/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ably";
exports.ids = ["vendor-chunks/ably"];
exports.modules = {

/***/ "(rsc)/./node_modules/ably/build/ably-node.js":
/*!**********************************************!*\
  !*** ./node_modules/ably/build/ably-node.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)\n\nAbly JavaScript Library v2.7.0\nhttps://github.com/ably/ably-js\n\nReleased under the Apache Licence v2.0*/(function (g, f) {\n    if (true) {\n      module.exports = f(__webpack_require__(/*! ws */ \"(rsc)/./node_modules/ably/node_modules/ws/index.js\"), __webpack_require__(/*! got */ \"(rsc)/./node_modules/got/dist/source/index.js\"));\n    } else {}\n  }(this, (__da, __db) => {\nvar exports = {};\nvar module = { exports };\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// node_modules/bops/from.js\nvar require_from = __commonJS({\n  \"node_modules/bops/from.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    var version2 = ((process || {}).version || \"v0.0.0\").slice(1).split(\".\")[0];\n    module2.exports = Number(version2) < 6 ? function from(source, encoding) {\n      return new Buffer2(source, encoding);\n    } : function from(source, encoding) {\n      return Buffer2.from(source, encoding);\n    };\n  }\n});\n\n// node_modules/bops/to.js\nvar require_to = __commonJS({\n  \"node_modules/bops/to.js\"(exports2, module2) {\n    module2.exports = function(source, encoding) {\n      return source.toString(encoding);\n    };\n  }\n});\n\n// node_modules/bops/is.js\nvar require_is = __commonJS({\n  \"node_modules/bops/is.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    module2.exports = function(buffer) {\n      return Buffer2.isBuffer(buffer);\n    };\n  }\n});\n\n// node_modules/bops/subarray.js\nvar require_subarray = __commonJS({\n  \"node_modules/bops/subarray.js\"(exports2, module2) {\n    module2.exports = function(source, from, to) {\n      return arguments.length === 2 ? source.slice(from) : source.slice(from, to);\n    };\n  }\n});\n\n// node_modules/bops/join.js\nvar require_join = __commonJS({\n  \"node_modules/bops/join.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    module2.exports = function(targets, hint) {\n      return hint !== void 0 ? Buffer2.concat(targets, hint) : Buffer2.concat(targets);\n    };\n  }\n});\n\n// node_modules/bops/copy.js\nvar require_copy = __commonJS({\n  \"node_modules/bops/copy.js\"(exports2, module2) {\n    module2.exports = copy2;\n    function copy2(source, target, target_start, source_start, source_end) {\n      return source.copy(target, target_start, source_start, source_end);\n    }\n  }\n});\n\n// node_modules/bops/create.js\nvar require_create = __commonJS({\n  \"node_modules/bops/create.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    var version2 = ((process || {}).version || \"v0.0.0\").slice(1).split(\".\")[0];\n    module2.exports = Number(version2) < 6 ? function create(size) {\n      return new Buffer2(size);\n    } : function create(size) {\n      return Buffer2.alloc(size);\n    };\n  }\n});\n\n// node_modules/bops/read.js\nvar require_read = __commonJS({\n  \"node_modules/bops/read.js\"(exports2, module2) {\n    var proto = {};\n    var rex = /read.+/;\n    var buildFn;\n    buildFn = function(key2) {\n      var code = \"return buf.\" + key2 + \"(\" + [\"a\", \"b\", \"c\"].join(\",\") + \")\";\n      return new Function([\"buf\", \"a\", \"b\", \"c\"], code);\n    };\n    module2.exports = proto;\n    for (key in Buffer.prototype) {\n      if (rex.test(key)) {\n        proto[key] = buildFn(key);\n      }\n    }\n    var key;\n  }\n});\n\n// node_modules/bops/write.js\nvar require_write = __commonJS({\n  \"node_modules/bops/write.js\"(exports2, module2) {\n    var Buffer2 = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    var proto = {};\n    var rex = /write.+/;\n    var buildFn;\n    buildFn = function(key2) {\n      var code = \"return buf.\" + key2 + \"(\" + [\"a\", \"b\", \"c\"].join(\",\") + \")\";\n      return new Function([\"buf\", \"a\", \"b\", \"c\"], code);\n    };\n    module2.exports = proto;\n    for (key in Buffer2.prototype) {\n      if (rex.test(key)) {\n        proto[key] = buildFn(key);\n      }\n    }\n    var key;\n  }\n});\n\n// node_modules/bops/index.js\nvar require_bops = __commonJS({\n  \"node_modules/bops/index.js\"(exports2, module2) {\n    var proto = {};\n    module2.exports = proto;\n    proto.from = require_from();\n    proto.to = require_to();\n    proto.is = require_is();\n    proto.subarray = require_subarray();\n    proto.join = require_join();\n    proto.copy = require_copy();\n    proto.create = require_create();\n    mix(require_read(), proto);\n    mix(require_write(), proto);\n    function mix(from, into) {\n      for (var key in from) {\n        into[key] = from[key];\n      }\n    }\n  }\n});\n\n// node_modules/@ably/msgpack-js/msgpack.js\nvar require_msgpack = __commonJS({\n  \"node_modules/@ably/msgpack-js/msgpack.js\"(exports2) {\n    \"use strict\";\n    var bops = require_bops();\n    exports2.encode = function(value, sparse) {\n      var size = sizeof(value, sparse);\n      if (size == 0)\n        return void 0;\n      var buffer = bops.create(size);\n      encode2(value, buffer, 0, sparse);\n      return buffer;\n    };\n    exports2.decode = decode2;\n    var SH_L_32 = (1 << 16) * (1 << 16);\n    var SH_R_32 = 1 / SH_L_32;\n    function readInt64BE(buf, offset) {\n      offset = offset || 0;\n      return buf.readInt32BE(offset + 0) * SH_L_32 + buf.readUInt32BE(offset + 4);\n    }\n    function readUInt64BE(buf, offset) {\n      offset = offset || 0;\n      return buf.readUInt32BE(offset + 0) * SH_L_32 + buf.readUInt32BE(offset + 4);\n    }\n    function writeInt64BE(buf, val, offset) {\n      if (val < 9223372036854776e3) {\n        buf.writeInt32BE(Math.floor(val * SH_R_32), offset);\n        buf.writeInt32BE(val & -1, offset + 4);\n      } else {\n        buf.writeUInt32BE(2147483647, offset);\n        buf.writeUInt32BE(4294967295, offset + 4);\n      }\n    }\n    function writeUInt64BE(buf, val, offset) {\n      if (val < 18446744073709552e3) {\n        buf.writeUInt32BE(Math.floor(val * SH_R_32), offset);\n        buf.writeInt32BE(val & -1, offset + 4);\n      } else {\n        buf.writeUInt32BE(4294967295, offset);\n        buf.writeUInt32BE(4294967295, offset + 4);\n      }\n    }\n    function Decoder(buffer, offset) {\n      this.offset = offset || 0;\n      this.buffer = buffer;\n      this.bufferLength = buffer.length;\n    }\n    Decoder.prototype.map = function(length) {\n      if (length * 2 > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a map of length ${length})`);\n      }\n      var value = {};\n      for (var i = 0; i < length; i++) {\n        var key = this.parse();\n        value[key] = this.parse();\n      }\n      return value;\n    };\n    Decoder.prototype.bin = Decoder.prototype.buf = function(length) {\n      if (length > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a binary of length ${length})`);\n      }\n      var value = bops.subarray(this.buffer, this.offset, this.offset + length);\n      this.offset += length;\n      return value;\n    };\n    Decoder.prototype.str = function(length) {\n      if (length > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a string of length ${length})`);\n      }\n      var value = bops.to(bops.subarray(this.buffer, this.offset, this.offset + length));\n      this.offset += length;\n      return value;\n    };\n    Decoder.prototype.array = function(length) {\n      if (length > this.bufferLength) {\n        throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced an array of length ${length})`);\n      }\n      var value = new Array(length);\n      for (var i = 0; i < length; i++) {\n        value[i] = this.parse();\n      }\n      return value;\n    };\n    Decoder.prototype.parse = function() {\n      var type = this.buffer[this.offset];\n      var value, length, extType;\n      if (type === void 0) {\n        throw new Error(\"malformed messagepack (referenced offset is outside buffer)\");\n      }\n      if ((type & 128) === 0) {\n        this.offset++;\n        return type;\n      }\n      if ((type & 240) === 128) {\n        length = type & 15;\n        this.offset++;\n        return this.map(length);\n      }\n      if ((type & 240) === 144) {\n        length = type & 15;\n        this.offset++;\n        return this.array(length);\n      }\n      if ((type & 224) === 160) {\n        length = type & 31;\n        this.offset++;\n        return this.str(length);\n      }\n      if ((type & 224) === 224) {\n        value = bops.readInt8(this.buffer, this.offset);\n        this.offset++;\n        return value;\n      }\n      switch (type) {\n        case 192:\n          this.offset++;\n          return null;\n        case 194:\n          this.offset++;\n          return false;\n        case 195:\n          this.offset++;\n          return true;\n        case 196:\n          length = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return this.bin(length);\n        case 197:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.bin(length);\n        case 198:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.bin(length);\n        case 199:\n          length = bops.readUInt8(this.buffer, this.offset + 1);\n          extType = bops.readUInt8(this.buffer, this.offset + 2);\n          this.offset += 3;\n          return [extType, this.bin(length)];\n        case 200:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          extType = bops.readUInt8(this.buffer, this.offset + 3);\n          this.offset += 4;\n          return [extType, this.bin(length)];\n        case 201:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          extType = bops.readUInt8(this.buffer, this.offset + 5);\n          this.offset += 6;\n          return [extType, this.bin(length)];\n        case 202:\n          value = bops.readFloatBE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 203:\n          value = bops.readDoubleBE(this.buffer, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 204:\n          value = this.buffer[this.offset + 1];\n          this.offset += 2;\n          return value;\n        case 205:\n          value = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return value;\n        case 206:\n          value = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 207:\n          value = readUInt64BE(this.buffer, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 208:\n          value = bops.readInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return value;\n        case 209:\n          value = bops.readInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return value;\n        case 210:\n          value = bops.readInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return value;\n        case 211:\n          value = readInt64BE(this.buffer, this.offset + 1);\n          this.offset += 9;\n          return value;\n        case 212:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          value = bops.readUInt8(this.buffer, this.offset + 2);\n          this.offset += 3;\n          return extType === 0 && value === 0 ? void 0 : [extType, value];\n        case 213:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(2)];\n        case 214:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(4)];\n        case 215:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(8)];\n        case 216:\n          extType = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return [extType, this.bin(16)];\n        case 217:\n          length = bops.readUInt8(this.buffer, this.offset + 1);\n          this.offset += 2;\n          return this.str(length);\n        case 218:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.str(length);\n        case 219:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.str(length);\n        case 220:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.array(length);\n        case 221:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.array(length);\n        case 222:\n          length = bops.readUInt16BE(this.buffer, this.offset + 1);\n          this.offset += 3;\n          return this.map(length);\n        case 223:\n          length = bops.readUInt32BE(this.buffer, this.offset + 1);\n          this.offset += 5;\n          return this.map(length);\n      }\n      throw new Error(\"Unknown type 0x\" + type.toString(16));\n    };\n    function decode2(buffer) {\n      var decoder = new Decoder(buffer);\n      var value = decoder.parse();\n      if (decoder.offset !== buffer.length)\n        throw new Error(buffer.length - decoder.offset + \" trailing bytes\");\n      return value;\n    }\n    function encodeableKeys(value, sparse) {\n      return Object.keys(value).filter(function(e) {\n        var val = value[e], type = typeof val;\n        return (!sparse || val !== void 0 && val !== null) && (\"function\" !== type || !!val.toJSON);\n      });\n    }\n    function encode2(value, buffer, offset, sparse, isMapElement) {\n      var type = typeof value;\n      var length, size;\n      if (type === \"string\") {\n        value = bops.from(value);\n        length = value.length;\n        if (length < 32) {\n          buffer[offset] = length | 160;\n          bops.copy(value, buffer, offset + 1);\n          return 1 + length;\n        }\n        if (length < 256) {\n          buffer[offset] = 217;\n          bops.writeUInt8(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 2);\n          return 2 + length;\n        }\n        if (length < 65536) {\n          buffer[offset] = 218;\n          bops.writeUInt16BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 3);\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          buffer[offset] = 219;\n          bops.writeUInt32BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 5);\n          return 5 + length;\n        }\n      }\n      if (bops.is(value)) {\n        length = value.length;\n        if (length < 256) {\n          buffer[offset] = 196;\n          bops.writeUInt8(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 2);\n          return 2 + length;\n        }\n        if (length < 65536) {\n          buffer[offset] = 197;\n          bops.writeUInt16BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 3);\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          buffer[offset] = 198;\n          bops.writeUInt32BE(buffer, length, offset + 1);\n          bops.copy(value, buffer, offset + 5);\n          return 5 + length;\n        }\n      }\n      if (type === \"number\") {\n        if (Math.floor(value) !== value) {\n          buffer[offset] = 203;\n          bops.writeDoubleBE(buffer, value, offset + 1);\n          return 9;\n        }\n        if (value >= 0) {\n          if (value < 128) {\n            buffer[offset] = value;\n            return 1;\n          }\n          if (value < 256) {\n            buffer[offset] = 204;\n            buffer[offset + 1] = value;\n            return 2;\n          }\n          if (value < 65536) {\n            buffer[offset] = 205;\n            bops.writeUInt16BE(buffer, value, offset + 1);\n            return 3;\n          }\n          if (value < 4294967296) {\n            buffer[offset] = 206;\n            bops.writeUInt32BE(buffer, value, offset + 1);\n            return 5;\n          }\n          if (value < 18446744073709552e3) {\n            buffer[offset] = 207;\n            writeUInt64BE(buffer, value, offset + 1);\n            return 9;\n          }\n          throw new Error(\"Number too big 0x\" + value.toString(16));\n        }\n        if (value >= -32) {\n          bops.writeInt8(buffer, value, offset);\n          return 1;\n        }\n        if (value >= -128) {\n          buffer[offset] = 208;\n          bops.writeInt8(buffer, value, offset + 1);\n          return 2;\n        }\n        if (value >= -32768) {\n          buffer[offset] = 209;\n          bops.writeInt16BE(buffer, value, offset + 1);\n          return 3;\n        }\n        if (value >= -2147483648) {\n          buffer[offset] = 210;\n          bops.writeInt32BE(buffer, value, offset + 1);\n          return 5;\n        }\n        if (value >= -9223372036854776e3) {\n          buffer[offset] = 211;\n          writeInt64BE(buffer, value, offset + 1);\n          return 9;\n        }\n        throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n      }\n      if (type === \"undefined\") {\n        if (sparse && isMapElement)\n          return 0;\n        buffer[offset] = 212;\n        buffer[offset + 1] = 0;\n        buffer[offset + 2] = 0;\n        return 3;\n      }\n      if (value === null) {\n        if (sparse && isMapElement)\n          return 0;\n        buffer[offset] = 192;\n        return 1;\n      }\n      if (type === \"boolean\") {\n        buffer[offset] = value ? 195 : 194;\n        return 1;\n      }\n      if (\"function\" === typeof value.toJSON)\n        return encode2(value.toJSON(), buffer, offset, sparse);\n      if (type === \"object\") {\n        size = 0;\n        var isArray = Array.isArray(value);\n        if (isArray) {\n          length = value.length;\n        } else {\n          var keys = encodeableKeys(value, sparse);\n          length = keys.length;\n        }\n        if (length < 16) {\n          buffer[offset] = length | (isArray ? 144 : 128);\n          size = 1;\n        } else if (length < 65536) {\n          buffer[offset] = isArray ? 220 : 222;\n          bops.writeUInt16BE(buffer, length, offset + 1);\n          size = 3;\n        } else if (length < 4294967296) {\n          buffer[offset] = isArray ? 221 : 223;\n          bops.writeUInt32BE(buffer, length, offset + 1);\n          size = 5;\n        }\n        if (isArray) {\n          for (var i = 0; i < length; i++) {\n            size += encode2(value[i], buffer, offset + size, sparse);\n          }\n        } else {\n          for (var i = 0; i < length; i++) {\n            var key = keys[i];\n            size += encode2(key, buffer, offset + size);\n            size += encode2(value[key], buffer, offset + size, sparse, true);\n          }\n        }\n        return size;\n      }\n      if (type === \"function\")\n        return void 0;\n      throw new Error(\"Unknown type \" + type);\n    }\n    function sizeof(value, sparse, isMapElement) {\n      var type = typeof value;\n      var length, size;\n      if (type === \"string\") {\n        length = bops.from(value).length;\n        if (length < 32) {\n          return 1 + length;\n        }\n        if (length < 256) {\n          return 2 + length;\n        }\n        if (length < 65536) {\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          return 5 + length;\n        }\n      }\n      if (bops.is(value)) {\n        length = value.length;\n        if (length < 256) {\n          return 2 + length;\n        }\n        if (length < 65536) {\n          return 3 + length;\n        }\n        if (length < 4294967296) {\n          return 5 + length;\n        }\n      }\n      if (type === \"number\") {\n        if (Math.floor(value) !== value)\n          return 9;\n        if (value >= 0) {\n          if (value < 128)\n            return 1;\n          if (value < 256)\n            return 2;\n          if (value < 65536)\n            return 3;\n          if (value < 4294967296)\n            return 5;\n          if (value < 18446744073709552e3)\n            return 9;\n          throw new Error(\"Number too big 0x\" + value.toString(16));\n        }\n        if (value >= -32)\n          return 1;\n        if (value >= -128)\n          return 2;\n        if (value >= -32768)\n          return 3;\n        if (value >= -2147483648)\n          return 5;\n        if (value >= -9223372036854776e3)\n          return 9;\n        throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n      }\n      if (type === \"boolean\")\n        return 1;\n      if (value === null)\n        return sparse && isMapElement ? 0 : 1;\n      if (value === void 0)\n        return sparse && isMapElement ? 0 : 3;\n      if (\"function\" === typeof value.toJSON)\n        return sizeof(value.toJSON(), sparse);\n      if (type === \"object\") {\n        size = 0;\n        if (Array.isArray(value)) {\n          length = value.length;\n          for (var i = 0; i < length; i++) {\n            size += sizeof(value[i], sparse);\n          }\n        } else {\n          var keys = encodeableKeys(value, sparse);\n          length = keys.length;\n          for (var i = 0; i < length; i++) {\n            var key = keys[i];\n            size += sizeof(key) + sizeof(value[key], sparse, true);\n          }\n        }\n        if (length < 16) {\n          return 1 + size;\n        }\n        if (length < 65536) {\n          return 3 + size;\n        }\n        if (length < 4294967296) {\n          return 5 + size;\n        }\n        throw new Error(\"Array or object too long 0x\" + length.toString(16));\n      }\n      if (type === \"function\")\n        return 0;\n      throw new Error(\"Unknown type \" + type);\n    }\n  }\n});\n\n// src/common/platform.ts\nvar Platform = class {\n};\n\n// src/common/lib/util/logger.ts\nvar globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : self;\nfunction pad(timeSegment, three) {\n  return `${timeSegment}`.padStart(three ? 3 : 2, \"0\");\n}\nfunction getHandler(logger) {\n  return Platform.Config.logTimestamps ? function(msg) {\n    const time = /* @__PURE__ */ new Date();\n    logger(\n      pad(time.getHours()) + \":\" + pad(time.getMinutes()) + \":\" + pad(time.getSeconds()) + \".\" + pad(time.getMilliseconds(), 1) + \" \" + msg\n    );\n  } : function(msg) {\n    logger(msg);\n  };\n}\nvar getDefaultLoggers = () => {\n  var _a2;\n  let consoleLogger;\n  let errorLogger;\n  if (typeof ((_a2 = globalObject == null ? void 0 : globalObject.console) == null ? void 0 : _a2.log) === \"function\") {\n    consoleLogger = function(...args) {\n      console.log.apply(console, args);\n    };\n    errorLogger = console.warn ? function(...args) {\n      console.warn.apply(console, args);\n    } : consoleLogger;\n  } else {\n    consoleLogger = errorLogger = function() {\n    };\n  }\n  return [consoleLogger, errorLogger].map(getHandler);\n};\nvar _Logger = class _Logger {\n  constructor() {\n    this.deprecated = (description, msg) => {\n      this.deprecationWarning(`${description} is deprecated and will be removed in a future version. ${msg}`);\n    };\n    /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\n      the object being serialised if the log level will not output the message */\n    this.shouldLog = (level) => {\n      return level <= this.logLevel;\n    };\n    this.setLog = (level, handler) => {\n      if (level !== void 0)\n        this.logLevel = level;\n      if (handler !== void 0)\n        this.logHandler = this.logErrorHandler = handler;\n    };\n    this.logLevel = _Logger.defaultLogLevel;\n    this.logHandler = _Logger.defaultLogHandler;\n    this.logErrorHandler = _Logger.defaultLogErrorHandler;\n  }\n  static initLogHandlers() {\n    const [logHandler, logErrorHandler] = getDefaultLoggers();\n    this.defaultLogHandler = logHandler;\n    this.defaultLogErrorHandler = logErrorHandler;\n    this.defaultLogger = new _Logger();\n  }\n  /**\n   * Calls to this method are never stripped by the `stripLogs` esbuild plugin. Use it for log statements that you wish to always be included in the modular variant of the SDK.\n   */\n  static logActionNoStrip(logger, level, action, message) {\n    logger.logAction(level, action, message);\n  }\n  logAction(level, action, message) {\n    if (this.shouldLog(level)) {\n      (level === 1 /* Error */ ? this.logErrorHandler : this.logHandler)(\"Ably: \" + action + \": \" + message, level);\n    }\n  }\n  renamedClientOption(oldName, newName) {\n    this.deprecationWarning(\n      `The \\`${oldName}\\` client option has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`\n    );\n  }\n  renamedMethod(className, oldName, newName) {\n    this.deprecationWarning(\n      `\\`${className}\\`\\u2019s \\`${oldName}\\` method has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`\n    );\n  }\n  deprecationWarning(message) {\n    if (this.shouldLog(1 /* Error */)) {\n      this.logErrorHandler(`Ably: Deprecation warning - ${message}`, 1 /* Error */);\n    }\n  }\n};\n_Logger.defaultLogLevel = 1 /* Error */;\n// public constants\n_Logger.LOG_NONE = 0 /* None */;\n_Logger.LOG_ERROR = 1 /* Error */;\n_Logger.LOG_MAJOR = 2 /* Major */;\n_Logger.LOG_MINOR = 3 /* Minor */;\n_Logger.LOG_MICRO = 4 /* Micro */;\n/* public static functions */\n/**\n * In the modular variant of the SDK, the `stripLogs` esbuild plugin strips out all calls to this method (when invoked as `Logger.logAction(...)`) except when called with level `Logger.LOG_ERROR`. If you wish for a log statement to never be stripped, use the {@link logActionNoStrip} method instead.\n *\n * The aforementioned plugin expects `level` to be an expression of the form `Logger.LOG_*`; that is, you can’t dynamically specify the log level.\n */\n_Logger.logAction = (logger, level, action, message) => {\n  _Logger.logActionNoStrip(logger, level, action, message);\n};\nvar Logger = _Logger;\nvar logger_default = Logger;\n\n// src/common/lib/util/utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Format: () => Format,\n  allSame: () => allSame,\n  allToLowerCase: () => allToLowerCase,\n  allToUpperCase: () => allToUpperCase,\n  arrChooseN: () => arrChooseN,\n  arrDeleteValue: () => arrDeleteValue,\n  arrEquals: () => arrEquals,\n  arrIntersect: () => arrIntersect,\n  arrIntersectOb: () => arrIntersectOb,\n  arrPopRandomElement: () => arrPopRandomElement,\n  arrSubtract: () => arrSubtract,\n  arrWithoutValue: () => arrWithoutValue,\n  cheapRandStr: () => cheapRandStr,\n  containsValue: () => containsValue,\n  copy: () => copy,\n  createMissingPluginError: () => createMissingPluginError,\n  dataSizeBytes: () => dataSizeBytes,\n  decodeBody: () => decodeBody,\n  encodeBody: () => encodeBody,\n  ensureArray: () => ensureArray,\n  forInOwnNonNullProperties: () => forInOwnNonNullProperties,\n  getBackoffCoefficient: () => getBackoffCoefficient,\n  getGlobalObject: () => getGlobalObject,\n  getJitterCoefficient: () => getJitterCoefficient,\n  getRetryTime: () => getRetryTime,\n  inherits: () => inherits,\n  inspectBody: () => inspectBody,\n  inspectError: () => inspectError,\n  intersect: () => intersect,\n  isEmpty: () => isEmpty,\n  isErrorInfoOrPartialErrorInfo: () => isErrorInfoOrPartialErrorInfo,\n  isNil: () => isNil,\n  isObject: () => isObject,\n  keysArray: () => keysArray,\n  matchDerivedChannel: () => matchDerivedChannel,\n  mixin: () => mixin,\n  parseQueryString: () => parseQueryString,\n  prototypicalClone: () => prototypicalClone,\n  randomString: () => randomString,\n  shallowClone: () => shallowClone,\n  shallowEquals: () => shallowEquals,\n  throwMissingPluginError: () => throwMissingPluginError,\n  toBase64: () => toBase64,\n  toQueryString: () => toQueryString,\n  valuesArray: () => valuesArray,\n  whenPromiseSettles: () => whenPromiseSettles,\n  withTimeoutAsync: () => withTimeoutAsync\n});\n\n// src/common/lib/types/errorinfo.ts\nfunction toString(err) {\n  let result = \"[\" + err.constructor.name;\n  if (err.message)\n    result += \": \" + err.message;\n  if (err.statusCode)\n    result += \"; statusCode=\" + err.statusCode;\n  if (err.code)\n    result += \"; code=\" + err.code;\n  if (err.cause)\n    result += \"; cause=\" + inspectError(err.cause);\n  if (err.href && !(err.message && err.message.indexOf(\"help.ably.io\") > -1))\n    result += \"; see \" + err.href + \" \";\n  result += \"]\";\n  return result;\n}\nvar ErrorInfo = class _ErrorInfo extends Error {\n  constructor(message, code, statusCode, cause) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== \"undefined\") {\n      Object.setPrototypeOf(this, _ErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  toString() {\n    return toString(this);\n  }\n  static fromValues(values) {\n    const { message, code, statusCode } = values;\n    if (typeof message !== \"string\" || typeof code !== \"number\" || typeof statusCode !== \"number\") {\n      throw new Error(\"ErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new _ErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = \"https://help.ably.io/error/\" + result.code;\n    }\n    return result;\n  }\n};\nvar PartialErrorInfo = class _PartialErrorInfo extends Error {\n  constructor(message, code, statusCode, cause) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== \"undefined\") {\n      Object.setPrototypeOf(this, _PartialErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n  toString() {\n    return toString(this);\n  }\n  static fromValues(values) {\n    const { message, code, statusCode } = values;\n    if (typeof message !== \"string\" || !isNil(code) && typeof code !== \"number\" || !isNil(statusCode) && typeof statusCode !== \"number\") {\n      throw new Error(\"PartialErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new _PartialErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = \"https://help.ably.io/error/\" + result.code;\n    }\n    return result;\n  }\n};\n\n// src/common/lib/util/utils.ts\nfunction randomPosn(arrOrStr) {\n  return Math.floor(Math.random() * arrOrStr.length);\n}\nfunction mixin(target, ...args) {\n  for (let i = 0; i < args.length; i++) {\n    const source = args[i];\n    if (!source) {\n      break;\n    }\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}\nfunction copy(src) {\n  return mixin({}, src);\n}\nfunction ensureArray(obj) {\n  if (isNil(obj)) {\n    return [];\n  }\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\nfunction isObject(ob) {\n  return Object.prototype.toString.call(ob) == \"[object Object]\";\n}\nfunction isEmpty(ob) {\n  for (const prop in ob)\n    return false;\n  return true;\n}\nfunction isNil(arg) {\n  return arg == null;\n}\nfunction shallowClone(ob) {\n  const result = new Object();\n  for (const prop in ob)\n    result[prop] = ob[prop];\n  return result;\n}\nfunction prototypicalClone(ob, ownProperties) {\n  class F {\n  }\n  F.prototype = ob;\n  const result = new F();\n  if (ownProperties)\n    mixin(result, ownProperties);\n  return result;\n}\nvar inherits = function(ctor, superCtor) {\n  if (Platform.Config.inherits) {\n    Platform.Config.inherits(ctor, superCtor);\n    return;\n  }\n  ctor.super_ = superCtor;\n  ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });\n};\nfunction containsValue(ob, val) {\n  for (const i in ob) {\n    if (ob[i] == val)\n      return true;\n  }\n  return false;\n}\nfunction intersect(arr, ob) {\n  return Array.isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\n}\nfunction arrIntersect(arr1, arr2) {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const member = arr1[i];\n    if (arr2.indexOf(member) != -1)\n      result.push(member);\n  }\n  return result;\n}\nfunction arrIntersectOb(arr, ob) {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const member = arr[i];\n    if (member in ob)\n      result.push(member);\n  }\n  return result;\n}\nfunction arrSubtract(arr1, arr2) {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const element = arr1[i];\n    if (arr2.indexOf(element) == -1)\n      result.push(element);\n  }\n  return result;\n}\nfunction arrDeleteValue(arr, val) {\n  const idx = arr.indexOf(val);\n  const res = idx != -1;\n  if (res)\n    arr.splice(idx, 1);\n  return res;\n}\nfunction arrWithoutValue(arr, val) {\n  const newArr = arr.slice();\n  arrDeleteValue(newArr, val);\n  return newArr;\n}\nfunction keysArray(ob, ownOnly) {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n      continue;\n    result.push(prop);\n  }\n  return result;\n}\nfunction valuesArray(ob, ownOnly) {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n      continue;\n    result.push(ob[prop]);\n  }\n  return result;\n}\nfunction forInOwnNonNullProperties(ob, fn) {\n  for (const prop in ob) {\n    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\n      fn(prop);\n    }\n  }\n}\nfunction allSame(arr, prop) {\n  if (arr.length === 0) {\n    return true;\n  }\n  const first = arr[0][prop];\n  return arr.every(function(item) {\n    return item[prop] === first;\n  });\n}\nvar Format = /* @__PURE__ */ ((Format2) => {\n  Format2[\"msgpack\"] = \"msgpack\";\n  Format2[\"json\"] = \"json\";\n  return Format2;\n})(Format || {});\nfunction arrPopRandomElement(arr) {\n  return arr.splice(randomPosn(arr), 1)[0];\n}\nfunction toQueryString(params) {\n  const parts = [];\n  if (params) {\n    for (const key in params)\n      parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n  }\n  return parts.length ? \"?\" + parts.join(\"&\") : \"\";\n}\nfunction parseQueryString(query) {\n  let match;\n  const search = /([^?&=]+)=?([^&]*)/g;\n  const result = {};\n  while (match = search.exec(query))\n    result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\n  return result;\n}\nfunction isErrorInfoOrPartialErrorInfo(err) {\n  return typeof err == \"object\" && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);\n}\nfunction inspectError(err) {\n  var _a2, _b;\n  if (err instanceof Error || ((_a2 = err == null ? void 0 : err.constructor) == null ? void 0 : _a2.name) === \"ErrorInfo\" || ((_b = err == null ? void 0 : err.constructor) == null ? void 0 : _b.name) === \"PartialErrorInfo\")\n    return err.toString();\n  return Platform.Config.inspect(err);\n}\nfunction inspectBody(body) {\n  if (Platform.BufferUtils.isBuffer(body)) {\n    return body.toString();\n  } else if (typeof body === \"string\") {\n    return body;\n  } else {\n    return Platform.Config.inspect(body);\n  }\n}\nfunction dataSizeBytes(data) {\n  if (Platform.BufferUtils.isBuffer(data)) {\n    return Platform.BufferUtils.byteLength(data);\n  }\n  if (typeof data === \"string\") {\n    return Platform.Config.stringByteSize(data);\n  }\n  throw new Error(\"Expected input of Utils.dataSizeBytes to be a buffer or string, but was: \" + typeof data);\n}\nfunction cheapRandStr() {\n  return String(Math.random()).substr(2);\n}\nvar randomString = async (numBytes) => {\n  const buffer = await Platform.Config.getRandomArrayBuffer(numBytes);\n  return Platform.BufferUtils.base64Encode(buffer);\n};\nfunction arrChooseN(arr, n) {\n  const numItems = Math.min(n, arr.length), mutableArr = arr.slice(), result = [];\n  for (let i = 0; i < numItems; i++) {\n    result.push(arrPopRandomElement(mutableArr));\n  }\n  return result;\n}\nfunction whenPromiseSettles(promise, callback) {\n  promise.then((result) => {\n    callback == null ? void 0 : callback(null, result);\n  }).catch((err) => {\n    callback == null ? void 0 : callback(err);\n  });\n}\nfunction decodeBody(body, MsgPack, format) {\n  if (format == \"msgpack\") {\n    if (!MsgPack) {\n      throwMissingPluginError(\"MsgPack\");\n    }\n    return MsgPack.decode(body);\n  }\n  return JSON.parse(String(body));\n}\nfunction encodeBody(body, MsgPack, format) {\n  if (format == \"msgpack\") {\n    if (!MsgPack) {\n      throwMissingPluginError(\"MsgPack\");\n    }\n    return MsgPack.encode(body, true);\n  }\n  return JSON.stringify(body);\n}\nfunction allToLowerCase(arr) {\n  return arr.map(function(element) {\n    return element && element.toLowerCase();\n  });\n}\nfunction allToUpperCase(arr) {\n  return arr.map(function(element) {\n    return element && element.toUpperCase();\n  });\n}\nfunction getBackoffCoefficient(count) {\n  return Math.min((count + 2) / 3, 2);\n}\nfunction getJitterCoefficient() {\n  return 1 - Math.random() * 0.2;\n}\nfunction getRetryTime(initialTimeout, retryAttempt) {\n  return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();\n}\nfunction getGlobalObject() {\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  return self;\n}\nfunction shallowEquals(source, target) {\n  return Object.keys(source).every((key) => source[key] === target[key]) && Object.keys(target).every((key) => target[key] === source[key]);\n}\nfunction matchDerivedChannel(name) {\n  const regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/;\n  const match = name.match(regex);\n  if (!match || !match.length || match.length < 5) {\n    throw new ErrorInfo(\"regex match failed\", 400, 40010);\n  }\n  if (match[2]) {\n    throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);\n  }\n  return {\n    qualifierParam: match[3] || \"\",\n    channelName: match[4]\n  };\n}\nfunction toBase64(str) {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(str);\n  return bufferUtils.base64Encode(textBuffer);\n}\nfunction arrEquals(a, b) {\n  return a.length === b.length && a.every(function(val, i) {\n    return val === b[i];\n  });\n}\nfunction createMissingPluginError(pluginName) {\n  return new ErrorInfo(`${pluginName} plugin not provided`, 40019, 400);\n}\nfunction throwMissingPluginError(pluginName) {\n  throw createMissingPluginError(pluginName);\n}\nasync function withTimeoutAsync(promise, timeout = 5e3, err = \"Timeout expired\") {\n  const e = new ErrorInfo(err, 5e4, 500);\n  return Promise.race([promise, new Promise((_resolve, reject) => setTimeout(() => reject(e), timeout))]);\n}\n\n// package.json\nvar version = \"2.7.0\";\n\n// src/common/lib/util/defaults.ts\nvar agent = \"ably-js/\" + version;\nvar Defaults = {\n  ENVIRONMENT: \"\",\n  REST_HOST: \"rest.ably.io\",\n  REALTIME_HOST: \"realtime.ably.io\",\n  FALLBACK_HOSTS: [\n    \"A.ably-realtime.com\",\n    \"B.ably-realtime.com\",\n    \"C.ably-realtime.com\",\n    \"D.ably-realtime.com\",\n    \"E.ably-realtime.com\"\n  ],\n  PORT: 80,\n  TLS_PORT: 443,\n  TIMEOUTS: {\n    /* Documented as options params: */\n    disconnectedRetryTimeout: 15e3,\n    suspendedRetryTimeout: 3e4,\n    /* Undocumented, but part of the api and can be used by customers: */\n    httpRequestTimeout: 1e4,\n    httpMaxRetryDuration: 15e3,\n    channelRetryTimeout: 15e3,\n    fallbackRetryTimeout: 6e5,\n    /* For internal / test use only: */\n    connectionStateTtl: 12e4,\n    realtimeRequestTimeout: 1e4,\n    recvTimeout: 9e4,\n    webSocketConnectTimeout: 1e4,\n    webSocketSlowTimeout: 4e3\n  },\n  httpMaxRetryCount: 3,\n  maxMessageSize: 65536,\n  version,\n  protocolVersion: 3,\n  agent,\n  getHost,\n  getPort,\n  getHttpScheme,\n  environmentFallbackHosts,\n  getFallbackHosts,\n  getHosts,\n  checkHost,\n  objectifyOptions,\n  normaliseOptions,\n  defaultGetHeaders,\n  defaultPostHeaders\n};\nfunction getHost(options, host, ws) {\n  if (ws)\n    host = host == options.restHost && options.realtimeHost || host || options.realtimeHost;\n  else\n    host = host || options.restHost;\n  return host;\n}\nfunction getPort(options, tls) {\n  return tls || options.tls ? options.tlsPort : options.port;\n}\nfunction getHttpScheme(options) {\n  return options.tls ? \"https://\" : \"http://\";\n}\nfunction environmentFallbackHosts(environment) {\n  return [\n    environment + \"-a-fallback.ably-realtime.com\",\n    environment + \"-b-fallback.ably-realtime.com\",\n    environment + \"-c-fallback.ably-realtime.com\",\n    environment + \"-d-fallback.ably-realtime.com\",\n    environment + \"-e-fallback.ably-realtime.com\"\n  ];\n}\nfunction getFallbackHosts(options) {\n  const fallbackHosts = options.fallbackHosts, httpMaxRetryCount = typeof options.httpMaxRetryCount !== \"undefined\" ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\n  return fallbackHosts ? arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\n}\nfunction getHosts(options, ws) {\n  const hosts = [options.restHost].concat(getFallbackHosts(options));\n  return ws ? hosts.map((host) => getHost(options, host, true)) : hosts;\n}\nfunction checkHost(host) {\n  if (typeof host !== \"string\") {\n    throw new ErrorInfo(\"host must be a string; was a \" + typeof host, 4e4, 400);\n  }\n  if (!host.length) {\n    throw new ErrorInfo(\"host must not be zero-length\", 4e4, 400);\n  }\n}\nfunction getRealtimeHost(options, production, environment, logger) {\n  if (options.realtimeHost)\n    return options.realtimeHost;\n  if (options.restHost) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MINOR,\n      \"Defaults.normaliseOptions\",\n      'restHost is set to \"' + options.restHost + '\" but realtimeHost is not set, so setting realtimeHost to \"' + options.restHost + '\" too. If this is not what you want, please set realtimeHost explicitly.'\n    );\n    return options.restHost;\n  }\n  return production ? Defaults.REALTIME_HOST : environment + \"-\" + Defaults.REALTIME_HOST;\n}\nfunction getTimeouts(options) {\n  const timeouts = {};\n  for (const prop in Defaults.TIMEOUTS) {\n    timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];\n  }\n  return timeouts;\n}\nfunction getAgentString(options) {\n  let agentStr = Defaults.agent;\n  if (options.agents) {\n    for (var agent2 in options.agents) {\n      agentStr += \" \" + agent2 + \"/\" + options.agents[agent2];\n    }\n  }\n  return agentStr;\n}\nfunction objectifyOptions(options, allowKeyOrToken, sourceForErrorMessage, logger, modularPluginsToInclude) {\n  if (options === void 0) {\n    const msg = allowKeyOrToken ? `${sourceForErrorMessage} must be initialized with either a client options object, an Ably API key, or an Ably Token` : `${sourceForErrorMessage} must be initialized with a client options object`;\n    logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n    throw new Error(msg);\n  }\n  let optionsObj;\n  if (typeof options === \"string\") {\n    if (options.indexOf(\":\") == -1) {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably Token; you must provide a client options object with a \\`plugins\\` property. (Set this Ably Token as the object\\u2019s \\`token\\` property.)`;\n        logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n      optionsObj = { token: options };\n    } else {\n      if (!allowKeyOrToken) {\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably API key; you must provide a client options object with a \\`plugins\\` property. (Set this Ably API key as the object\\u2019s \\`key\\` property.)`;\n        logger_default.logAction(logger, logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n        throw new Error(msg);\n      }\n      optionsObj = { key: options };\n    }\n  } else {\n    optionsObj = options;\n  }\n  if (modularPluginsToInclude) {\n    optionsObj = __spreadProps(__spreadValues({}, optionsObj), { plugins: __spreadValues(__spreadValues({}, modularPluginsToInclude), optionsObj.plugins) });\n  }\n  return optionsObj;\n}\nfunction normaliseOptions(options, MsgPack, logger) {\n  const loggerToUse = logger != null ? logger : logger_default.defaultLogger;\n  if (typeof options.recover === \"function\" && options.closeOnUnload === true) {\n    logger_default.logAction(\n      loggerToUse,\n      logger_default.LOG_ERROR,\n      \"Defaults.normaliseOptions\",\n      \"closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter\"\n    );\n    options.recover = void 0;\n  }\n  if (!(\"closeOnUnload\" in options)) {\n    options.closeOnUnload = !options.recover;\n  }\n  if (!(\"queueMessages\" in options))\n    options.queueMessages = true;\n  const environment = options.environment && String(options.environment).toLowerCase() || Defaults.ENVIRONMENT;\n  const production = !environment || environment === \"production\";\n  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\n    options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);\n  }\n  const restHost = options.restHost || (production ? Defaults.REST_HOST : environment + \"-\" + Defaults.REST_HOST);\n  const realtimeHost = getRealtimeHost(options, production, environment, loggerToUse);\n  (options.fallbackHosts || []).concat(restHost, realtimeHost).forEach(checkHost);\n  options.port = options.port || Defaults.PORT;\n  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\n  if (!(\"tls\" in options))\n    options.tls = true;\n  const timeouts = getTimeouts(options);\n  if (MsgPack) {\n    if (\"useBinaryProtocol\" in options) {\n      options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;\n    } else {\n      options.useBinaryProtocol = Platform.Config.preferBinary;\n    }\n  } else {\n    options.useBinaryProtocol = false;\n  }\n  const headers = {};\n  if (options.clientId) {\n    headers[\"X-Ably-ClientId\"] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));\n  }\n  if (!(\"idempotentRestPublishing\" in options)) {\n    options.idempotentRestPublishing = true;\n  }\n  let connectivityCheckParams = null;\n  let connectivityCheckUrl = options.connectivityCheckUrl;\n  if (options.connectivityCheckUrl) {\n    let [uri, qs] = options.connectivityCheckUrl.split(\"?\");\n    connectivityCheckParams = qs ? parseQueryString(qs) : {};\n    if (uri.indexOf(\"://\") === -1) {\n      uri = \"https://\" + uri;\n    }\n    connectivityCheckUrl = uri;\n  }\n  let wsConnectivityCheckUrl = options.wsConnectivityCheckUrl;\n  if (wsConnectivityCheckUrl && wsConnectivityCheckUrl.indexOf(\"://\") === -1) {\n    wsConnectivityCheckUrl = \"wss://\" + wsConnectivityCheckUrl;\n  }\n  return __spreadProps(__spreadValues({}, options), {\n    realtimeHost,\n    restHost,\n    maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize,\n    timeouts,\n    connectivityCheckParams,\n    connectivityCheckUrl,\n    wsConnectivityCheckUrl,\n    headers\n  });\n}\nfunction normaliseChannelOptions(Crypto2, logger, options) {\n  const channelOptions = options || {};\n  if (channelOptions.cipher) {\n    if (!Crypto2)\n      throwMissingPluginError(\"Crypto\");\n    const cipher = Crypto2.getCipher(channelOptions.cipher, logger);\n    channelOptions.cipher = cipher.cipherParams;\n    channelOptions.channelCipher = cipher.cipher;\n  } else if (\"cipher\" in channelOptions) {\n    channelOptions.cipher = void 0;\n    channelOptions.channelCipher = null;\n  }\n  return channelOptions;\n}\nvar contentTypes = {\n  json: \"application/json\",\n  xml: \"application/xml\",\n  html: \"text/html\",\n  msgpack: \"application/x-msgpack\",\n  text: \"text/plain\"\n};\nvar defaultHeadersOptions = {\n  format: \"json\" /* json */,\n  protocolVersion: Defaults.protocolVersion\n};\nfunction defaultGetHeaders(options, {\n  format = defaultHeadersOptions.format,\n  protocolVersion = defaultHeadersOptions.protocolVersion\n} = {}) {\n  const accept = contentTypes[format];\n  return {\n    accept,\n    \"X-Ably-Version\": protocolVersion.toString(),\n    \"Ably-Agent\": getAgentString(options)\n  };\n}\nfunction defaultPostHeaders(options, {\n  format = defaultHeadersOptions.format,\n  protocolVersion = defaultHeadersOptions.protocolVersion\n} = {}) {\n  let contentType;\n  const accept = contentType = contentTypes[format];\n  return {\n    accept,\n    \"content-type\": contentType,\n    \"X-Ably-Version\": protocolVersion.toString(),\n    \"Ably-Agent\": getAgentString(options)\n  };\n}\nvar defaults_default = Defaults;\nfunction getDefaults(platformDefaults) {\n  return Object.assign(Defaults, platformDefaults);\n}\n\n// src/common/lib/util/multicaster.ts\nvar Multicaster = class _Multicaster {\n  // Private constructor; use static Multicaster.create instead\n  constructor(logger, members) {\n    this.logger = logger;\n    this.members = members || [];\n  }\n  call(err, result) {\n    for (const member of this.members) {\n      if (member) {\n        try {\n          member(err, result);\n        } catch (e) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"Multicaster multiple callback handler\",\n            \"Unexpected exception: \" + e + \"; stack = \" + e.stack\n          );\n        }\n      }\n    }\n  }\n  push(...args) {\n    this.members.push(...args);\n  }\n  createPromise() {\n    return new Promise((resolve, reject) => {\n      this.push((err, result) => {\n        err ? reject(err) : resolve(result);\n      });\n    });\n  }\n  resolveAll(result) {\n    this.call(null, result);\n  }\n  rejectAll(err) {\n    this.call(err);\n  }\n  static create(logger, members) {\n    const instance = new _Multicaster(logger, members);\n    return Object.assign((err, result) => instance.call(err, result), {\n      push: (fn) => instance.push(fn),\n      createPromise: () => instance.createPromise(),\n      resolveAll: (result) => instance.resolveAll(result),\n      rejectAll: (err) => instance.rejectAll(err)\n    });\n  }\n};\nvar multicaster_default = Multicaster;\n\n// src/common/constants/HttpMethods.ts\nvar HttpMethods = /* @__PURE__ */ ((HttpMethods2) => {\n  HttpMethods2[\"Get\"] = \"get\";\n  HttpMethods2[\"Delete\"] = \"delete\";\n  HttpMethods2[\"Post\"] = \"post\";\n  HttpMethods2[\"Put\"] = \"put\";\n  HttpMethods2[\"Patch\"] = \"patch\";\n  return HttpMethods2;\n})(HttpMethods || {});\nvar HttpMethods_default = HttpMethods;\n\n// src/common/constants/HttpStatusCodes.ts\nvar HttpStatusCodes = /* @__PURE__ */ ((HttpStatusCodes2) => {\n  HttpStatusCodes2[HttpStatusCodes2[\"Success\"] = 200] = \"Success\";\n  HttpStatusCodes2[HttpStatusCodes2[\"NoContent\"] = 204] = \"NoContent\";\n  HttpStatusCodes2[HttpStatusCodes2[\"BadRequest\"] = 400] = \"BadRequest\";\n  HttpStatusCodes2[HttpStatusCodes2[\"Unauthorized\"] = 401] = \"Unauthorized\";\n  HttpStatusCodes2[HttpStatusCodes2[\"Forbidden\"] = 403] = \"Forbidden\";\n  HttpStatusCodes2[HttpStatusCodes2[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n  HttpStatusCodes2[HttpStatusCodes2[\"InternalServerError\"] = 500] = \"InternalServerError\";\n  return HttpStatusCodes2;\n})(HttpStatusCodes || {});\nfunction isSuccessCode(statusCode) {\n  return statusCode >= 200 /* Success */ && statusCode < 400 /* BadRequest */;\n}\nvar HttpStatusCodes_default = HttpStatusCodes;\n\n// src/common/lib/client/auth.ts\nvar MAX_TOKEN_LENGTH = Math.pow(2, 17);\nfunction random() {\n  return (\"000000\" + Math.floor(Math.random() * 1e16)).slice(-16);\n}\nfunction isRealtime(client) {\n  return !!client.connection;\n}\nfunction normaliseAuthcallbackError(err) {\n  if (!isErrorInfoOrPartialErrorInfo(err)) {\n    return new ErrorInfo(inspectError(err), err.code || 40170, err.statusCode || 401);\n  }\n  if (!err.code) {\n    if (err.statusCode === 403) {\n      err.code = 40300;\n    } else {\n      err.code = 40170;\n      err.statusCode = 401;\n    }\n  }\n  return err;\n}\nvar hmac = (text, key) => {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(text);\n  const keyBuffer = bufferUtils.utf8Encode(key);\n  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);\n  return bufferUtils.base64Encode(digest);\n};\nfunction c14n(capability) {\n  if (!capability)\n    return \"\";\n  if (typeof capability == \"string\")\n    capability = JSON.parse(capability);\n  const c14nCapability = /* @__PURE__ */ Object.create(null);\n  const keys = keysArray(capability, true);\n  if (!keys)\n    return \"\";\n  keys.sort();\n  for (let i = 0; i < keys.length; i++) {\n    c14nCapability[keys[i]] = capability[keys[i]].sort();\n  }\n  return JSON.stringify(c14nCapability);\n}\nfunction logAndValidateTokenAuthMethod(authOptions, logger) {\n  if (authOptions.authCallback) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authCallback\");\n  } else if (authOptions.authUrl) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authUrl\");\n  } else if (authOptions.key) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with client-side signing\");\n  } else if (authOptions.tokenDetails) {\n    logger_default.logAction(logger, logger_default.LOG_MINOR, \"Auth()\", \"using token auth with supplied token only\");\n  } else {\n    const msg = \"authOptions must include valid authentication parameters\";\n    logger_default.logAction(logger, logger_default.LOG_ERROR, \"Auth()\", msg);\n    throw new Error(msg);\n  }\n}\nfunction basicAuthForced(options) {\n  return \"useTokenAuth\" in options && !options.useTokenAuth;\n}\nfunction useTokenAuth(options) {\n  return options.useTokenAuth || !basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails);\n}\nfunction noWayToRenew(options) {\n  return !options.key && !options.authCallback && !options.authUrl;\n}\nvar trId = 0;\nfunction getTokenRequestId() {\n  return trId++;\n}\nvar Auth = class {\n  constructor(client, options) {\n    // This initialization is always overwritten and only used to prevent a TypeScript compiler error\n    this.authOptions = {};\n    this.client = client;\n    this.tokenParams = options.defaultTokenParams || {};\n    this.currentTokenRequestId = null;\n    this.waitingForTokenRequest = null;\n    if (useTokenAuth(options)) {\n      if (noWayToRenew(options)) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"Auth()\",\n          \"Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\"\n        );\n      }\n      this._saveTokenOptions(options.defaultTokenParams, options);\n      logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    } else {\n      if (!options.key) {\n        const msg = \"No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth()\", msg);\n        throw new ErrorInfo(msg, 40160, 401);\n      }\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth()\", \"anonymous, using basic auth\");\n      this._saveBasicOptions(options);\n    }\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  async authorize(tokenParams, authOptions) {\n    if (authOptions && authOptions.key && this.authOptions.key !== authOptions.key) {\n      throw new ErrorInfo(\"Unable to update auth options with incompatible key\", 40102, 401);\n    }\n    try {\n      let tokenDetails = await this._forceNewToken(tokenParams != null ? tokenParams : null, authOptions != null ? authOptions : null);\n      if (isRealtime(this.client)) {\n        return new Promise((resolve, reject) => {\n          this.client.connection.connectionManager.onAuthUpdated(\n            tokenDetails,\n            (err, tokenDetails2) => err ? reject(err) : resolve(tokenDetails2)\n          );\n        });\n      } else {\n        return tokenDetails;\n      }\n    } catch (err) {\n      if (this.client.connection && err.statusCode === HttpStatusCodes_default.Forbidden) {\n        this.client.connection.connectionManager.actOnErrorFromAuthorize(err);\n      }\n      throw err;\n    }\n  }\n  /* For internal use, eg by connectionManager - useful when want to call back\n   * as soon as we have the new token, rather than waiting for it to take\n   * effect on the connection as #authorize does */\n  async _forceNewToken(tokenParams, authOptions) {\n    this.tokenDetails = null;\n    this._saveTokenOptions(tokenParams, authOptions);\n    logAndValidateTokenAuthMethod(this.authOptions, this.logger);\n    try {\n      return this._ensureValidAuthCredentials(true);\n    } finally {\n      delete this.tokenParams.timestamp;\n      delete this.authOptions.queryTime;\n    }\n  }\n  async requestToken(tokenParams, authOptions) {\n    const resolvedAuthOptions = authOptions || this.authOptions;\n    const resolvedTokenParams = tokenParams || copy(this.tokenParams);\n    let tokenRequestCallback, client = this.client;\n    if (resolvedAuthOptions.authCallback) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authCallback\");\n      tokenRequestCallback = resolvedAuthOptions.authCallback;\n    } else if (resolvedAuthOptions.authUrl) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authUrl\");\n      tokenRequestCallback = (params, cb) => {\n        const authHeaders = mixin(\n          { accept: \"application/json, text/plain\" },\n          resolvedAuthOptions.authHeaders\n        );\n        const usePost = resolvedAuthOptions.authMethod && resolvedAuthOptions.authMethod.toLowerCase() === \"post\";\n        let providedQsParams;\n        const queryIdx = resolvedAuthOptions.authUrl.indexOf(\"?\");\n        if (queryIdx > -1) {\n          providedQsParams = parseQueryString(resolvedAuthOptions.authUrl.slice(queryIdx));\n          resolvedAuthOptions.authUrl = resolvedAuthOptions.authUrl.slice(0, queryIdx);\n          if (!usePost) {\n            resolvedAuthOptions.authParams = mixin(\n              providedQsParams,\n              resolvedAuthOptions.authParams\n            );\n          }\n        }\n        const authParams = mixin({}, resolvedAuthOptions.authParams || {}, params);\n        const authUrlRequestCallback = (result) => {\n          var _a2, _b;\n          let body = (_a2 = result.body) != null ? _a2 : null;\n          let contentType = null;\n          if (result.error) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MICRO,\n              \"Auth.requestToken().tokenRequestCallback\",\n              \"Received Error: \" + inspectError(result.error)\n            );\n          } else {\n            const contentTypeHeaderOrHeaders = (_b = result.headers[\"content-type\"]) != null ? _b : null;\n            if (Array.isArray(contentTypeHeaderOrHeaders)) {\n              contentType = contentTypeHeaderOrHeaders.join(\", \");\n            } else {\n              contentType = contentTypeHeaderOrHeaders;\n            }\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MICRO,\n              \"Auth.requestToken().tokenRequestCallback\",\n              \"Received; content-type: \" + contentType + \"; body: \" + inspectBody(body)\n            );\n          }\n          if (result.error) {\n            cb(result.error, null);\n            return;\n          }\n          if (result.unpacked) {\n            cb(null, body);\n            return;\n          }\n          if (Platform.BufferUtils.isBuffer(body))\n            body = body.toString();\n          if (!contentType) {\n            cb(new ErrorInfo(\"authUrl response is missing a content-type header\", 40170, 401), null);\n            return;\n          }\n          const json = contentType.indexOf(\"application/json\") > -1, text = contentType.indexOf(\"text/plain\") > -1 || contentType.indexOf(\"application/jwt\") > -1;\n          if (!json && !text) {\n            cb(\n              new ErrorInfo(\n                \"authUrl responded with unacceptable content-type \" + contentType + \", should be either text/plain, application/jwt or application/json\",\n                40170,\n                401\n              ),\n              null\n            );\n            return;\n          }\n          if (json) {\n            if (body.length > MAX_TOKEN_LENGTH) {\n              cb(new ErrorInfo(\"authUrl response exceeded max permitted length\", 40170, 401), null);\n              return;\n            }\n            try {\n              body = JSON.parse(body);\n            } catch (e) {\n              cb(\n                new ErrorInfo(\n                  \"Unexpected error processing authURL response; err = \" + e.message,\n                  40170,\n                  401\n                ),\n                null\n              );\n              return;\n            }\n          }\n          cb(null, body, contentType);\n        };\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"Auth.requestToken().tokenRequestCallback\",\n          \"Requesting token from \" + resolvedAuthOptions.authUrl + \"; Params: \" + JSON.stringify(authParams) + \"; method: \" + (usePost ? \"POST\" : \"GET\")\n        );\n        if (usePost) {\n          const headers = authHeaders || {};\n          headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n          const body = toQueryString(authParams).slice(1);\n          whenPromiseSettles(\n            this.client.http.doUri(\n              HttpMethods_default.Post,\n              resolvedAuthOptions.authUrl,\n              headers,\n              body,\n              providedQsParams\n            ),\n            (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result)\n          );\n        } else {\n          whenPromiseSettles(\n            this.client.http.doUri(HttpMethods_default.Get, resolvedAuthOptions.authUrl, authHeaders || {}, null, authParams),\n            (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result)\n          );\n        }\n      };\n    } else if (resolvedAuthOptions.key) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"Auth.requestToken()\",\n        \"using token auth with client-side signing\"\n      );\n      tokenRequestCallback = (params, cb) => {\n        whenPromiseSettles(\n          this.createTokenRequest(params, resolvedAuthOptions),\n          (err, result) => cb(err, result != null ? result : null)\n        );\n      };\n    } else {\n      const msg = \"Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)\";\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Auth()\",\n        \"library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\"\n      );\n      throw new ErrorInfo(msg, 40171, 403);\n    }\n    if (\"capability\" in resolvedTokenParams)\n      resolvedTokenParams.capability = c14n(\n        resolvedTokenParams.capability\n      );\n    const tokenRequest = (signedTokenParams, tokenCb) => {\n      const keyName = signedTokenParams.keyName, path = \"/keys/\" + keyName + \"/requestToken\", tokenUri = function(host) {\n        return client.baseUri(host) + path;\n      };\n      const requestHeaders = defaults_default.defaultPostHeaders(this.client.options);\n      if (resolvedAuthOptions.requestHeaders)\n        mixin(requestHeaders, resolvedAuthOptions.requestHeaders);\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Auth.requestToken().requestToken\",\n        \"Sending POST to \" + path + \"; Token params: \" + JSON.stringify(signedTokenParams)\n      );\n      whenPromiseSettles(\n        this.client.http.do(HttpMethods_default.Post, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null),\n        (err, result) => err ? tokenCb(err) : tokenCb(result.error, result.body, result.unpacked)\n      );\n    };\n    return new Promise((resolve, reject) => {\n      let tokenRequestCallbackTimeoutExpired = false, timeoutLength = this.client.options.timeouts.realtimeRequestTimeout, tokenRequestCallbackTimeout = setTimeout(() => {\n        tokenRequestCallbackTimeoutExpired = true;\n        const msg = \"Token request callback timed out after \" + timeoutLength / 1e3 + \" seconds\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n        reject(new ErrorInfo(msg, 40170, 401));\n      }, timeoutLength);\n      tokenRequestCallback(resolvedTokenParams, (err, tokenRequestOrDetails, contentType) => {\n        if (tokenRequestCallbackTimeoutExpired)\n          return;\n        clearTimeout(tokenRequestCallbackTimeout);\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"Auth.requestToken()\",\n            \"token request signing call returned error; err = \" + inspectError(err)\n          );\n          reject(normaliseAuthcallbackError(err));\n          return;\n        }\n        if (typeof tokenRequestOrDetails === \"string\") {\n          if (tokenRequestOrDetails.length === 0) {\n            reject(new ErrorInfo(\"Token string is empty\", 40170, 401));\n          } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\n            reject(\n              new ErrorInfo(\n                \"Token string exceeded max permitted length (was \" + tokenRequestOrDetails.length + \" bytes)\",\n                40170,\n                401\n              )\n            );\n          } else if (tokenRequestOrDetails === \"undefined\" || tokenRequestOrDetails === \"null\") {\n            reject(new ErrorInfo(\"Token string was literal null/undefined\", 40170, 401));\n          } else if (tokenRequestOrDetails[0] === \"{\" && !(contentType && contentType.indexOf(\"application/jwt\") > -1)) {\n            reject(\n              new ErrorInfo(\n                \"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\",\n                40170,\n                401\n              )\n            );\n          } else {\n            resolve({ token: tokenRequestOrDetails });\n          }\n          return;\n        }\n        if (typeof tokenRequestOrDetails !== \"object\" || tokenRequestOrDetails === null) {\n          const msg = \"Expected token request callback to call back with a token string or token request/details object, but got a \" + typeof tokenRequestOrDetails;\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        const objectSize = JSON.stringify(tokenRequestOrDetails).length;\n        if (objectSize > MAX_TOKEN_LENGTH && !resolvedAuthOptions.suppressMaxLengthCheck) {\n          reject(\n            new ErrorInfo(\n              \"Token request/details object exceeded max permitted stringified size (was \" + objectSize + \" bytes)\",\n              40170,\n              401\n            )\n          );\n          return;\n        }\n        if (\"issued\" in tokenRequestOrDetails) {\n          resolve(tokenRequestOrDetails);\n          return;\n        }\n        if (!(\"keyName\" in tokenRequestOrDetails)) {\n          const msg = \"Expected token request callback to call back with a token string, token request object, or token details object\";\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        tokenRequest(tokenRequestOrDetails, (err2, tokenResponse, unpacked) => {\n          if (err2) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"Auth.requestToken()\",\n              \"token request API call returned error; err = \" + inspectError(err2)\n            );\n            reject(normaliseAuthcallbackError(err2));\n            return;\n          }\n          if (!unpacked)\n            tokenResponse = JSON.parse(tokenResponse);\n          logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getToken()\", \"token received\");\n          resolve(tokenResponse);\n        });\n      });\n    });\n  }\n  /**\n   * Create and sign a token request based on the given options.\n   * NOTE this can only be used when the key value is available locally.\n   * Otherwise, signed token requests must be obtained from the key\n   * owner (either using the token request callback or url).\n   *\n   * @param authOptions\n   * an object containing the request options:\n   * - key:           the key to use. If not specified, a key passed in constructing\n   *                  the Rest interface will be used\n   *\n   * - queryTime      (optional) boolean indicating that the ably system should be\n   *                  queried for the current time when none is specified explicitly\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:       (optional) the requested life of the token in ms. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   */\n  async createTokenRequest(tokenParams, authOptions) {\n    authOptions = authOptions || this.authOptions;\n    tokenParams = tokenParams || copy(this.tokenParams);\n    const key = authOptions.key;\n    if (!key) {\n      throw new ErrorInfo(\"No key specified\", 40101, 403);\n    }\n    const keyParts = key.split(\":\"), keyName = keyParts[0], keySecret = keyParts[1];\n    if (!keySecret) {\n      throw new ErrorInfo(\"Invalid key specified\", 40101, 403);\n    }\n    if (tokenParams.clientId === \"\") {\n      throw new ErrorInfo(\"clientId can\\u2019t be an empty string\", 40012, 400);\n    }\n    if (\"capability\" in tokenParams) {\n      tokenParams.capability = c14n(tokenParams.capability);\n    }\n    const request = mixin({ keyName }, tokenParams), clientId = tokenParams.clientId || \"\", ttl = tokenParams.ttl || \"\", capability = tokenParams.capability || \"\";\n    if (!request.timestamp) {\n      request.timestamp = await this.getTimestamp(authOptions && authOptions.queryTime);\n    }\n    const nonce = request.nonce || (request.nonce = random()), timestamp = request.timestamp;\n    const signText = request.keyName + \"\\n\" + ttl + \"\\n\" + capability + \"\\n\" + clientId + \"\\n\" + timestamp + \"\\n\" + nonce + \"\\n\";\n    request.mac = request.mac || hmac(signText, keySecret);\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getTokenRequest()\", \"generated signed request\");\n    return request;\n  }\n  /**\n   * Get the auth query params to use for a websocket connection,\n   * based on the current auth parameters\n   */\n  async getAuthParams() {\n    if (this.method == \"basic\")\n      return { key: this.key };\n    else {\n      let tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n      }\n      return { access_token: tokenDetails.token };\n    }\n  }\n  /**\n   * Get the authorization header to use for a REST or comet request,\n   * based on the current auth parameters\n   */\n  async getAuthHeaders() {\n    if (this.method == \"basic\") {\n      return { authorization: \"Basic \" + this.basicKey };\n    } else {\n      const tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n      }\n      return { authorization: \"Bearer \" + toBase64(tokenDetails.token) };\n    }\n  }\n  /**\n   * Get the current time based on the local clock,\n   * or if the option queryTime is true, return the server time.\n   * The server time offset from the local time is stored so that\n   * only one request to the server to get the time is ever needed\n   */\n  async getTimestamp(queryTime) {\n    if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {\n      return this.client.time();\n    } else {\n      return this.getTimestampUsingOffset();\n    }\n  }\n  getTimestampUsingOffset() {\n    return Date.now() + (this.client.serverTimeOffset || 0);\n  }\n  isTimeOffsetSet() {\n    return this.client.serverTimeOffset !== null;\n  }\n  _saveBasicOptions(authOptions) {\n    this.method = \"basic\";\n    this.key = authOptions.key;\n    this.basicKey = toBase64(authOptions.key);\n    this.authOptions = authOptions || {};\n    if (\"clientId\" in authOptions) {\n      this._userSetClientId(authOptions.clientId);\n    }\n  }\n  _saveTokenOptions(tokenParams, authOptions) {\n    this.method = \"token\";\n    if (tokenParams) {\n      this.tokenParams = tokenParams;\n    }\n    if (authOptions) {\n      if (authOptions.token) {\n        authOptions.tokenDetails = typeof authOptions.token === \"string\" ? { token: authOptions.token } : authOptions.token;\n      }\n      if (authOptions.tokenDetails) {\n        this.tokenDetails = authOptions.tokenDetails;\n      }\n      if (\"clientId\" in authOptions) {\n        this._userSetClientId(authOptions.clientId);\n      }\n      this.authOptions = authOptions;\n    }\n  }\n  /* @param forceSupersede: force a new token request even if there's one in\n   * progress, making all pending callbacks wait for the new one */\n  async _ensureValidAuthCredentials(forceSupersede) {\n    const token = this.tokenDetails;\n    if (token) {\n      if (this._tokenClientIdMismatch(token.clientId)) {\n        throw new ErrorInfo(\n          \"Mismatch between clientId in token (\" + token.clientId + \") and current clientId (\" + this.clientId + \")\",\n          40102,\n          403\n        );\n      }\n      if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"Auth.getToken()\",\n          \"using cached token; expires = \" + token.expires\n        );\n        return token;\n      }\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Auth.getToken()\", \"deleting expired token\");\n      this.tokenDetails = null;\n    }\n    const promise = (this.waitingForTokenRequest || (this.waitingForTokenRequest = multicaster_default.create(this.logger))).createPromise();\n    if (this.currentTokenRequestId !== null && !forceSupersede) {\n      return promise;\n    }\n    const tokenRequestId = this.currentTokenRequestId = getTokenRequestId();\n    let tokenResponse, caughtError = null;\n    try {\n      tokenResponse = await this.requestToken(this.tokenParams, this.authOptions);\n    } catch (err) {\n      caughtError = err;\n    }\n    if (this.currentTokenRequestId > tokenRequestId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"Auth._ensureValidAuthCredentials()\",\n        \"Discarding token request response; overtaken by newer one\"\n      );\n      return promise;\n    }\n    this.currentTokenRequestId = null;\n    const multicaster = this.waitingForTokenRequest;\n    this.waitingForTokenRequest = null;\n    if (caughtError) {\n      multicaster == null ? void 0 : multicaster.rejectAll(caughtError);\n      return promise;\n    }\n    multicaster == null ? void 0 : multicaster.resolveAll(this.tokenDetails = tokenResponse);\n    return promise;\n  }\n  /* User-set: check types, '*' is disallowed, throw any errors */\n  _userSetClientId(clientId) {\n    if (!(typeof clientId === \"string\" || clientId === null)) {\n      throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n    } else if (clientId === \"*\") {\n      throw new ErrorInfo(\n        'Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)',\n        40012,\n        400\n      );\n    } else {\n      const err = this._uncheckedSetClientId(clientId);\n      if (err)\n        throw err;\n    }\n  }\n  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\n  _uncheckedSetClientId(clientId) {\n    if (this._tokenClientIdMismatch(clientId)) {\n      const msg = \"Unexpected clientId mismatch: client has \" + this.clientId + \", requested \" + clientId;\n      const err = new ErrorInfo(msg, 40102, 401);\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Auth._uncheckedSetClientId()\", msg);\n      return err;\n    } else {\n      this.clientId = this.tokenParams.clientId = clientId;\n      return null;\n    }\n  }\n  _tokenClientIdMismatch(tokenClientId) {\n    return !!(this.clientId && this.clientId !== \"*\" && tokenClientId && tokenClientId !== \"*\" && this.clientId !== tokenClientId);\n  }\n  static isTokenErr(error) {\n    return error.code && error.code >= 40140 && error.code < 40150;\n  }\n  revokeTokens(specifiers, options) {\n    return this.client.rest.revokeTokens(specifiers, options);\n  }\n};\nvar auth_default = Auth;\n\n// src/common/types/http.ts\nfunction paramString(params) {\n  const paramPairs = [];\n  if (params) {\n    for (const needle in params) {\n      paramPairs.push(needle + \"=\" + params[needle]);\n    }\n  }\n  return paramPairs.join(\"&\");\n}\nfunction appendingParams(uri, params) {\n  return uri + (params ? \"?\" : \"\") + paramString(params);\n}\nfunction logResult(result, method, uri, params, logger) {\n  if (result.error) {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Received Error; \" + appendingParams(uri, params) + \"; Error: \" + inspectError(result.error)\n    );\n  } else {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Received; \" + appendingParams(uri, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body\" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + result.body)\n    );\n  }\n}\nfunction logRequest(method, uri, body, params, logger) {\n  if (logger.shouldLog(logger_default.LOG_MICRO)) {\n    logger_default.logActionNoStrip(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Http.\" + method + \"()\",\n      \"Sending; \" + appendingParams(uri, params) + \"; Body\" + (Platform.BufferUtils.isBuffer(body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(body) : \": \" + body)\n    );\n  }\n}\nvar Http = class {\n  constructor(client) {\n    this.client = client;\n    this.platformHttp = new Platform.Http(client);\n    this.checkConnectivity = this.platformHttp.checkConnectivity ? () => this.platformHttp.checkConnectivity() : void 0;\n  }\n  get logger() {\n    var _a2, _b;\n    return (_b = (_a2 = this.client) == null ? void 0 : _a2.logger) != null ? _b : logger_default.defaultLogger;\n  }\n  get supportsAuthHeaders() {\n    return this.platformHttp.supportsAuthHeaders;\n  }\n  get supportsLinkHeaders() {\n    return this.platformHttp.supportsLinkHeaders;\n  }\n  _getHosts(client) {\n    const connection = client.connection, connectionHost = connection && connection.connectionManager.host;\n    if (connectionHost) {\n      return [connectionHost].concat(defaults_default.getFallbackHosts(client.options));\n    }\n    return defaults_default.getHosts(client.options);\n  }\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async do(method, path, headers, body, params) {\n    try {\n      const client = this.client;\n      if (!client) {\n        return { error: new ErrorInfo(\"http.do called without client\", 5e4, 500) };\n      }\n      const uriFromHost = typeof path === \"function\" ? path : function(host) {\n        return client.baseUri(host) + path;\n      };\n      const currentFallback = client._currentFallback;\n      if (currentFallback) {\n        if (currentFallback.validUntil > Date.now()) {\n          const result = await this.doUri(method, uriFromHost(currentFallback.host), headers, body, params);\n          if (result.error && this.platformHttp.shouldFallback(result.error)) {\n            client._currentFallback = null;\n            return this.do(method, path, headers, body, params);\n          }\n          return result;\n        } else {\n          client._currentFallback = null;\n        }\n      }\n      const hosts = this._getHosts(client);\n      if (hosts.length === 1) {\n        return this.doUri(method, uriFromHost(hosts[0]), headers, body, params);\n      }\n      let tryAHostStartedAt = null;\n      const tryAHost = async (candidateHosts, persistOnSuccess) => {\n        const host = candidateHosts.shift();\n        tryAHostStartedAt = tryAHostStartedAt != null ? tryAHostStartedAt : /* @__PURE__ */ new Date();\n        const result = await this.doUri(method, uriFromHost(host), headers, body, params);\n        if (result.error && this.platformHttp.shouldFallback(result.error) && candidateHosts.length) {\n          const elapsedTime = Date.now() - tryAHostStartedAt.getTime();\n          if (elapsedTime > client.options.timeouts.httpMaxRetryDuration) {\n            return {\n              error: new ErrorInfo(\n                `Timeout for trying fallback hosts retries. Total elapsed time exceeded the ${client.options.timeouts.httpMaxRetryDuration}ms limit`,\n                50003,\n                500\n              )\n            };\n          }\n          return tryAHost(candidateHosts, true);\n        }\n        if (persistOnSuccess) {\n          client._currentFallback = {\n            host,\n            validUntil: Date.now() + client.options.timeouts.fallbackRetryTimeout\n          };\n        }\n        return result;\n      };\n      return tryAHost(hosts);\n    } catch (err) {\n      return { error: new ErrorInfo(`Unexpected error in Http.do: ${inspectError(err)}`, 500, 5e4) };\n    }\n  }\n  /**\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n   */\n  async doUri(method, uri, headers, body, params) {\n    try {\n      logRequest(method, uri, body, params, this.logger);\n      const result = await this.platformHttp.doUri(method, uri, headers, body, params);\n      if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n        logResult(result, method, uri, params, this.logger);\n      }\n      return result;\n    } catch (err) {\n      return { error: new ErrorInfo(`Unexpected error in Http.doUri: ${inspectError(err)}`, 500, 5e4) };\n    }\n  }\n};\n\n// src/common/lib/client/baseclient.ts\nvar BaseClient = class {\n  constructor(options) {\n    /**\n     * These exports are for use by UMD plugins; reason being so that constructors and static methods can be accessed by these plugins without needing to import the classes directly and result in the class existing in both the plugin and the core library.\n     */\n    this.Platform = Platform;\n    this.ErrorInfo = ErrorInfo;\n    this.Logger = logger_default;\n    this.Defaults = defaults_default;\n    this.Utils = utils_exports;\n    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    this._additionalHTTPRequestImplementations = (_a2 = options.plugins) != null ? _a2 : null;\n    this.logger = new logger_default();\n    this.logger.setLog(options.logLevel, options.logHandler);\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"BaseClient()\",\n      \"initialized with clientOptions \" + Platform.Config.inspect(options)\n    );\n    this._MsgPack = (_c = (_b = options.plugins) == null ? void 0 : _b.MsgPack) != null ? _c : null;\n    const normalOptions = this.options = defaults_default.normaliseOptions(options, this._MsgPack, this.logger);\n    if (normalOptions.key) {\n      const keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\n      if (!keyMatch) {\n        const msg = \"invalid key parameter\";\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"BaseClient()\", msg);\n        throw new ErrorInfo(msg, 40400, 404);\n      }\n      normalOptions.keyName = keyMatch[1];\n      normalOptions.keySecret = keyMatch[2];\n    }\n    if (\"clientId\" in normalOptions) {\n      if (!(typeof normalOptions.clientId === \"string\" || normalOptions.clientId === null))\n        throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n      else if (normalOptions.clientId === \"*\")\n        throw new ErrorInfo(\n          'Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})',\n          40012,\n          400\n        );\n    }\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"BaseClient()\", \"started; version = \" + defaults_default.version);\n    this._currentFallback = null;\n    this.serverTimeOffset = null;\n    this.http = new Http(this);\n    this.auth = new auth_default(this, normalOptions);\n    this._rest = ((_d = options.plugins) == null ? void 0 : _d.Rest) ? new options.plugins.Rest(this) : null;\n    this._Crypto = (_f = (_e = options.plugins) == null ? void 0 : _e.Crypto) != null ? _f : null;\n    this.__FilteredSubscriptions = (_h = (_g = options.plugins) == null ? void 0 : _g.MessageInteractions) != null ? _h : null;\n    this._Annotations = (_j = (_i = options.plugins) == null ? void 0 : _i.Annotations) != null ? _j : null;\n  }\n  get rest() {\n    if (!this._rest) {\n      throwMissingPluginError(\"Rest\");\n    }\n    return this._rest;\n  }\n  get _FilteredSubscriptions() {\n    if (!this.__FilteredSubscriptions) {\n      throwMissingPluginError(\"MessageInteractions\");\n    }\n    return this.__FilteredSubscriptions;\n  }\n  get channels() {\n    return this.rest.channels;\n  }\n  get push() {\n    return this.rest.push;\n  }\n  get device() {\n    var _a2;\n    if (!((_a2 = this.options.plugins) == null ? void 0 : _a2.Push) || !this.push.LocalDevice) {\n      throwMissingPluginError(\"Push\");\n    }\n    if (!this._device) {\n      this._device = this.push.LocalDevice.load(this);\n    }\n    return this._device;\n  }\n  baseUri(host) {\n    return defaults_default.getHttpScheme(this.options) + host + \":\" + defaults_default.getPort(this.options, false);\n  }\n  async stats(params) {\n    return this.rest.stats(params);\n  }\n  async time(params) {\n    return this.rest.time(params);\n  }\n  async request(method, path, version2, params, body, customHeaders) {\n    return this.rest.request(method, path, version2, params, body, customHeaders);\n  }\n  batchPublish(specOrSpecs) {\n    return this.rest.batchPublish(specOrSpecs);\n  }\n  batchPresence(channels) {\n    return this.rest.batchPresence(channels);\n  }\n  setLog(logOptions) {\n    this.logger.setLog(logOptions.level, logOptions.handler);\n  }\n};\nBaseClient.Platform = Platform;\nvar baseclient_default = BaseClient;\n\n// src/common/lib/types/devicedetails.ts\nvar DeviceDetails = class _DeviceDetails {\n  toJSON() {\n    var _a2, _b, _c;\n    return {\n      id: this.id,\n      deviceSecret: this.deviceSecret,\n      platform: this.platform,\n      formFactor: this.formFactor,\n      clientId: this.clientId,\n      metadata: this.metadata,\n      deviceIdentityToken: this.deviceIdentityToken,\n      push: {\n        recipient: (_a2 = this.push) == null ? void 0 : _a2.recipient,\n        state: (_b = this.push) == null ? void 0 : _b.state,\n        error: (_c = this.push) == null ? void 0 : _c.error\n      }\n    };\n  }\n  toString() {\n    var _a2, _b, _c, _d;\n    let result = \"[DeviceDetails\";\n    if (this.id)\n      result += \"; id=\" + this.id;\n    if (this.platform)\n      result += \"; platform=\" + this.platform;\n    if (this.formFactor)\n      result += \"; formFactor=\" + this.formFactor;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    if (this.metadata)\n      result += \"; metadata=\" + this.metadata;\n    if (this.deviceIdentityToken)\n      result += \"; deviceIdentityToken=\" + JSON.stringify(this.deviceIdentityToken);\n    if ((_a2 = this.push) == null ? void 0 : _a2.recipient)\n      result += \"; push.recipient=\" + JSON.stringify(this.push.recipient);\n    if ((_b = this.push) == null ? void 0 : _b.state)\n      result += \"; push.state=\" + this.push.state;\n    if ((_c = this.push) == null ? void 0 : _c.error)\n      result += \"; push.error=\" + JSON.stringify(this.push.error);\n    if ((_d = this.push) == null ? void 0 : _d.metadata)\n      result += \"; push.metadata=\" + this.push.metadata;\n    result += \"]\";\n    return result;\n  }\n  static toRequestBody(body, MsgPack, format) {\n    return encodeBody(body, MsgPack, format);\n  }\n  static fromResponseBody(body, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    if (Array.isArray(body)) {\n      return _DeviceDetails.fromValuesArray(body);\n    } else {\n      return _DeviceDetails.fromValues(body);\n    }\n  }\n  static fromValues(values) {\n    values.error = values.error && ErrorInfo.fromValues(values.error);\n    return Object.assign(new _DeviceDetails(), values);\n  }\n  static fromLocalDevice(device) {\n    return Object.assign(new _DeviceDetails(), device);\n  }\n  static fromValuesArray(values) {\n    const count = values.length, result = new Array(count);\n    for (let i = 0; i < count; i++)\n      result[i] = _DeviceDetails.fromValues(values[i]);\n    return result;\n  }\n};\nvar devicedetails_default = DeviceDetails;\n\n// src/common/lib/client/resource.ts\nasync function withAuthDetails(client, headers, params, opCallback) {\n  if (client.http.supportsAuthHeaders) {\n    const authHeaders = await client.auth.getAuthHeaders();\n    return opCallback(mixin(authHeaders, headers), params);\n  } else {\n    const authParams = await client.auth.getAuthParams();\n    return opCallback(headers, mixin(authParams, params));\n  }\n}\nfunction unenvelope(result, MsgPack, format) {\n  if (result.err && !result.body) {\n    return { err: result.err };\n  }\n  if (result.statusCode === HttpStatusCodes_default.NoContent) {\n    return __spreadProps(__spreadValues({}, result), { body: [], unpacked: true });\n  }\n  let body = result.body;\n  if (!result.unpacked) {\n    try {\n      body = decodeBody(body, MsgPack, format);\n    } catch (e) {\n      if (isErrorInfoOrPartialErrorInfo(e)) {\n        return { err: e };\n      } else {\n        return { err: new PartialErrorInfo(inspectError(e), null) };\n      }\n    }\n  }\n  if (!body) {\n    return { err: new PartialErrorInfo(\"unenvelope(): Response body is missing\", null) };\n  }\n  const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body;\n  if (wrappedStatusCode === void 0) {\n    return __spreadProps(__spreadValues({}, result), { body, unpacked: true });\n  }\n  if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\n    let wrappedErr = response && response.error || result.err;\n    if (!wrappedErr) {\n      wrappedErr = new Error(\"Error in unenveloping \" + body);\n      wrappedErr.statusCode = wrappedStatusCode;\n    }\n    return { err: wrappedErr, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n  }\n  return { err: result.err, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\n}\nfunction logResult2(result, method, path, params, logger) {\n  if (result.err) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Resource.\" + method + \"()\",\n      \"Received Error; \" + appendingParams(path, params) + \"; Error: \" + inspectError(result.err)\n    );\n  } else {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_MICRO,\n      \"Resource.\" + method + \"()\",\n      \"Received; \" + appendingParams(path, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body: \" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + Platform.Config.inspect(result.body))\n    );\n  }\n}\nvar Resource = class _Resource {\n  static async get(client, path, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Get, client, path, null, headers, params, envelope, throwError != null ? throwError : false);\n  }\n  static async delete(client, path, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Delete, client, path, null, headers, params, envelope, throwError);\n  }\n  static async post(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Post, client, path, body, headers, params, envelope, throwError);\n  }\n  static async patch(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Patch, client, path, body, headers, params, envelope, throwError);\n  }\n  static async put(client, path, body, headers, params, envelope, throwError) {\n    return _Resource.do(HttpMethods_default.Put, client, path, body, headers, params, envelope, throwError);\n  }\n  static async do(method, client, path, body, headers, params, envelope, throwError) {\n    if (envelope) {\n      (params = params || {})[\"envelope\"] = envelope;\n    }\n    const logger = client.logger;\n    async function doRequest(headers2, params2) {\n      var _a2;\n      if (logger.shouldLog(logger_default.LOG_MICRO)) {\n        let decodedBody = body;\n        if (((_a2 = headers2[\"content-type\"]) == null ? void 0 : _a2.indexOf(\"msgpack\")) > 0) {\n          try {\n            if (!client._MsgPack) {\n              throwMissingPluginError(\"MsgPack\");\n            }\n            decodedBody = client._MsgPack.decode(body);\n          } catch (decodeErr) {\n            logger_default.logAction(\n              logger,\n              logger_default.LOG_MICRO,\n              \"Resource.\" + method + \"()\",\n              \"Sending MsgPack Decoding Error: \" + inspectError(decodeErr)\n            );\n          }\n        }\n        logger_default.logAction(\n          logger,\n          logger_default.LOG_MICRO,\n          \"Resource.\" + method + \"()\",\n          \"Sending; \" + appendingParams(path, params2) + \"; Body: \" + decodedBody\n        );\n      }\n      const httpResult = await client.http.do(method, path, headers2, body, params2);\n      if (httpResult.error && auth_default.isTokenErr(httpResult.error)) {\n        await client.auth.authorize(null, null);\n        return withAuthDetails(client, headers2, params2, doRequest);\n      }\n      return {\n        err: httpResult.error,\n        body: httpResult.body,\n        headers: httpResult.headers,\n        unpacked: httpResult.unpacked,\n        statusCode: httpResult.statusCode\n      };\n    }\n    let result = await withAuthDetails(client, headers, params, doRequest);\n    if (envelope) {\n      result = unenvelope(result, client._MsgPack, envelope);\n    }\n    if (logger.shouldLog(logger_default.LOG_MICRO)) {\n      logResult2(result, method, path, params, logger);\n    }\n    if (throwError) {\n      if (result.err) {\n        throw result.err;\n      } else {\n        const response = __spreadValues({}, result);\n        delete response.err;\n        return response;\n      }\n    }\n    return result;\n  }\n};\nvar resource_default = Resource;\n\n// src/common/lib/client/paginatedresource.ts\nfunction getRelParams(linkUrl) {\n  const urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\n  return urlMatch && urlMatch[2] && parseQueryString(urlMatch[2]);\n}\nfunction parseRelLinks(linkHeader) {\n  if (typeof linkHeader == \"string\")\n    linkHeader = linkHeader.split(\",\");\n  const relParams = {};\n  for (let i = 0; i < linkHeader.length; i++) {\n    const linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\n    if (linkMatch) {\n      const params = getRelParams(linkMatch[1]);\n      if (params)\n        relParams[linkMatch[2]] = params;\n    }\n  }\n  return relParams;\n}\nfunction returnErrOnly(err, body, useHPR) {\n  return !(useHPR && (body || typeof err.code === \"number\"));\n}\nvar PaginatedResource = class {\n  constructor(client, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {\n    this.client = client;\n    this.path = path;\n    this.headers = headers;\n    this.envelope = envelope != null ? envelope : null;\n    this.bodyHandler = bodyHandler;\n    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  async get(params) {\n    const result = await resource_default.get(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async delete(params) {\n    const result = await resource_default.delete(this.client, this.path, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async post(params, body) {\n    const result = await resource_default.post(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async put(params, body) {\n    const result = await resource_default.put(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async patch(params, body) {\n    const result = await resource_default.patch(this.client, this.path, body, this.headers, params, this.envelope, false);\n    return this.handlePage(result);\n  }\n  async handlePage(result) {\n    if (result.err && returnErrOnly(result.err, result.body, this.useHttpPaginatedResponse)) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"PaginatedResource.handlePage()\",\n        \"Unexpected error getting resource: err = \" + inspectError(result.err)\n      );\n      throw result.err;\n    }\n    let items, linkHeader, relParams;\n    try {\n      items = result.statusCode == HttpStatusCodes_default.NoContent ? [] : await this.bodyHandler(result.body, result.headers || {}, result.unpacked);\n    } catch (e) {\n      throw result.err || e;\n    }\n    if (result.headers && (linkHeader = result.headers[\"Link\"] || result.headers[\"link\"])) {\n      relParams = parseRelLinks(linkHeader);\n    }\n    if (this.useHttpPaginatedResponse) {\n      return new HttpPaginatedResponse(\n        this,\n        items,\n        result.headers || {},\n        result.statusCode,\n        relParams,\n        result.err\n      );\n    } else {\n      return new PaginatedResult(this, items, relParams);\n    }\n  }\n};\nvar PaginatedResult = class {\n  constructor(resource, items, relParams) {\n    this.resource = resource;\n    this.items = items;\n    const self2 = this;\n    if (relParams) {\n      if (\"first\" in relParams) {\n        this.first = async function() {\n          return self2.get(relParams.first);\n        };\n      }\n      if (\"current\" in relParams) {\n        this.current = async function() {\n          return self2.get(relParams.current);\n        };\n      }\n      this.next = async function() {\n        if (\"next\" in relParams) {\n          return self2.get(relParams.next);\n        } else {\n          return null;\n        }\n      };\n      this.hasNext = function() {\n        return \"next\" in relParams;\n      };\n      this.isLast = () => {\n        var _a2;\n        return !((_a2 = this.hasNext) == null ? void 0 : _a2.call(this));\n      };\n    }\n  }\n  /* We assume that only the initial request can be a POST, and that accessing\n   * the rest of a multipage set of results can always be done with GET */\n  async get(params) {\n    const res = this.resource;\n    const result = await resource_default.get(res.client, res.path, res.headers, params, res.envelope, false);\n    return res.handlePage(result);\n  }\n};\nvar HttpPaginatedResponse = class extends PaginatedResult {\n  constructor(resource, items, headers, statusCode, relParams, err) {\n    super(resource, items, relParams);\n    this.statusCode = statusCode;\n    this.success = statusCode < 300 && statusCode >= 200;\n    this.headers = headers;\n    this.errorCode = err && err.code;\n    this.errorMessage = err && err.message;\n  }\n  toJSON() {\n    return {\n      items: this.items,\n      statusCode: this.statusCode,\n      success: this.success,\n      headers: this.headers,\n      errorCode: this.errorCode,\n      errorMessage: this.errorMessage\n    };\n  }\n};\nvar paginatedresource_default = PaginatedResource;\n\n// src/common/lib/types/pushchannelsubscription.ts\nvar _PushChannelSubscription = class _PushChannelSubscription {\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON() {\n    return {\n      channel: this.channel,\n      deviceId: this.deviceId,\n      clientId: this.clientId\n    };\n  }\n  toString() {\n    let result = \"[PushChannelSubscription\";\n    if (this.channel)\n      result += \"; channel=\" + this.channel;\n    if (this.deviceId)\n      result += \"; deviceId=\" + this.deviceId;\n    if (this.clientId)\n      result += \"; clientId=\" + this.clientId;\n    result += \"]\";\n    return result;\n  }\n  static fromResponseBody(body, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    if (Array.isArray(body)) {\n      return _PushChannelSubscription.fromValuesArray(body);\n    } else {\n      return _PushChannelSubscription.fromValues(body);\n    }\n  }\n  static fromValues(values) {\n    return Object.assign(new _PushChannelSubscription(), values);\n  }\n  static fromValuesArray(values) {\n    const count = values.length, result = new Array(count);\n    for (let i = 0; i < count; i++)\n      result[i] = _PushChannelSubscription.fromValues(values[i]);\n    return result;\n  }\n};\n_PushChannelSubscription.toRequestBody = encodeBody;\nvar PushChannelSubscription = _PushChannelSubscription;\nvar pushchannelsubscription_default = PushChannelSubscription;\n\n// src/common/lib/client/push.ts\nvar Push = class {\n  constructor(client) {\n    var _a2;\n    this.client = client;\n    this.admin = new Admin(client);\n    if (Platform.Config.push && ((_a2 = client.options.plugins) == null ? void 0 : _a2.Push)) {\n      this.stateMachine = new client.options.plugins.Push.ActivationStateMachine(client);\n      this.LocalDevice = client.options.plugins.Push.localDeviceFactory(devicedetails_default);\n    }\n  }\n  async activate(registerCallback, updateFailedCallback) {\n    await new Promise((resolve, reject) => {\n      var _a2;\n      if (!((_a2 = this.client.options.plugins) == null ? void 0 : _a2.Push)) {\n        reject(createMissingPluginError(\"Push\"));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo(\"This platform is not supported as a target of push notifications\", 4e4, 400));\n        return;\n      }\n      if (this.stateMachine.activatedCallback) {\n        reject(new ErrorInfo(\"Activation already in progress\", 4e4, 400));\n        return;\n      }\n      this.stateMachine.activatedCallback = (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.updateFailedCallback = updateFailedCallback;\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledActivate(this.stateMachine, registerCallback)\n      );\n    });\n  }\n  async deactivate(deregisterCallback) {\n    await new Promise((resolve, reject) => {\n      var _a2;\n      if (!((_a2 = this.client.options.plugins) == null ? void 0 : _a2.Push)) {\n        reject(createMissingPluginError(\"Push\"));\n        return;\n      }\n      if (!this.stateMachine) {\n        reject(new ErrorInfo(\"This platform is not supported as a target of push notifications\", 4e4, 400));\n        return;\n      }\n      if (this.stateMachine.deactivatedCallback) {\n        reject(new ErrorInfo(\"Deactivation already in progress\", 4e4, 400));\n        return;\n      }\n      this.stateMachine.deactivatedCallback = (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve();\n      };\n      this.stateMachine.handleEvent(\n        new this.client.options.plugins.Push.CalledDeactivate(this.stateMachine, deregisterCallback)\n      );\n    });\n  }\n};\nvar Admin = class {\n  constructor(client) {\n    this.client = client;\n    this.deviceRegistrations = new DeviceRegistrations(client);\n    this.channelSubscriptions = new ChannelSubscriptions(client);\n  }\n  async publish(recipient, payload) {\n    const client = this.client;\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};\n    const body = mixin({ recipient }, payload);\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    await resource_default.post(client, \"/push/publish\", requestBody, headers, params, null, true);\n  }\n};\nvar DeviceRegistrations = class {\n  constructor(client) {\n    this.client = client;\n  }\n  async save(device) {\n    const client = this.client;\n    const body = devicedetails_default.fromValues(device);\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    const response = await resource_default.put(\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(device.id),\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    return devicedetails_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async get(deviceIdOrDetails) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format }), deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n    if (typeof deviceId !== \"string\" || !deviceId.length) {\n      throw new ErrorInfo(\n        \"First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails\",\n        4e4,\n        400\n      );\n    }\n    mixin(headers, client.options.headers);\n    const response = await resource_default.get(\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId),\n      headers,\n      {},\n      null,\n      true\n    );\n    return devicedetails_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async list(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, \"/push/deviceRegistrations\", headers, envelope, async function(body, headers2, unpacked) {\n      return devicedetails_default.fromResponseBody(\n        body,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  async remove(deviceIdOrDetails) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format }), params = {}, deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n    if (typeof deviceId !== \"string\" || !deviceId.length) {\n      throw new ErrorInfo(\n        \"First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails\",\n        4e4,\n        400\n      );\n    }\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](\n      client,\n      \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId),\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async removeWhere(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](client, \"/push/deviceRegistrations\", headers, params, null, true);\n  }\n};\nvar ChannelSubscriptions = class _ChannelSubscriptions {\n  constructor(client) {\n    /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\n    this.remove = _ChannelSubscriptions.prototype.removeWhere;\n    this.client = client;\n  }\n  async save(subscription) {\n    const client = this.client;\n    const body = pushchannelsubscription_default.fromValues(subscription);\n    const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    const requestBody = encodeBody(body, client._MsgPack, format);\n    const response = await resource_default.post(\n      client,\n      \"/push/channelSubscriptions\",\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n    return pushchannelsubscription_default.fromResponseBody(\n      response.body,\n      client._MsgPack,\n      response.unpacked ? void 0 : format\n    );\n  }\n  async list(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, \"/push/channelSubscriptions\", headers, envelope, async function(body, headers2, unpacked) {\n      return pushchannelsubscription_default.fromResponseBody(\n        body,\n        client._MsgPack,\n        unpacked ? void 0 : format\n      );\n    }).get(params);\n  }\n  async removeWhere(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    await resource_default[\"delete\"](client, \"/push/channelSubscriptions\", headers, params, null, true);\n  }\n  async listChannels(params) {\n    const client = this.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    if (client.options.pushFullWait)\n      mixin(params, { fullWait: \"true\" });\n    return new paginatedresource_default(client, \"/push/channels\", headers, envelope, async function(body, headers2, unpacked) {\n      const parsedBody = !unpacked && format ? decodeBody(body, client._MsgPack, format) : body;\n      for (let i = 0; i < parsedBody.length; i++) {\n        parsedBody[i] = String(parsedBody[i]);\n      }\n      return parsedBody;\n    }).get(params);\n  }\n};\nvar push_default = Push;\n\n// src/common/lib/types/protocolmessagecommon.ts\nvar actions = {\n  HEARTBEAT: 0,\n  ACK: 1,\n  NACK: 2,\n  CONNECT: 3,\n  CONNECTED: 4,\n  DISCONNECT: 5,\n  DISCONNECTED: 6,\n  CLOSE: 7,\n  CLOSED: 8,\n  ERROR: 9,\n  ATTACH: 10,\n  ATTACHED: 11,\n  DETACH: 12,\n  DETACHED: 13,\n  PRESENCE: 14,\n  MESSAGE: 15,\n  SYNC: 16,\n  AUTH: 17,\n  ACTIVATE: 18,\n  STATE: 19,\n  STATE_SYNC: 20,\n  ANNOTATION: 21\n};\nvar ActionName = [];\nObject.keys(actions).forEach(function(name) {\n  ActionName[actions[name]] = name;\n});\nvar flags = {\n  /* Channel attach state flags */\n  HAS_PRESENCE: 1 << 0,\n  HAS_BACKLOG: 1 << 1,\n  RESUMED: 1 << 2,\n  TRANSIENT: 1 << 4,\n  ATTACH_RESUME: 1 << 5,\n  /* Channel mode flags */\n  PRESENCE: 1 << 16,\n  PUBLISH: 1 << 17,\n  SUBSCRIBE: 1 << 18,\n  PRESENCE_SUBSCRIBE: 1 << 19,\n  ANNOTATION_PUBLISH: 1 << 21,\n  ANNOTATION_SUBSCRIBE: 1 << 22\n};\nvar flagNames = Object.keys(flags);\nflags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE | flags.ANNOTATION_PUBLISH | flags.ANNOTATION_SUBSCRIBE;\nvar channelModes = [\n  \"PRESENCE\",\n  \"PUBLISH\",\n  \"SUBSCRIBE\",\n  \"PRESENCE_SUBSCRIBE\",\n  \"ANNOTATION_PUBLISH\",\n  \"ANNOTATION_SUBSCRIBE\"\n];\n\n// src/common/lib/types/basemessage.ts\nfunction normaliseContext(context) {\n  if (!context || !context.channelOptions) {\n    return {\n      channelOptions: context,\n      plugins: {},\n      baseEncodedPreviousPayload: void 0\n    };\n  }\n  return context;\n}\nfunction normalizeCipherOptions(Crypto2, logger, options) {\n  if (options && options.cipher) {\n    if (!Crypto2)\n      throwMissingPluginError(\"Crypto\");\n    const cipher = Crypto2.getCipher(options.cipher, logger);\n    return {\n      cipher: cipher.cipherParams,\n      channelCipher: cipher.cipher\n    };\n  }\n  return options != null ? options : {};\n}\nasync function encrypt(msg, options) {\n  let data = msg.data, encoding = msg.encoding, cipher = options.channelCipher;\n  encoding = encoding ? encoding + \"/\" : \"\";\n  if (!Platform.BufferUtils.isBuffer(data)) {\n    data = Platform.BufferUtils.utf8Encode(String(data));\n    encoding = encoding + \"utf-8/\";\n  }\n  const ciphertext = await cipher.encrypt(data);\n  msg.data = ciphertext;\n  msg.encoding = encoding + \"cipher+\" + cipher.algorithm;\n  return msg;\n}\nasync function encode(msg, options) {\n  const data = msg.data;\n  const nativeDataType = typeof data == \"string\" || Platform.BufferUtils.isBuffer(data) || data === null || data === void 0;\n  if (!nativeDataType) {\n    if (isObject(data) || Array.isArray(data)) {\n      msg.data = JSON.stringify(data);\n      msg.encoding = msg.encoding ? msg.encoding + \"/json\" : \"json\";\n    } else {\n      throw new ErrorInfo(\"Data type is unsupported\", 40013, 400);\n    }\n  }\n  if (options != null && options.cipher) {\n    return encrypt(msg, options);\n  } else {\n    return msg;\n  }\n}\nasync function decode(message, inputContext) {\n  const context = normaliseContext(inputContext);\n  let lastPayload = message.data;\n  const encoding = message.encoding;\n  if (encoding) {\n    const xforms = encoding.split(\"/\");\n    let lastProcessedEncodingIndex, encodingsToProcess = xforms.length, data = message.data;\n    let xform = \"\";\n    try {\n      while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\n        const match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\n        if (!match)\n          break;\n        xform = match[1];\n        switch (xform) {\n          case \"base64\":\n            data = Platform.BufferUtils.base64Decode(String(data));\n            if (lastProcessedEncodingIndex == xforms.length) {\n              lastPayload = data;\n            }\n            continue;\n          case \"utf-8\":\n            data = Platform.BufferUtils.utf8Decode(data);\n            continue;\n          case \"json\":\n            data = JSON.parse(data);\n            continue;\n          case \"cipher\":\n            if (context.channelOptions != null && context.channelOptions.cipher && context.channelOptions.channelCipher) {\n              const xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;\n              if (xformAlgorithm != cipher.algorithm) {\n                throw new Error(\"Unable to decrypt message with given cipher; incompatible cipher params\");\n              }\n              data = await cipher.decrypt(data);\n              continue;\n            } else {\n              throw new Error(\"Unable to decrypt message; not an encrypted channel\");\n            }\n          case \"vcdiff\":\n            if (!context.plugins || !context.plugins.vcdiff) {\n              throw new ErrorInfo(\"Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)\", 40019, 400);\n            }\n            if (typeof Uint8Array === \"undefined\") {\n              throw new ErrorInfo(\n                \"Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)\",\n                40020,\n                400\n              );\n            }\n            try {\n              let deltaBase = context.baseEncodedPreviousPayload;\n              if (typeof deltaBase === \"string\") {\n                deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);\n              }\n              const deltaBaseBuffer = Platform.BufferUtils.toBuffer(deltaBase);\n              data = Platform.BufferUtils.toBuffer(data);\n              data = Platform.BufferUtils.arrayBufferViewToBuffer(context.plugins.vcdiff.decode(data, deltaBaseBuffer));\n              lastPayload = data;\n            } catch (e) {\n              throw new ErrorInfo(\"Vcdiff delta decode failed with \" + e, 40018, 400);\n            }\n            continue;\n          default:\n            throw new Error(\"Unknown encoding\");\n        }\n      }\n    } catch (e) {\n      const err = e;\n      throw new ErrorInfo(\n        \"Error processing the \" + xform + \" encoding, decoder returned \\u2018\" + err.message + \"\\u2019\",\n        err.code || 40013,\n        400\n      );\n    } finally {\n      message.encoding = lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join(\"/\");\n      message.data = data;\n    }\n  }\n  context.baseEncodedPreviousPayload = lastPayload;\n}\nfunction wireToJSON(...args) {\n  let encoding = this.encoding;\n  let data = this.data;\n  if (data && Platform.BufferUtils.isBuffer(data)) {\n    if (args.length > 0) {\n      encoding = encoding ? encoding + \"/base64\" : \"base64\";\n      data = Platform.BufferUtils.base64Encode(data);\n    } else {\n      data = Platform.BufferUtils.toBuffer(data);\n    }\n  }\n  return Object.assign({}, this, { encoding, data });\n}\nfunction populateFieldsFromParent(parent) {\n  const { id, connectionId, timestamp } = parent;\n  let msgs;\n  switch (parent.action) {\n    case actions.MESSAGE: {\n      msgs = parent.messages;\n      break;\n    }\n    case actions.PRESENCE:\n    case actions.SYNC:\n      msgs = parent.presence;\n      break;\n    case actions.ANNOTATION:\n      msgs = parent.annotations;\n      break;\n    default:\n      throw new ErrorInfo(\"Unexpected action \" + parent.action, 4e4, 400);\n  }\n  for (let i = 0; i < msgs.length; i++) {\n    const msg = msgs[i];\n    if (!msg.connectionId) {\n      msg.connectionId = connectionId;\n    }\n    if (!msg.timestamp) {\n      msg.timestamp = timestamp;\n    }\n    if (id && !msg.id) {\n      msg.id = id + \":\" + i;\n    }\n  }\n}\nfunction strMsg(m, cls) {\n  let result = \"[\" + cls;\n  for (const attr in m) {\n    if (attr === \"data\") {\n      if (typeof m.data == \"string\") {\n        result += \"; data=\" + m.data;\n      } else if (Platform.BufferUtils.isBuffer(m.data)) {\n        result += \"; data (buffer)=\" + Platform.BufferUtils.base64Encode(m.data);\n      } else {\n        result += \"; data (json)=\" + JSON.stringify(m.data);\n      }\n    } else if (attr && (attr === \"extras\" || attr === \"operation\")) {\n      result += \"; \" + attr + \"=\" + JSON.stringify(m[attr]);\n    } else if (m[attr] !== void 0) {\n      result += \"; \" + attr + \"=\" + m[attr];\n    }\n  }\n  result += \"]\";\n  return result;\n}\nvar BaseMessage = class {\n};\n\n// src/common/lib/types/presencemessage.ts\nvar actions2 = [\"absent\", \"present\", \"enter\", \"leave\", \"update\"];\nasync function fromEncoded(logger, Crypto2, encoded, inputOptions) {\n  const options = normalizeCipherOptions(Crypto2, logger, inputOptions != null ? inputOptions : null);\n  const wpm = WirePresenceMessage.fromValues(encoded);\n  return wpm.decode(options, logger);\n}\nasync function fromEncodedArray(logger, Crypto2, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded(logger, Crypto2, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded(encoded, channel) {\n  return WirePresenceMessage.fromValues(encoded).decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded(encoded, channel);\n    })\n  );\n}\nvar PresenceMessage = class _PresenceMessage extends BaseMessage {\n  /* Returns whether this presenceMessage is synthesized, i.e. was not actually\n   * sent by the connection (usually means a leave event sent 15s after a\n   * disconnection). This is useful because synthesized messages cannot be\n   * compared for newness by id lexicographically - RTP2b1\n   */\n  isSynthesized() {\n    if (!this.id || !this.connectionId) {\n      return true;\n    }\n    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\n  }\n  /* RTP2b2 */\n  parseId() {\n    if (!this.id)\n      throw new Error(\"parseId(): Presence message does not contain an id\");\n    const parts = this.id.split(\":\");\n    return {\n      connectionId: parts[0],\n      msgSerial: parseInt(parts[1], 10),\n      index: parseInt(parts[2], 10)\n    };\n  }\n  async encode(options) {\n    const res = Object.assign(new WirePresenceMessage(), this, {\n      action: actions2.indexOf(this.action || \"present\")\n    });\n    return encode(res, options);\n  }\n  static fromValues(values) {\n    return Object.assign(new _PresenceMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _PresenceMessage.fromValues(v));\n  }\n  static fromData(data) {\n    if (data instanceof _PresenceMessage) {\n      return data;\n    }\n    return _PresenceMessage.fromValues({\n      data\n    });\n  }\n  toString() {\n    return strMsg(this, \"PresenceMessage\");\n  }\n};\nvar WirePresenceMessage = class _WirePresenceMessage extends BaseMessage {\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WirePresenceMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WirePresenceMessage.fromValues(v));\n  }\n  async decode(channelOptions, logger) {\n    const res = Object.assign(new PresenceMessage(), __spreadProps(__spreadValues({}, this), {\n      action: actions2[this.action]\n    }));\n    try {\n      await decode(res, channelOptions);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WirePresenceMessage.decode()\", inspectError(e));\n    }\n    return res;\n  }\n  toString() {\n    return strMsg(this, \"WirePresenceMessage\");\n  }\n};\nvar presencemessage_default = PresenceMessage;\n\n// src/common/lib/client/restpresence.ts\nvar RestPresence = class {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  get logger() {\n    return this.channel.logger;\n  }\n  async get(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestPresence.get()\", \"channel = \" + this.channel.name);\n    const client = this.channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      this.channel.client.rest.presenceMixin.basePath(this),\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray(decoded, this.channel);\n      }\n    ).get(params);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestPresence.history()\", \"channel = \" + this.channel.name);\n    return this.channel.client.rest.presenceMixin.history(this, params);\n  }\n};\nvar restpresence_default = RestPresence;\n\n// src/common/lib/types/message.ts\nvar actions3 = [\"message.create\", \"message.update\", \"message.delete\", \"meta\", \"message.summary\"];\nfunction stringifyAction(action) {\n  return actions3[action || 0] || \"unknown\";\n}\nfunction getMessageSize(msg) {\n  let size = 0;\n  if (msg.name) {\n    size += msg.name.length;\n  }\n  if (msg.clientId) {\n    size += msg.clientId.length;\n  }\n  if (msg.extras) {\n    size += JSON.stringify(msg.extras).length;\n  }\n  if (msg.data) {\n    size += dataSizeBytes(msg.data);\n  }\n  return size;\n}\nasync function fromEncoded2(logger, Crypto2, encoded, inputOptions) {\n  const options = normalizeCipherOptions(Crypto2, logger, inputOptions != null ? inputOptions : null);\n  const wm = WireMessage.fromValues(encoded);\n  return wm.decode(options, logger);\n}\nasync function fromEncodedArray2(logger, Crypto2, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded2(logger, Crypto2, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded2(encoded, channel) {\n  const wm = WireMessage.fromValues(encoded);\n  return wm.decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray2(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded2(encoded, channel);\n    })\n  );\n}\nasync function encodeArray(messages, options) {\n  return Promise.all(messages.map((message) => message.encode(options)));\n}\nvar serialize = encodeBody;\nfunction getMessagesSize(messages) {\n  let msg, total = 0;\n  for (let i = 0; i < messages.length; i++) {\n    msg = messages[i];\n    total += msg.size || (msg.size = getMessageSize(msg));\n  }\n  return total;\n}\nvar Message = class _Message extends BaseMessage {\n  // TODO improve typings after summary structure is finalised\n  expandFields() {\n    if (this.action === \"message.create\") {\n      if (this.version && !this.serial) {\n        this.serial = this.version;\n      }\n      if (this.timestamp && !this.createdAt) {\n        this.createdAt = this.timestamp;\n      }\n    }\n  }\n  async encode(options) {\n    const res = Object.assign(new WireMessage(), this, {\n      action: actions3.indexOf(this.action || \"message.create\")\n    });\n    return encode(res, options);\n  }\n  static fromValues(values) {\n    return Object.assign(new _Message(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _Message.fromValues(v));\n  }\n  toString() {\n    return strMsg(this, \"Message\");\n  }\n};\nvar WireMessage = class _WireMessage extends BaseMessage {\n  // Overload toJSON() to intercept JSON.stringify()\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WireMessage(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WireMessage.fromValues(v));\n  }\n  // for contexts where some decoding errors need to be handled specially by the caller\n  async decodeWithErr(inputContext, logger) {\n    const res = Object.assign(new Message(), __spreadProps(__spreadValues({}, this), {\n      action: stringifyAction(this.action)\n    }));\n    let err;\n    try {\n      await decode(res, inputContext);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WireMessage.decode()\", inspectError(e));\n      err = e;\n    }\n    res.expandFields();\n    return { decoded: res, err };\n  }\n  async decode(inputContext, logger) {\n    const { decoded } = await this.decodeWithErr(inputContext, logger);\n    return decoded;\n  }\n  toString() {\n    return strMsg(this, \"WireMessage\");\n  }\n};\nvar message_default = Message;\n\n// src/common/lib/client/restchannel.ts\nvar MSG_ID_ENTROPY_BYTES = 9;\nfunction allEmptyIds(messages) {\n  return messages.every(function(message) {\n    return !message.id;\n  });\n}\nvar RestChannel = class {\n  constructor(client, name, channelOptions) {\n    this._annotations = null;\n    var _a2, _b;\n    logger_default.logAction(client.logger, logger_default.LOG_MINOR, \"RestChannel()\", \"started; name = \" + name);\n    this.name = name;\n    this.client = client;\n    this.presence = new restpresence_default(this);\n    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, this.logger, channelOptions);\n    if ((_b = client.options.plugins) == null ? void 0 : _b.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n    if (client._Annotations) {\n      this._annotations = new client._Annotations.RestAnnotations(this);\n    }\n  }\n  get annotations() {\n    if (!this._annotations) {\n      throwMissingPluginError(\"Annotations\");\n    }\n    return this._annotations;\n  }\n  get push() {\n    if (!this._push) {\n      throwMissingPluginError(\"Push\");\n    }\n    return this._push;\n  }\n  get logger() {\n    return this.client.logger;\n  }\n  setOptions(options) {\n    var _a2;\n    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, this.logger, options);\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RestChannel.history()\", \"channel = \" + this.name);\n    return this.client.rest.channelMixin.history(this, params);\n  }\n  async publish(...args) {\n    const first = args[0], second = args[1];\n    let messages;\n    let params;\n    if (typeof first === \"string\" || first === null) {\n      messages = [message_default.fromValues({ name: first, data: second })];\n      params = args[2];\n    } else if (isObject(first)) {\n      messages = [message_default.fromValues(first)];\n      params = args[1];\n    } else if (Array.isArray(first)) {\n      messages = message_default.fromValuesArray(first);\n      params = args[1];\n    } else {\n      throw new ErrorInfo(\n        \"The single-argument form of publish() expects a message object or an array of message objects\",\n        40013,\n        400\n      );\n    }\n    if (!params) {\n      params = {};\n    }\n    const client = this.client, options = client.options, format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, idempotentRestPublishing = client.options.idempotentRestPublishing, headers = defaults_default.defaultPostHeaders(client.options, { format });\n    mixin(headers, options.headers);\n    if (idempotentRestPublishing && allEmptyIds(messages)) {\n      const msgIdBase = await randomString(MSG_ID_ENTROPY_BYTES);\n      messages.forEach(function(message, index) {\n        message.id = msgIdBase + \":\" + index.toString();\n      });\n    }\n    const wireMessages = await encodeArray(messages, this.channelOptions);\n    const size = getMessagesSize(wireMessages), maxMessageSize = options.maxMessageSize;\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        \"Maximum size of messages that can be published at once exceeded ( was \" + size + \" bytes; limit is \" + maxMessageSize + \" bytes)\",\n        40009,\n        400\n      );\n    }\n    await this._publish(serialize(wireMessages, client._MsgPack, format), headers, params);\n  }\n  async _publish(requestBody, headers, params) {\n    await resource_default.post(\n      this.client,\n      this.client.rest.channelMixin.basePath(this) + \"/messages\",\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async status() {\n    return this.client.rest.channelMixin.status(this);\n  }\n};\nvar restchannel_default = RestChannel;\n\n// src/common/lib/types/stats.ts\nvar Stats = class _Stats {\n  constructor(values) {\n    this.entries = values && values.entries || void 0;\n    this.schema = values && values.schema || void 0;\n    this.appId = values && values.appId || void 0;\n    this.inProgress = values && values.inProgress || void 0;\n    this.unit = values && values.unit || void 0;\n    this.intervalId = values && values.intervalId || void 0;\n  }\n  static fromValues(values) {\n    return new _Stats(values);\n  }\n};\nvar stats_default = Stats;\n\n// src/common/lib/client/restchannelmixin.ts\nvar RestChannelMixin = class {\n  static basePath(channel) {\n    return \"/channels/\" + encodeURIComponent(channel.name);\n  }\n  static history(channel, params) {\n    const client = channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(client, this.basePath(channel) + \"/messages\", headers, envelope, async function(body, headers2, unpacked) {\n      const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n      return _fromEncodedArray2(decoded, channel);\n    }).get(params);\n  }\n  static async status(channel) {\n    const format = channel.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    const headers = defaults_default.defaultPostHeaders(channel.client.options, { format });\n    const response = await resource_default.get(\n      channel.client,\n      this.basePath(channel),\n      headers,\n      {},\n      format,\n      true\n    );\n    return response.body;\n  }\n};\n\n// src/common/lib/client/restpresencemixin.ts\nvar RestPresenceMixin = class {\n  static basePath(presence) {\n    return RestChannelMixin.basePath(presence.channel) + \"/presence\";\n  }\n  static async history(presence, params) {\n    const client = presence.channel.client, format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = presence.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      this.basePath(presence) + \"/history\",\n      headers,\n      envelope,\n      async (body, headers2, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray(decoded, presence.channel);\n      }\n    ).get(params);\n  }\n};\n\n// src/common/lib/client/rest.ts\nvar Rest = class {\n  constructor(client) {\n    this.channelMixin = RestChannelMixin;\n    this.presenceMixin = RestPresenceMixin;\n    // exposed for plugins but shouldn't be bundled with minimal realtime\n    this.Resource = resource_default;\n    this.DeviceDetails = devicedetails_default;\n    this.client = client;\n    this.channels = new Channels(this.client);\n    this.push = new push_default(this.client);\n  }\n  async stats(params) {\n    const headers = defaults_default.defaultGetHeaders(this.client.options), format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n    mixin(headers, this.client.options.headers);\n    return new paginatedresource_default(this.client, \"/stats\", headers, envelope, function(body, headers2, unpacked) {\n      const statsValues = unpacked ? body : JSON.parse(body);\n      for (let i = 0; i < statsValues.length; i++)\n        statsValues[i] = stats_default.fromValues(statsValues[i]);\n      return statsValues;\n    }).get(params);\n  }\n  async time(params) {\n    const headers = defaults_default.defaultGetHeaders(this.client.options);\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const timeUri = (host) => {\n      return this.client.baseUri(host) + \"/time\";\n    };\n    let { error, body, unpacked } = await this.client.http.do(\n      HttpMethods_default.Get,\n      timeUri,\n      headers,\n      null,\n      params\n    );\n    if (error) {\n      throw error;\n    }\n    if (!unpacked)\n      body = JSON.parse(body);\n    const time = body[0];\n    if (!time) {\n      throw new ErrorInfo(\"Internal error (unexpected result type from GET /time)\", 5e4, 500);\n    }\n    this.client.serverTimeOffset = time - Date.now();\n    return time;\n  }\n  async request(method, path, version2, params, body, customHeaders) {\n    var _a2;\n    const [encoder, decoder, format] = (() => {\n      if (this.client.options.useBinaryProtocol) {\n        if (!this.client._MsgPack) {\n          throwMissingPluginError(\"MsgPack\");\n        }\n        return [this.client._MsgPack.encode, this.client._MsgPack.decode, \"msgpack\" /* msgpack */];\n      } else {\n        return [JSON.stringify, JSON.parse, \"json\" /* json */];\n      }\n    })();\n    const envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n    params = params || {};\n    const _method = method.toLowerCase();\n    const headers = _method == \"get\" ? defaults_default.defaultGetHeaders(this.client.options, { format, protocolVersion: version2 }) : defaults_default.defaultPostHeaders(this.client.options, { format, protocolVersion: version2 });\n    if (typeof body !== \"string\") {\n      body = (_a2 = encoder(body)) != null ? _a2 : null;\n    }\n    mixin(headers, this.client.options.headers);\n    if (customHeaders) {\n      mixin(headers, customHeaders);\n    }\n    const paginatedResource = new paginatedresource_default(\n      this.client,\n      path,\n      headers,\n      envelope,\n      async function(resbody, headers2, unpacked) {\n        return ensureArray(unpacked ? resbody : decoder(resbody));\n      },\n      /* useHttpPaginatedResponse: */\n      true\n    );\n    if (!Platform.Http.methods.includes(_method)) {\n      throw new ErrorInfo(\"Unsupported method \" + _method, 40500, 405);\n    }\n    if (Platform.Http.methodsWithBody.includes(_method)) {\n      return paginatedResource[_method](params, body);\n    } else {\n      return paginatedResource[_method](params);\n    }\n  }\n  async batchPublish(specOrSpecs) {\n    let requestBodyDTO;\n    let singleSpecMode;\n    if (Array.isArray(specOrSpecs)) {\n      requestBodyDTO = specOrSpecs;\n      singleSpecMode = false;\n    } else {\n      requestBodyDTO = [specOrSpecs];\n      singleSpecMode = true;\n    }\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n    const response = await resource_default.post(this.client, \"/messages\", requestBody, headers, {}, null, true);\n    const batchResults = response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n    if (singleSpecMode) {\n      return batchResults[0];\n    } else {\n      return batchResults;\n    }\n  }\n  async batchPresence(channels) {\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const channelsParam = channels.join(\",\");\n    const response = await resource_default.get(this.client, \"/presence\", headers, { channels: channelsParam }, null, true);\n    return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n  }\n  async revokeTokens(specifiers, options) {\n    if (useTokenAuth(this.client.options)) {\n      throw new ErrorInfo(\"Cannot revoke tokens when using token auth\", 40162, 401);\n    }\n    const keyName = this.client.options.keyName;\n    let resolvedOptions = options != null ? options : {};\n    const requestBodyDTO = __spreadValues({\n      targets: specifiers.map((specifier) => `${specifier.type}:${specifier.value}`)\n    }, resolvedOptions);\n    const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });\n    if (this.client.options.headers)\n      mixin(headers, this.client.options.headers);\n    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n    const response = await resource_default.post(\n      this.client,\n      `/keys/${keyName}/revokeTokens`,\n      requestBody,\n      headers,\n      {},\n      null,\n      true\n    );\n    return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n  }\n};\nvar Channels = class {\n  constructor(client) {\n    this.client = client;\n    this.all = /* @__PURE__ */ Object.create(null);\n  }\n  get(name, channelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      this.all[name] = channel = new restchannel_default(this.client, name, channelOptions);\n    } else if (channelOptions) {\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name) {\n    delete this.all[String(name)];\n  }\n};\n\n// src/common/lib/client/baserest.ts\nvar BaseRest = class extends baseclient_default {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if they’re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options) {\n    super(defaults_default.objectifyOptions(options, false, \"BaseRest\", logger_default.defaultLogger, { Rest }));\n  }\n};\n\n// src/common/lib/client/modularplugins.ts\nvar allCommonModularPlugins = { Rest };\n\n// src/common/lib/types/defaultmessage.ts\nvar DefaultMessage = class extends message_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded2(logger_default.defaultLogger, Platform.Crypto, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray2(logger_default.defaultLogger, Platform.Crypto, encodedArray, options);\n  }\n  static fromValues(values) {\n    return message_default.fromValues(values);\n  }\n};\n\n// src/common/lib/types/defaultpresencemessage.ts\nvar DefaultPresenceMessage = class extends presencemessage_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded(logger_default.defaultLogger, Platform.Crypto, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray(logger_default.defaultLogger, Platform.Crypto, encodedArray, options);\n  }\n  static fromValues(values) {\n    return presencemessage_default.fromValues(values);\n  }\n};\n\n// src/common/lib/types/annotation.ts\nvar actions4 = [\"annotation.create\", \"annotation.delete\"];\nasync function fromEncoded3(logger, encoded, options) {\n  const wa = WireAnnotation.fromValues(encoded);\n  return wa.decode(options || {}, logger);\n}\nasync function fromEncodedArray3(logger, encodedArray, options) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return fromEncoded3(logger, encoded, options);\n    })\n  );\n}\nasync function _fromEncoded3(encoded, channel) {\n  return WireAnnotation.fromValues(encoded).decode(channel.channelOptions, channel.logger);\n}\nasync function _fromEncodedArray3(encodedArray, channel) {\n  return Promise.all(\n    encodedArray.map(function(encoded) {\n      return _fromEncoded3(encoded, channel);\n    })\n  );\n}\nvar Annotation = class _Annotation extends BaseMessage {\n  async encode() {\n    const res = Object.assign(new WireAnnotation(), this, {\n      action: actions4.indexOf(this.action || \"annotation.create\")\n    });\n    return encode(res, {});\n  }\n  static fromValues(values) {\n    return Object.assign(new _Annotation(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _Annotation.fromValues(v));\n  }\n  toString() {\n    return strMsg(this, \"Annotation\");\n  }\n};\nvar WireAnnotation = class _WireAnnotation extends BaseMessage {\n  toJSON(...args) {\n    return wireToJSON.call(this, ...args);\n  }\n  static fromValues(values) {\n    return Object.assign(new _WireAnnotation(), values);\n  }\n  static fromValuesArray(values) {\n    return values.map((v) => _WireAnnotation.fromValues(v));\n  }\n  async decode(channelOptions, logger) {\n    const res = Object.assign(new Annotation(), __spreadProps(__spreadValues({}, this), {\n      action: actions4[this.action]\n    }));\n    try {\n      await decode(res, channelOptions);\n    } catch (e) {\n      logger_default.logAction(logger, logger_default.LOG_ERROR, \"WireAnnotation.decode()\", inspectError(e));\n    }\n    return res;\n  }\n  toString() {\n    return strMsg(this, \"WireAnnotation\");\n  }\n};\nvar annotation_default = Annotation;\n\n// src/common/lib/types/defaultannotation.ts\nvar DefaultAnnotation = class extends annotation_default {\n  static async fromEncoded(encoded, inputOptions) {\n    return fromEncoded3(logger_default.defaultLogger, encoded, inputOptions);\n  }\n  static async fromEncodedArray(encodedArray, options) {\n    return fromEncodedArray3(logger_default.defaultLogger, encodedArray, options);\n  }\n  static fromValues(values) {\n    return annotation_default.fromValues(values);\n  }\n};\n\n// src/common/lib/util/eventemitter.ts\nfunction callListener(logger, eventThis, listener, args) {\n  try {\n    listener.apply(eventThis, args);\n  } catch (e) {\n    logger_default.logAction(\n      logger,\n      logger_default.LOG_ERROR,\n      \"EventEmitter.emit()\",\n      \"Unexpected listener exception: \" + e + \"; stack = \" + (e && e.stack)\n    );\n  }\n}\nfunction removeListener(targetListeners, listener, eventFilter) {\n  let listeners;\n  let index;\n  let eventName;\n  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\n    listeners = targetListeners[targetListenersIndex];\n    if (eventFilter) {\n      listeners = listeners[eventFilter];\n    }\n    if (Array.isArray(listeners)) {\n      while ((index = listeners.indexOf(listener)) !== -1) {\n        listeners.splice(index, 1);\n      }\n      if (eventFilter && listeners.length === 0) {\n        delete targetListeners[targetListenersIndex][eventFilter];\n      }\n    } else if (isObject(listeners)) {\n      for (eventName in listeners) {\n        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Array.isArray(listeners[eventName])) {\n          removeListener([listeners], listener, eventName);\n        }\n      }\n    }\n  }\n}\nvar EventEmitter = class {\n  constructor(logger) {\n    this.logger = logger;\n    this.any = [];\n    this.events = /* @__PURE__ */ Object.create(null);\n    this.anyOnce = [];\n    this.eventsOnce = /* @__PURE__ */ Object.create(null);\n  }\n  on(...args) {\n    if (args.length === 1) {\n      const listener = args[0];\n      if (typeof listener === \"function\") {\n        this.any.push(listener);\n      } else {\n        throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n      }\n    }\n    if (args.length === 2) {\n      const [event, listener] = args;\n      if (typeof listener !== \"function\") {\n        throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n      }\n      if (isNil(event)) {\n        this.any.push(listener);\n      } else if (Array.isArray(event)) {\n        event.forEach((eventName) => {\n          this.on(eventName, listener);\n        });\n      } else {\n        if (typeof event !== \"string\") {\n          throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n        }\n        const listeners = this.events[event] || (this.events[event] = []);\n        listeners.push(listener);\n      }\n    }\n  }\n  off(...args) {\n    if (args.length == 0 || isNil(args[0]) && isNil(args[1])) {\n      this.any = [];\n      this.events = /* @__PURE__ */ Object.create(null);\n      this.anyOnce = [];\n      this.eventsOnce = /* @__PURE__ */ Object.create(null);\n      return;\n    }\n    const [firstArg, secondArg] = args;\n    let listener = null;\n    let event = null;\n    if (args.length === 1 || !secondArg) {\n      if (typeof firstArg === \"function\") {\n        listener = firstArg;\n      } else {\n        event = firstArg;\n      }\n    } else {\n      if (typeof secondArg !== \"function\") {\n        throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      [event, listener] = [firstArg, secondArg];\n    }\n    if (listener && isNil(event)) {\n      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\n      return;\n    }\n    if (Array.isArray(event)) {\n      event.forEach((eventName) => {\n        this.off(eventName, listener);\n      });\n      return;\n    }\n    if (typeof event !== \"string\") {\n      throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n    }\n    if (listener) {\n      removeListener([this.events, this.eventsOnce], listener, event);\n    } else {\n      delete this.events[event];\n      delete this.eventsOnce[event];\n    }\n  }\n  /**\n   * Get the array of listeners for a given event; excludes once events\n   * @param event (optional) the name of the event, or none for 'any'\n   * @return array of events, or null if none\n   */\n  listeners(event) {\n    if (event) {\n      const listeners = this.events[event] || [];\n      if (this.eventsOnce[event])\n        Array.prototype.push.apply(listeners, this.eventsOnce[event]);\n      return listeners.length ? listeners : null;\n    }\n    return this.any.length ? this.any : null;\n  }\n  /**\n   * Emit an event\n   * @param event the event name\n   * @param args the arguments to pass to the listener\n   */\n  emit(event, ...args) {\n    const eventThis = { event };\n    const listeners = [];\n    if (this.anyOnce.length) {\n      Array.prototype.push.apply(listeners, this.anyOnce);\n      this.anyOnce = [];\n    }\n    if (this.any.length) {\n      Array.prototype.push.apply(listeners, this.any);\n    }\n    const eventsOnceListeners = this.eventsOnce[event];\n    if (eventsOnceListeners) {\n      Array.prototype.push.apply(listeners, eventsOnceListeners);\n      delete this.eventsOnce[event];\n    }\n    const eventsListeners = this.events[event];\n    if (eventsListeners) {\n      Array.prototype.push.apply(listeners, eventsListeners);\n    }\n    listeners.forEach((listener) => {\n      callListener(this.logger, eventThis, listener, args);\n    });\n  }\n  once(...args) {\n    const argCount = args.length;\n    if (argCount === 0 || argCount === 1 && typeof args[0] !== \"function\") {\n      const event = args[0];\n      return new Promise((resolve) => {\n        this.once(event, resolve);\n      });\n    }\n    const [firstArg, secondArg] = args;\n    if (args.length === 1 && typeof firstArg === \"function\") {\n      this.anyOnce.push(firstArg);\n    } else if (isNil(firstArg)) {\n      if (typeof secondArg !== \"function\") {\n        throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      this.anyOnce.push(secondArg);\n    } else if (Array.isArray(firstArg)) {\n      const self2 = this;\n      const listenerWrapper = function() {\n        const innerArgs = Array.prototype.slice.call(arguments);\n        firstArg.forEach(function(eventName) {\n          self2.off(eventName, listenerWrapper);\n        });\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        secondArg.apply(this, innerArgs);\n      };\n      firstArg.forEach(function(eventName) {\n        self2.on(eventName, listenerWrapper);\n      });\n    } else {\n      if (typeof firstArg !== \"string\") {\n        throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\n      if (secondArg) {\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        listeners.push(secondArg);\n      }\n    }\n  }\n  /**\n   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\n   * @param targetState the name of the state event to listen to\n   * @param currentState the name of the current state of this object\n   */\n  async whenState(targetState, currentState) {\n    if (typeof targetState !== \"string\" || typeof currentState !== \"string\") {\n      throw new Error(\"whenState requires a valid state String argument\");\n    }\n    if (targetState === currentState) {\n      return null;\n    } else {\n      return this.once(targetState);\n    }\n  }\n};\nvar eventemitter_default = EventEmitter;\n\n// src/common/lib/client/restannotations.ts\nfunction serialFromMsgOrSerial(msgOrSerial) {\n  let messageSerial;\n  switch (typeof msgOrSerial) {\n    case \"string\":\n      messageSerial = msgOrSerial;\n      break;\n    case \"object\":\n      messageSerial = msgOrSerial.serial;\n      break;\n  }\n  if (!messageSerial || typeof messageSerial !== \"string\") {\n    throw new ErrorInfo(\n      \"First argument of annotations.publish() must be either a Message (or at least an object with a string `serial` property) or a message serial (string)\",\n      40003,\n      400\n    );\n  }\n  return messageSerial;\n}\nfunction constructValidateAnnotation(msgOrSerial, annotationValues) {\n  const messageSerial = serialFromMsgOrSerial(msgOrSerial);\n  if (!annotationValues || typeof annotationValues !== \"object\") {\n    throw new ErrorInfo(\n      \"Second argument of annotations.publish() must be an object (the intended annotation to publish)\",\n      40003,\n      400\n    );\n  }\n  const annotation = annotation_default.fromValues(annotationValues);\n  annotation.messageSerial = messageSerial;\n  if (!annotation.action) {\n    annotation.action = \"annotation.create\";\n  }\n  return annotation;\n}\nfunction basePathForSerial(channel, serial) {\n  return channel.client.rest.channelMixin.basePath(channel) + \"/messages/\" + encodeURIComponent(serial) + \"/annotations\";\n}\nvar RestAnnotations = class {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  async publish(msgOrSerial, annotationValues) {\n    const annotation = constructValidateAnnotation(msgOrSerial, annotationValues);\n    const wireAnnotation = await annotation.encode();\n    const client = this.channel.client, options = client.options, format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};\n    mixin(headers, client.options.headers);\n    const requestBody = encodeBody([wireAnnotation], client._MsgPack, format);\n    await resource_default.post(\n      client,\n      basePathForSerial(this.channel, annotation.messageSerial),\n      requestBody,\n      headers,\n      params,\n      null,\n      true\n    );\n  }\n  async delete(msgOrSerial, annotationValues) {\n    annotationValues.action = \"annotation.delete\";\n    return this.publish(msgOrSerial, annotationValues);\n  }\n  async get(msgOrSerial, params) {\n    const client = this.channel.client, messageSerial = serialFromMsgOrSerial(msgOrSerial), format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */, envelope = client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });\n    mixin(headers, client.options.headers);\n    return new paginatedresource_default(\n      client,\n      basePathForSerial(this.channel, messageSerial),\n      headers,\n      envelope,\n      async (body, _, unpacked) => {\n        const decoded = unpacked ? body : decodeBody(body, client._MsgPack, format);\n        return _fromEncodedArray3(decoded, this.channel);\n      }\n    ).get(params);\n  }\n};\nvar restannotations_default = RestAnnotations;\n\n// src/common/lib/types/protocolmessage.ts\nvar serialize2 = encodeBody;\nfunction toStringArray(array) {\n  const result = [];\n  if (array) {\n    for (let i = 0; i < array.length; i++) {\n      result.push(array[i].toString());\n    }\n  }\n  return \"[ \" + result.join(\", \") + \" ]\";\n}\nfunction deserialize(serialized, MsgPack, presenceMessagePlugin, annotationsPlugin, format) {\n  const deserialized = decodeBody(serialized, MsgPack, format);\n  return fromDeserialized(deserialized, presenceMessagePlugin, annotationsPlugin);\n}\nfunction fromDeserialized(deserialized, presenceMessagePlugin, annotationsPlugin) {\n  let error;\n  if (deserialized.error) {\n    error = ErrorInfo.fromValues(deserialized.error);\n  }\n  let messages;\n  if (deserialized.messages) {\n    messages = WireMessage.fromValuesArray(deserialized.messages);\n  }\n  let presence;\n  if (presenceMessagePlugin && deserialized.presence) {\n    presence = presenceMessagePlugin.WirePresenceMessage.fromValuesArray(\n      deserialized.presence\n    );\n  }\n  let annotations;\n  if (annotationsPlugin && deserialized.annotations) {\n    annotations = annotationsPlugin.WireAnnotation.fromValuesArray(\n      deserialized.annotations\n    );\n  }\n  return Object.assign(new ProtocolMessage(), __spreadProps(__spreadValues({}, deserialized), { presence, messages, annotations, error }));\n}\nfunction fromDeserializedIncludingDependencies(deserialized) {\n  return fromDeserialized(\n    deserialized,\n    { PresenceMessage: presencemessage_default, WirePresenceMessage },\n    { Annotation: annotation_default, WireAnnotation, RealtimeAnnotations: realtimeannotations_default, RestAnnotations: restannotations_default }\n  );\n}\nfunction fromValues(values) {\n  return Object.assign(new ProtocolMessage(), values);\n}\nfunction stringify(msg, presenceMessagePlugin, annotationsPlugin) {\n  let result = \"[ProtocolMessage\";\n  if (msg.action !== void 0)\n    result += \"; action=\" + ActionName[msg.action] || 0;\n  const simpleAttributes = [\"id\", \"channel\", \"channelSerial\", \"connectionId\", \"count\", \"msgSerial\", \"timestamp\"];\n  let attribute;\n  for (let attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {\n    attribute = simpleAttributes[attribIndex];\n    if (msg[attribute] !== void 0)\n      result += \"; \" + attribute + \"=\" + msg[attribute];\n  }\n  if (msg.messages)\n    result += \"; messages=\" + toStringArray(WireMessage.fromValuesArray(msg.messages));\n  if (msg.presence && presenceMessagePlugin)\n    result += \"; presence=\" + toStringArray(presenceMessagePlugin.WirePresenceMessage.fromValuesArray(msg.presence));\n  if (msg.annotations && annotationsPlugin) {\n    result += \"; annotations=\" + toStringArray(annotationsPlugin.WireAnnotation.fromValuesArray(msg.annotations));\n  }\n  if (msg.error)\n    result += \"; error=\" + ErrorInfo.fromValues(msg.error).toString();\n  if (msg.auth && msg.auth.accessToken)\n    result += \"; token=\" + msg.auth.accessToken;\n  if (msg.flags)\n    result += \"; flags=\" + flagNames.filter(msg.hasFlag).join(\",\");\n  if (msg.params) {\n    let stringifiedParams = \"\";\n    forInOwnNonNullProperties(msg.params, function(prop) {\n      if (stringifiedParams.length > 0) {\n        stringifiedParams += \"; \";\n      }\n      stringifiedParams += prop + \"=\" + msg.params[prop];\n    });\n    if (stringifiedParams.length > 0) {\n      result += \"; params=[\" + stringifiedParams + \"]\";\n    }\n  }\n  result += \"]\";\n  return result;\n}\nvar ProtocolMessage = class {\n  constructor() {\n    this.hasFlag = (flag) => {\n      return (this.flags & flags[flag]) > 0;\n    };\n  }\n  setFlag(flag) {\n    return this.flags = this.flags | flags[flag];\n  }\n  getMode() {\n    return (this.flags || 0) & flags.MODE_ALL;\n  }\n  encodeModesToFlags(modes) {\n    modes.forEach((mode) => this.setFlag(mode));\n  }\n  decodeModesFromFlags() {\n    const modes = [];\n    channelModes.forEach((mode) => {\n      if (this.hasFlag(mode)) {\n        modes.push(mode);\n      }\n    });\n    return modes.length > 0 ? modes : void 0;\n  }\n};\nvar protocolmessage_default = ProtocolMessage;\n\n// src/common/lib/client/channelstatechange.ts\nvar ChannelStateChange = class {\n  constructor(previous, current, resumed, hasBacklog, reason) {\n    this.previous = previous;\n    this.current = current;\n    if (current === \"attached\") {\n      this.resumed = resumed;\n      this.hasBacklog = hasBacklog;\n    }\n    if (reason)\n      this.reason = reason;\n  }\n};\nvar channelstatechange_default = ChannelStateChange;\n\n// src/common/lib/client/realtimechannel.ts\nvar noop = function() {\n};\nfunction validateChannelOptions(options) {\n  if (options && \"params\" in options && !isObject(options.params)) {\n    return new ErrorInfo(\"options.params must be an object\", 4e4, 400);\n  }\n  if (options && \"modes\" in options) {\n    if (!Array.isArray(options.modes)) {\n      return new ErrorInfo(\"options.modes must be an array\", 4e4, 400);\n    }\n    for (let i = 0; i < options.modes.length; i++) {\n      const currentMode = options.modes[i];\n      if (!currentMode || typeof currentMode !== \"string\" || !channelModes.includes(String.prototype.toUpperCase.call(currentMode))) {\n        return new ErrorInfo(\"Invalid channel mode: \" + currentMode, 4e4, 400);\n      }\n    }\n  }\n}\nvar RealtimeChannel = class _RealtimeChannel extends eventemitter_default {\n  constructor(client, name, options) {\n    var _a2, _b;\n    super(client.logger);\n    this._annotations = null;\n    this._mode = 0;\n    this.retryCount = 0;\n    this.history = async function(params) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.history()\", \"channel = \" + this.name);\n      const restMixin = this.client.rest.channelMixin;\n      if (params && params.untilAttach) {\n        if (this.state !== \"attached\") {\n          throw new ErrorInfo(\"option untilAttach requires the channel to be attached\", 4e4, 400);\n        }\n        if (!this.properties.attachSerial) {\n          throw new ErrorInfo(\n            \"untilAttach was specified and channel is attached, but attachSerial is not defined\",\n            4e4,\n            400\n          );\n        }\n        delete params.untilAttach;\n        params.from_serial = this.properties.attachSerial;\n      }\n      return restMixin.history(this, params);\n    };\n    this.whenState = (state) => {\n      return eventemitter_default.prototype.whenState.call(this, state, this.state);\n    };\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"RealtimeChannel()\", \"started; name = \" + name);\n    this.name = name;\n    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, this.logger, options);\n    this.client = client;\n    this._presence = client._RealtimePresence ? new client._RealtimePresence.RealtimePresence(this) : null;\n    if (client._Annotations) {\n      this._annotations = new client._Annotations.RealtimeAnnotations(this);\n    }\n    this.connectionManager = client.connection.connectionManager;\n    this.state = \"initialized\";\n    this.subscriptions = new eventemitter_default(this.logger);\n    this.syncChannelSerial = void 0;\n    this.properties = {\n      attachSerial: void 0,\n      channelSerial: void 0\n    };\n    this.setOptions(options);\n    this.errorReason = null;\n    this._attachResume = false;\n    this._decodingContext = {\n      channelOptions: this.channelOptions,\n      plugins: client.options.plugins || {},\n      baseEncodedPreviousPayload: void 0\n    };\n    this._lastPayload = {\n      messageId: null,\n      protocolMessageChannelSerial: null,\n      decodeFailureRecoveryInProgress: null\n    };\n    this._allChannelChanges = new eventemitter_default(this.logger);\n    if ((_b = client.options.plugins) == null ? void 0 : _b.Push) {\n      this._push = new client.options.plugins.Push.PushChannel(this);\n    }\n  }\n  get presence() {\n    if (!this._presence) {\n      throwMissingPluginError(\"RealtimePresence\");\n    }\n    return this._presence;\n  }\n  get annotations() {\n    if (!this._annotations) {\n      throwMissingPluginError(\"Annotations\");\n    }\n    return this._annotations;\n  }\n  get push() {\n    if (!this._push) {\n      throwMissingPluginError(\"Push\");\n    }\n    return this._push;\n  }\n  invalidStateError() {\n    return new ErrorInfo(\n      \"Channel operation failed as channel state is \" + this.state,\n      90001,\n      400,\n      this.errorReason || void 0\n    );\n  }\n  static processListenerArgs(args) {\n    args = Array.prototype.slice.call(args);\n    if (typeof args[0] === \"function\") {\n      args.unshift(null);\n    }\n    return args;\n  }\n  async setOptions(options) {\n    var _a2;\n    const previousChannelOptions = this.channelOptions;\n    const err = validateChannelOptions(options);\n    if (err) {\n      throw err;\n    }\n    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, this.logger, options);\n    if (this._decodingContext)\n      this._decodingContext.channelOptions = this.channelOptions;\n    if (this._shouldReattachToSetOptions(options, previousChannelOptions)) {\n      this.attachImpl();\n      return new Promise((resolve, reject) => {\n        this._allChannelChanges.once(\n          [\"attached\", \"update\", \"detached\", \"failed\"],\n          function(stateChange) {\n            switch (this.event) {\n              case \"update\":\n              case \"attached\":\n                resolve();\n                break;\n              default:\n                reject(stateChange.reason);\n            }\n          }\n        );\n      });\n    }\n  }\n  _shouldReattachToSetOptions(options, prevOptions) {\n    if (!(this.state === \"attached\" || this.state === \"attaching\")) {\n      return false;\n    }\n    if (options == null ? void 0 : options.params) {\n      const requestedParams = omitAgent(options.params);\n      const existingParams = omitAgent(prevOptions.params);\n      if (Object.keys(requestedParams).length !== Object.keys(existingParams).length) {\n        return true;\n      }\n      if (!shallowEquals(existingParams, requestedParams)) {\n        return true;\n      }\n    }\n    if (options == null ? void 0 : options.modes) {\n      if (!prevOptions.modes || !arrEquals(options.modes, prevOptions.modes)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async publish(...args) {\n    let messages;\n    let argCount = args.length;\n    if (argCount == 1) {\n      if (isObject(args[0])) {\n        messages = [message_default.fromValues(args[0])];\n      } else if (Array.isArray(args[0])) {\n        messages = message_default.fromValuesArray(args[0]);\n      } else {\n        throw new ErrorInfo(\n          \"The single-argument form of publish() expects a message object or an array of message objects\",\n          40013,\n          400\n        );\n      }\n    } else {\n      messages = [message_default.fromValues({ name: args[0], data: args[1] })];\n    }\n    const maxMessageSize = this.client.options.maxMessageSize;\n    const wireMessages = await encodeArray(messages, this.channelOptions);\n    const size = getMessagesSize(wireMessages);\n    if (size > maxMessageSize) {\n      throw new ErrorInfo(\n        \"Maximum size of messages that can be published at once exceeded ( was \" + size + \" bytes; limit is \" + maxMessageSize + \" bytes)\",\n        40009,\n        400\n      );\n    }\n    this._throwIfUnpublishableState();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.publish()\",\n      \"sending message; channel state is \" + this.state + \", message count = \" + wireMessages.length\n    );\n    const pm = fromValues({ action: actions.MESSAGE, channel: this.name, messages: wireMessages });\n    return this.sendMessage(pm);\n  }\n  _throwIfUnpublishableState() {\n    if (!this.connectionManager.activeState()) {\n      throw this.connectionManager.getError();\n    }\n    if (this.state === \"failed\" || this.state === \"suspended\") {\n      throw this.invalidStateError();\n    }\n  }\n  onEvent(messages) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.onEvent()\", \"received message\");\n    const subscriptions = this.subscriptions;\n    for (let i = 0; i < messages.length; i++) {\n      const message = messages[i];\n      subscriptions.emit(message.name, message);\n    }\n  }\n  async attach() {\n    if (this.state === \"attached\") {\n      return null;\n    }\n    return new Promise((resolve, reject) => {\n      this._attach(false, null, (err, result) => err ? reject(err) : resolve(result));\n    });\n  }\n  _attach(forceReattach, attachReason, callback) {\n    if (!callback) {\n      callback = (err) => {\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"RealtimeChannel._attach()\",\n            \"Channel attach failed: \" + err.toString()\n          );\n        }\n      };\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      callback(connectionManager.getError());\n      return;\n    }\n    if (this.state !== \"attaching\" || forceReattach) {\n      this.requestState(\"attaching\", attachReason);\n    }\n    this.once(function(stateChange) {\n      switch (this.event) {\n        case \"attached\":\n          callback == null ? void 0 : callback(null, stateChange);\n          break;\n        case \"detached\":\n        case \"suspended\":\n        case \"failed\":\n          callback == null ? void 0 : callback(\n            stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to attach; reason unknown; state = \" + this.event, 9e4, 500)\n          );\n          break;\n        case \"detaching\":\n          callback == null ? void 0 : callback(new ErrorInfo(\"Attach request superseded by a subsequent detach request\", 9e4, 409));\n          break;\n      }\n    });\n  }\n  attachImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.attachImpl()\", \"sending ATTACH message\");\n    const attachMsg = fromValues({\n      action: actions.ATTACH,\n      channel: this.name,\n      params: this.channelOptions.params,\n      // RTL4c1: Includes the channel serial to resume from a previous message\n      // or attachment.\n      channelSerial: this.properties.channelSerial\n    });\n    if (this.channelOptions.modes) {\n      attachMsg.encodeModesToFlags(allToUpperCase(this.channelOptions.modes));\n    }\n    if (this._attachResume) {\n      attachMsg.setFlag(\"ATTACH_RESUME\");\n    }\n    if (this._lastPayload.decodeFailureRecoveryInProgress) {\n      attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;\n    }\n    this.sendMessage(attachMsg).catch(noop);\n  }\n  async detach() {\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      throw connectionManager.getError();\n    }\n    switch (this.state) {\n      case \"suspended\":\n        this.notifyState(\"detached\");\n        return;\n      case \"detached\":\n        return;\n      case \"failed\":\n        throw new ErrorInfo(\"Unable to detach; channel state = failed\", 90001, 400);\n      default:\n        this.requestState(\"detaching\");\n      case \"detaching\":\n        return new Promise((resolve, reject) => {\n          this.once(function(stateChange) {\n            switch (this.event) {\n              case \"detached\":\n                resolve();\n                break;\n              case \"attached\":\n              case \"suspended\":\n              case \"failed\":\n                reject(\n                  stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to detach; reason unknown; state = \" + this.event, 9e4, 500)\n                );\n                break;\n              case \"attaching\":\n                reject(new ErrorInfo(\"Detach request superseded by a subsequent attach request\", 9e4, 409));\n                break;\n            }\n          });\n        });\n    }\n  }\n  detachImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimeChannel.detach()\", \"sending DETACH message\");\n    const msg = fromValues({ action: actions.DETACH, channel: this.name });\n    this.sendMessage(msg).catch(noop);\n  }\n  async subscribe(...args) {\n    const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n    if (this.state === \"failed\") {\n      throw ErrorInfo.fromValues(this.invalidStateError());\n    }\n    if (event && typeof event === \"object\" && !Array.isArray(event)) {\n      this.client._FilteredSubscriptions.subscribeFilter(this, event, listener);\n    } else {\n      this.subscriptions.on(event, listener);\n    }\n    if (this.channelOptions.attachOnSubscribe !== false) {\n      return this.attach();\n    } else {\n      return null;\n    }\n  }\n  unsubscribe(...args) {\n    var _a2;\n    const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n    if (typeof event === \"object\" && !listener || ((_a2 = this.filteredSubscriptions) == null ? void 0 : _a2.has(listener))) {\n      this.client._FilteredSubscriptions.getAndDeleteFilteredSubscriptions(this, event, listener).forEach((l) => this.subscriptions.off(l));\n      return;\n    }\n    this.subscriptions.off(event, listener);\n  }\n  sync() {\n    switch (this.state) {\n      case \"initialized\":\n      case \"detaching\":\n      case \"detached\":\n        throw new PartialErrorInfo(\"Unable to sync to channel; not attached\", 4e4);\n      default:\n    }\n    const connectionManager = this.connectionManager;\n    if (!connectionManager.activeState()) {\n      throw connectionManager.getError();\n    }\n    const syncMessage = fromValues({ action: actions.SYNC, channel: this.name });\n    if (this.syncChannelSerial) {\n      syncMessage.channelSerial = this.syncChannelSerial;\n    }\n    connectionManager.send(syncMessage);\n  }\n  async sendMessage(msg) {\n    return new Promise((resolve, reject) => {\n      this.connectionManager.send(msg, this.client.options.queueMessages, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n  async sendPresence(presence) {\n    const msg = fromValues({\n      action: actions.PRESENCE,\n      channel: this.name,\n      presence\n    });\n    return this.sendMessage(msg);\n  }\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage, in order to synchronise access to the state stored in _decodingContext.\n  async processMessage(message) {\n    if (message.action === actions.ATTACHED || message.action === actions.MESSAGE || message.action === actions.PRESENCE || message.action === actions.ANNOTATION) {\n      this.setChannelSerial(message.channelSerial);\n    }\n    let syncChannelSerial, isSync = false;\n    switch (message.action) {\n      case actions.ATTACHED: {\n        this.properties.attachSerial = message.channelSerial;\n        this._mode = message.getMode();\n        this.params = message.params || {};\n        const modesFromFlags = message.decodeModesFromFlags();\n        this.modes = modesFromFlags && allToLowerCase(modesFromFlags) || void 0;\n        const resumed = message.hasFlag(\"RESUMED\");\n        const hasPresence = message.hasFlag(\"HAS_PRESENCE\");\n        const hasBacklog = message.hasFlag(\"HAS_BACKLOG\");\n        if (this.state === \"attached\") {\n          if (!resumed) {\n            if (this._presence) {\n              this._presence.onAttached(hasPresence);\n            }\n          }\n          const change = new channelstatechange_default(this.state, this.state, resumed, hasBacklog, message.error);\n          this._allChannelChanges.emit(\"update\", change);\n          if (!resumed || this.channelOptions.updateOnAttached) {\n            this.emit(\"update\", change);\n          }\n        } else if (this.state === \"detaching\") {\n          this.checkPendingState();\n        } else {\n          this.notifyState(\"attached\", message.error, resumed, hasPresence, hasBacklog);\n        }\n        break;\n      }\n      case actions.DETACHED: {\n        const detachErr = message.error ? ErrorInfo.fromValues(message.error) : new ErrorInfo(\"Channel detached\", 90001, 404);\n        if (this.state === \"detaching\") {\n          this.notifyState(\"detached\", detachErr);\n        } else if (this.state === \"attaching\") {\n          this.notifyState(\"suspended\", detachErr);\n        } else if (this.state === \"attached\" || this.state === \"suspended\") {\n          this.requestState(\"attaching\", detachErr);\n        }\n        break;\n      }\n      case actions.SYNC:\n        isSync = true;\n        syncChannelSerial = this.syncChannelSerial = message.channelSerial;\n        if (!message.presence)\n          break;\n      case actions.PRESENCE: {\n        if (!message.presence) {\n          break;\n        }\n        populateFieldsFromParent(message);\n        const options = this.channelOptions;\n        if (this._presence) {\n          const presenceMessages = await Promise.all(\n            message.presence.map((wpm) => {\n              return wpm.decode(options, this.logger);\n            })\n          );\n          this._presence.setPresence(presenceMessages, isSync, syncChannelSerial);\n        }\n        break;\n      }\n      case actions.MESSAGE: {\n        if (this.state !== \"attached\") {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"RealtimeChannel.processMessage()\",\n            'Message \"' + message.id + '\" skipped as this channel \"' + this.name + '\" state is not \"attached\" (state is \"' + this.state + '\").'\n          );\n          return;\n        }\n        populateFieldsFromParent(message);\n        const encoded = message.messages, firstMessage = encoded[0], lastMessage = encoded[encoded.length - 1];\n        if (firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {\n          const msg = 'Delta message decode failure - previous message not available for message \"' + message.id + '\" on this channel \"' + this.name + '\".';\n          logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"RealtimeChannel.processMessage()\", msg);\n          this._startDecodeFailureRecovery(new ErrorInfo(msg, 40018, 400));\n          break;\n        }\n        let messages = [];\n        for (let i = 0; i < encoded.length; i++) {\n          const { decoded, err } = await encoded[i].decodeWithErr(this._decodingContext, this.logger);\n          messages[i] = decoded;\n          if (err) {\n            switch (err.code) {\n              case 40018:\n                this._startDecodeFailureRecovery(err);\n                return;\n              case 40019:\n              case 40021:\n                this.notifyState(\"failed\", err);\n                return;\n              default:\n            }\n          }\n        }\n        this._lastPayload.messageId = lastMessage.id;\n        this._lastPayload.protocolMessageChannelSerial = message.channelSerial;\n        this.onEvent(messages);\n        break;\n      }\n      case actions.ANNOTATION: {\n        populateFieldsFromParent(message);\n        const options = this.channelOptions;\n        if (this._annotations) {\n          const annotations = await Promise.all(\n            (message.annotations || []).map((wpm) => {\n              return wpm.decode(options, this.logger);\n            })\n          );\n          this._annotations._processIncoming(annotations);\n        }\n        break;\n      }\n      case actions.ERROR: {\n        const err = message.error;\n        if (err && err.code == 80016) {\n          this.checkPendingState();\n        } else {\n          this.notifyState(\"failed\", ErrorInfo.fromValues(err));\n        }\n        break;\n      }\n      default:\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MAJOR,\n          \"RealtimeChannel.processMessage()\",\n          \"Protocol error: unrecognised message action (\" + message.action + \")\"\n        );\n    }\n  }\n  _startDecodeFailureRecovery(reason) {\n    if (!this._lastPayload.decodeFailureRecoveryInProgress) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MAJOR,\n        \"RealtimeChannel.processMessage()\",\n        \"Starting decode failure recovery process.\"\n      );\n      this._lastPayload.decodeFailureRecoveryInProgress = true;\n      this._attach(true, reason, () => {\n        this._lastPayload.decodeFailureRecoveryInProgress = false;\n      });\n    }\n  }\n  onAttached() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.onAttached\",\n      \"activating channel; name = \" + this.name\n    );\n  }\n  notifyState(state, reason, resumed, hasPresence, hasBacklog) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.notifyState\",\n      \"name = \" + this.name + \", current state = \" + this.state + \", notifying state \" + state\n    );\n    this.clearStateTimer();\n    if ([\"detached\", \"suspended\", \"failed\"].includes(state)) {\n      this.properties.channelSerial = null;\n    }\n    if (state === this.state) {\n      return;\n    }\n    if (this._presence) {\n      this._presence.actOnChannelState(state, hasPresence, reason);\n    }\n    if (state === \"suspended\" && this.connectionManager.state.sendEvents) {\n      this.startRetryTimer();\n    } else {\n      this.cancelRetryTimer();\n    }\n    if (reason) {\n      this.errorReason = reason;\n    }\n    const change = new channelstatechange_default(this.state, state, resumed, hasBacklog, reason);\n    const action = 'Channel state for channel \"' + this.name + '\"';\n    const message = state + (reason ? \"; reason: \" + reason : \"\");\n    if (state === \"failed\") {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, action, message);\n    } else {\n      logger_default.logAction(this.logger, logger_default.LOG_MAJOR, action, message);\n    }\n    if (state !== \"attaching\" && state !== \"suspended\") {\n      this.retryCount = 0;\n    }\n    if (state === \"attached\") {\n      this.onAttached();\n    }\n    if (state === \"attached\") {\n      this._attachResume = true;\n    } else if (state === \"detaching\" || state === \"failed\") {\n      this._attachResume = false;\n    }\n    this.state = state;\n    this._allChannelChanges.emit(state, change);\n    this.emit(state, change);\n  }\n  requestState(state, reason) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.requestState\",\n      \"name = \" + this.name + \", state = \" + state\n    );\n    this.notifyState(state, reason);\n    this.checkPendingState();\n  }\n  checkPendingState() {\n    const cmState = this.connectionManager.state;\n    if (!cmState.sendEvents) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"RealtimeChannel.checkPendingState\",\n        \"sendEvents is false; state is \" + this.connectionManager.state.state\n      );\n      return;\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimeChannel.checkPendingState\",\n      \"name = \" + this.name + \", state = \" + this.state\n    );\n    switch (this.state) {\n      case \"attaching\":\n        this.startStateTimerIfNotRunning();\n        this.attachImpl();\n        break;\n      case \"detaching\":\n        this.startStateTimerIfNotRunning();\n        this.detachImpl();\n        break;\n      case \"attached\":\n        this.sync();\n        break;\n      default:\n        break;\n    }\n  }\n  timeoutPendingState() {\n    switch (this.state) {\n      case \"attaching\": {\n        const err = new ErrorInfo(\"Channel attach timed out\", 90007, 408);\n        this.notifyState(\"suspended\", err);\n        break;\n      }\n      case \"detaching\": {\n        const err = new ErrorInfo(\"Channel detach timed out\", 90007, 408);\n        this.notifyState(\"attached\", err);\n        break;\n      }\n      default:\n        this.checkPendingState();\n        break;\n    }\n  }\n  startStateTimerIfNotRunning() {\n    if (!this.stateTimer) {\n      this.stateTimer = setTimeout(() => {\n        logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"RealtimeChannel.startStateTimerIfNotRunning\", \"timer expired\");\n        this.stateTimer = null;\n        this.timeoutPendingState();\n      }, this.client.options.timeouts.realtimeRequestTimeout);\n    }\n  }\n  clearStateTimer() {\n    const stateTimer = this.stateTimer;\n    if (stateTimer) {\n      clearTimeout(stateTimer);\n      this.stateTimer = null;\n    }\n  }\n  startRetryTimer() {\n    if (this.retryTimer)\n      return;\n    this.retryCount++;\n    const retryDelay = getRetryTime(this.client.options.timeouts.channelRetryTimeout, this.retryCount);\n    this.retryTimer = setTimeout(() => {\n      if (this.state === \"suspended\" && this.connectionManager.state.sendEvents) {\n        this.retryTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"RealtimeChannel retry timer expired\",\n          \"attempting a new attach\"\n        );\n        this.requestState(\"attaching\");\n      }\n    }, retryDelay);\n  }\n  cancelRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n  /* @returns null (if can safely be released) | ErrorInfo (if cannot) */\n  getReleaseErr() {\n    const s = this.state;\n    if (s === \"initialized\" || s === \"detached\" || s === \"failed\") {\n      return null;\n    }\n    return new ErrorInfo(\n      \"Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was \" + s,\n      90001,\n      400\n    );\n  }\n  setChannelSerial(channelSerial) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeChannel.setChannelSerial()\",\n      \"Updating channel serial; serial = \" + channelSerial + \"; previous = \" + this.properties.channelSerial\n    );\n    if (channelSerial) {\n      this.properties.channelSerial = channelSerial;\n    }\n  }\n  async status() {\n    return this.client.rest.channelMixin.status(this);\n  }\n};\nfunction omitAgent(channelParams) {\n  const _a2 = channelParams || {}, { agent: _ } = _a2, paramsWithoutAgent = __objRest(_a2, [\"agent\"]);\n  return paramsWithoutAgent;\n}\nvar realtimechannel_default = RealtimeChannel;\n\n// src/common/lib/client/realtimeannotations.ts\nvar RealtimeAnnotations = class {\n  constructor(channel) {\n    this.channel = channel;\n    this.logger = channel.logger;\n    this.subscriptions = new eventemitter_default(this.logger);\n  }\n  async publish(msgOrSerial, annotationValues) {\n    const channelName = this.channel.name;\n    const annotation = constructValidateAnnotation(msgOrSerial, annotationValues);\n    const wireAnnotation = await annotation.encode();\n    this.channel._throwIfUnpublishableState();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimeAnnotations.publish()\",\n      \"channelName = \" + channelName + \", sending annotation with messageSerial = \" + annotation.messageSerial + \", type = \" + annotation.type\n    );\n    const pm = fromValues({\n      action: actions.ANNOTATION,\n      channel: channelName,\n      annotations: [wireAnnotation]\n    });\n    return this.channel.sendMessage(pm);\n  }\n  async delete(msgOrSerial, annotationValues) {\n    annotationValues.action = \"annotation.delete\";\n    return this.publish(msgOrSerial, annotationValues);\n  }\n  async subscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    const channel = this.channel;\n    if (channel.state === \"failed\") {\n      throw ErrorInfo.fromValues(channel.invalidStateError());\n    }\n    this.subscriptions.on(event, listener);\n    if (this.channel.channelOptions.attachOnSubscribe !== false) {\n      await channel.attach();\n    }\n    if ((this.channel.state === \"attached\" && this.channel._mode & flags.ANNOTATION_SUBSCRIBE) === 0) {\n      throw new ErrorInfo(\n        \"You are trying to add an annotation listener, but you haven't requested the annotation_subscribe channel mode in ChannelOptions, so this won't do anything (we only deliver annotations to clients who have explicitly requested them)\",\n        93001,\n        400\n      );\n    }\n  }\n  unsubscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    this.subscriptions.off(event, listener);\n  }\n  _processIncoming(annotations) {\n    for (const annotation of annotations) {\n      this.subscriptions.emit(annotation.type || \"\", annotation);\n    }\n  }\n  async get(msgOrSerial, params) {\n    return restannotations_default.prototype.get.call(this, msgOrSerial, params);\n  }\n};\nvar realtimeannotations_default = RealtimeAnnotations;\n\n// src/common/lib/client/defaultrest.ts\nvar _DefaultRest = class _DefaultRest extends BaseRest {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options) {\n    var _a2, _b;\n    const MsgPack = _DefaultRest._MsgPack;\n    if (!MsgPack) {\n      throw new Error(\"Expected DefaultRest._MsgPack to have been set\");\n    }\n    super(\n      defaults_default.objectifyOptions(options, true, \"Rest\", logger_default.defaultLogger, __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRest.Crypto) != null ? _a2 : void 0,\n        MsgPack: (_b = _DefaultRest._MsgPack) != null ? _b : void 0,\n        Annotations: {\n          Annotation: annotation_default,\n          WireAnnotation,\n          RealtimeAnnotations: realtimeannotations_default,\n          RestAnnotations: restannotations_default\n        }\n      }))\n    );\n  }\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n    }\n    return this._Crypto;\n  }\n  static set Crypto(newValue) {\n    this._Crypto = newValue;\n  }\n};\n_DefaultRest._Crypto = null;\n_DefaultRest.Message = DefaultMessage;\n_DefaultRest.PresenceMessage = DefaultPresenceMessage;\n_DefaultRest.Annotation = DefaultAnnotation;\n_DefaultRest._MsgPack = null;\n// Used by tests\n_DefaultRest._Http = Http;\nvar DefaultRest = _DefaultRest;\n\n// src/common/lib/transport/messagequeue.ts\nvar MessageQueue = class extends eventemitter_default {\n  constructor(logger) {\n    super(logger);\n    this.messages = [];\n  }\n  count() {\n    return this.messages.length;\n  }\n  push(message) {\n    this.messages.push(message);\n  }\n  shift() {\n    return this.messages.shift();\n  }\n  last() {\n    return this.messages[this.messages.length - 1];\n  }\n  copyAll() {\n    return this.messages.slice();\n  }\n  append(messages) {\n    this.messages.push.apply(this.messages, messages);\n  }\n  prepend(messages) {\n    this.messages.unshift.apply(this.messages, messages);\n  }\n  completeMessages(serial, count, err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"MessageQueue.completeMessages()\",\n      \"serial = \" + serial + \"; count = \" + count\n    );\n    err = err || null;\n    const messages = this.messages;\n    if (messages.length === 0) {\n      throw new Error(\"MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue\");\n    }\n    const first = messages[0];\n    if (first) {\n      const startSerial = first.message.msgSerial;\n      const endSerial = serial + count;\n      if (endSerial > startSerial) {\n        const completeMessages = messages.splice(0, endSerial - startSerial);\n        for (const message of completeMessages) {\n          message.callback(err);\n        }\n      }\n      if (messages.length == 0)\n        this.emit(\"idle\");\n    }\n  }\n  completeAllMessages(err) {\n    this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);\n  }\n  resetSendAttempted() {\n    for (let msg of this.messages) {\n      msg.sendAttempted = false;\n    }\n  }\n  clear() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"MessageQueue.clear()\",\n      \"clearing \" + this.messages.length + \" messages\"\n    );\n    this.messages = [];\n    this.emit(\"idle\");\n  }\n};\nvar messagequeue_default = MessageQueue;\n\n// src/common/lib/transport/protocol.ts\nvar PendingMessage = class {\n  constructor(message, callback) {\n    this.message = message;\n    this.callback = callback;\n    this.merged = false;\n    const action = message.action;\n    this.sendAttempted = false;\n    this.ackRequired = action == actions.MESSAGE || action == actions.PRESENCE || action == actions.ANNOTATION;\n  }\n};\nvar Protocol = class extends eventemitter_default {\n  constructor(transport) {\n    super(transport.logger);\n    this.transport = transport;\n    this.messageQueue = new messagequeue_default(this.logger);\n    transport.on(\"ack\", (serial, count) => {\n      this.onAck(serial, count);\n    });\n    transport.on(\"nack\", (serial, count, err) => {\n      this.onNack(serial, count, err);\n    });\n  }\n  onAck(serial, count) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"Protocol.onAck()\", \"serial = \" + serial + \"; count = \" + count);\n    this.messageQueue.completeMessages(serial, count);\n  }\n  onNack(serial, count, err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_ERROR,\n      \"Protocol.onNack()\",\n      \"serial = \" + serial + \"; count = \" + count + \"; err = \" + inspectError(err)\n    );\n    if (!err) {\n      err = new ErrorInfo(\"Unable to send message; channel not responding\", 50001, 500);\n    }\n    this.messageQueue.completeMessages(serial, count, err);\n  }\n  onceIdle(listener) {\n    const messageQueue = this.messageQueue;\n    if (messageQueue.count() === 0) {\n      listener();\n      return;\n    }\n    messageQueue.once(\"idle\", listener);\n  }\n  send(pendingMessage) {\n    if (pendingMessage.ackRequired) {\n      this.messageQueue.push(pendingMessage);\n    }\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Protocol.send()\",\n        \"sending msg; \" + stringify(\n          pendingMessage.message,\n          this.transport.connectionManager.realtime._RealtimePresence,\n          this.transport.connectionManager.realtime._Annotations\n        )\n      );\n    }\n    pendingMessage.sendAttempted = true;\n    this.transport.send(pendingMessage.message);\n  }\n  getTransport() {\n    return this.transport;\n  }\n  getPendingMessages() {\n    return this.messageQueue.copyAll();\n  }\n  clearPendingMessages() {\n    return this.messageQueue.clear();\n  }\n  finish() {\n    const transport = this.transport;\n    this.onceIdle(function() {\n      transport.disconnect();\n    });\n  }\n};\nvar protocol_default = Protocol;\n\n// src/common/lib/client/connectionstatechange.ts\nvar ConnectionStateChange = class {\n  constructor(previous, current, retryIn, reason) {\n    this.previous = previous;\n    this.current = current;\n    if (retryIn)\n      this.retryIn = retryIn;\n    if (reason)\n      this.reason = reason;\n  }\n};\nvar connectionstatechange_default = ConnectionStateChange;\n\n// src/common/lib/transport/connectionerrors.ts\nvar ConnectionErrorCodes = {\n  DISCONNECTED: 80003,\n  SUSPENDED: 80002,\n  FAILED: 8e4,\n  CLOSING: 80017,\n  CLOSED: 80017,\n  UNKNOWN_CONNECTION_ERR: 50002,\n  UNKNOWN_CHANNEL_ERR: 50001\n};\nvar ConnectionErrors = {\n  disconnected: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.DISCONNECTED,\n    message: \"Connection to server temporarily unavailable\"\n  }),\n  suspended: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.SUSPENDED,\n    message: \"Connection to server unavailable\"\n  }),\n  failed: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.FAILED,\n    message: \"Connection failed or disconnected by server\"\n  }),\n  closing: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.CLOSING,\n    message: \"Connection closing\"\n  }),\n  closed: () => ErrorInfo.fromValues({\n    statusCode: 400,\n    code: ConnectionErrorCodes.CLOSED,\n    message: \"Connection closed\"\n  }),\n  unknownConnectionErr: () => ErrorInfo.fromValues({\n    statusCode: 500,\n    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n    message: \"Internal connection error\"\n  }),\n  unknownChannelErr: () => ErrorInfo.fromValues({\n    statusCode: 500,\n    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n    message: \"Internal channel error\"\n  })\n};\nfunction isRetriable(err) {\n  if (!err.statusCode || !err.code || err.statusCode >= 500) {\n    return true;\n  }\n  return Object.values(ConnectionErrorCodes).includes(err.code);\n}\nvar connectionerrors_default = ConnectionErrors;\n\n// src/common/lib/transport/transport.ts\nvar closeMessage = fromValues({ action: actions.CLOSE });\nvar disconnectMessage = fromValues({ action: actions.DISCONNECT });\nvar Transport = class extends eventemitter_default {\n  constructor(connectionManager, auth, params, forceJsonProtocol) {\n    super(connectionManager.logger);\n    if (forceJsonProtocol) {\n      params.format = void 0;\n      params.heartbeats = true;\n    }\n    this.connectionManager = connectionManager;\n    this.auth = auth;\n    this.params = params;\n    this.timeouts = params.options.timeouts;\n    this.format = params.format;\n    this.isConnected = false;\n    this.isFinished = false;\n    this.isDisposed = false;\n    this.maxIdleInterval = null;\n    this.idleTimer = null;\n    this.lastActivity = null;\n  }\n  connect() {\n  }\n  close() {\n    if (this.isConnected) {\n      this.requestClose();\n    }\n    this.finish(\"closed\", connectionerrors_default.closed());\n  }\n  disconnect(err) {\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish(\"disconnected\", err || connectionerrors_default.disconnected());\n  }\n  fail(err) {\n    if (this.isConnected) {\n      this.requestDisconnect();\n    }\n    this.finish(\"failed\", err || connectionerrors_default.failed());\n  }\n  finish(event, err) {\n    var _a2;\n    if (this.isFinished) {\n      return;\n    }\n    this.isFinished = true;\n    this.isConnected = false;\n    this.maxIdleInterval = null;\n    clearTimeout((_a2 = this.idleTimer) != null ? _a2 : void 0);\n    this.idleTimer = null;\n    this.emit(event, err);\n    this.dispose();\n  }\n  onProtocolMessage(message) {\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"Transport.onProtocolMessage()\",\n        \"received on \" + this.shortName + \": \" + stringify(\n          message,\n          this.connectionManager.realtime._RealtimePresence,\n          this.connectionManager.realtime._Annotations\n        ) + \"; connectionId = \" + this.connectionManager.connectionId\n      );\n    }\n    this.onActivity();\n    switch (message.action) {\n      case actions.HEARTBEAT:\n        logger_default.logActionNoStrip(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"Transport.onProtocolMessage()\",\n          this.shortName + \" heartbeat; connectionId = \" + this.connectionManager.connectionId\n        );\n        this.emit(\"heartbeat\", message.id);\n        break;\n      case actions.CONNECTED:\n        this.onConnect(message);\n        this.emit(\"connected\", message.error, message.connectionId, message.connectionDetails, message);\n        break;\n      case actions.CLOSED:\n        this.onClose(message);\n        break;\n      case actions.DISCONNECTED:\n        this.onDisconnect(message);\n        break;\n      case actions.ACK:\n        this.emit(\"ack\", message.msgSerial, message.count);\n        break;\n      case actions.NACK:\n        this.emit(\"nack\", message.msgSerial, message.count, message.error);\n        break;\n      case actions.SYNC:\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      case actions.ACTIVATE:\n        break;\n      case actions.AUTH:\n        whenPromiseSettles(this.auth.authorize(), (err) => {\n          if (err) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_ERROR,\n              \"Transport.onProtocolMessage()\",\n              \"Ably requested re-authentication, but unable to obtain a new token: \" + inspectError(err)\n            );\n          }\n        });\n        break;\n      case actions.ERROR:\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"Transport.onProtocolMessage()\",\n          \"received error action; connectionId = \" + this.connectionManager.connectionId + \"; err = \" + Platform.Config.inspect(message.error) + (message.channel ? \", channel: \" + message.channel : \"\")\n        );\n        if (message.channel === void 0) {\n          this.onFatalError(message);\n          break;\n        }\n        this.connectionManager.onChannelMessage(message, this);\n        break;\n      default:\n        this.connectionManager.onChannelMessage(message, this);\n    }\n  }\n  onConnect(message) {\n    this.isConnected = true;\n    if (!message.connectionDetails) {\n      throw new Error(\"Transport.onConnect(): Connect message recieved without connectionDetails\");\n    }\n    const maxPromisedIdle = message.connectionDetails.maxIdleInterval;\n    if (maxPromisedIdle) {\n      this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;\n      this.onActivity();\n    }\n  }\n  onDisconnect(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onDisconnect()\", \"err = \" + inspectError(err));\n    this.finish(\"disconnected\", err);\n  }\n  onFatalError(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onFatalError()\", \"err = \" + inspectError(err));\n    this.finish(\"failed\", err);\n  }\n  onClose(message) {\n    const err = message && message.error;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.onClose()\", \"err = \" + inspectError(err));\n    this.finish(\"closed\", err);\n  }\n  requestClose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.requestClose()\", \"\");\n    this.send(closeMessage);\n  }\n  requestDisconnect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.requestDisconnect()\", \"\");\n    this.send(disconnectMessage);\n  }\n  ping(id) {\n    const msg = { action: actions.HEARTBEAT };\n    if (id)\n      msg.id = id;\n    this.send(fromValues(msg));\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Transport.dispose()\", \"\");\n    this.isDisposed = true;\n    this.off();\n  }\n  onActivity() {\n    if (!this.maxIdleInterval) {\n      return;\n    }\n    this.lastActivity = this.connectionManager.lastActivity = Date.now();\n    this.setIdleTimer(this.maxIdleInterval + 100);\n  }\n  setIdleTimer(timeout) {\n    if (!this.idleTimer) {\n      this.idleTimer = setTimeout(() => {\n        this.onIdleTimerExpire();\n      }, timeout);\n    }\n  }\n  onIdleTimerExpire() {\n    if (!this.lastActivity || !this.maxIdleInterval) {\n      throw new Error(\"Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set\");\n    }\n    this.idleTimer = null;\n    const sinceLast = Date.now() - this.lastActivity;\n    const timeRemaining = this.maxIdleInterval - sinceLast;\n    if (timeRemaining <= 0) {\n      const msg = \"No activity seen from realtime in \" + sinceLast + \"ms; assuming connection has dropped\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"Transport.onIdleTimerExpire()\", msg);\n      this.disconnect(new ErrorInfo(msg, 80003, 408));\n    } else {\n      this.setIdleTimer(timeRemaining + 100);\n    }\n  }\n  static tryConnect(transportCtor, connectionManager, auth, transportParams, callback) {\n    const transport = new transportCtor(connectionManager, auth, transportParams);\n    let transportAttemptTimer;\n    const errorCb = function(err) {\n      clearTimeout(transportAttemptTimer);\n      callback({ event: this.event, error: err });\n    };\n    const realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;\n    transportAttemptTimer = setTimeout(() => {\n      transport.off([\"preconnect\", \"disconnected\", \"failed\"]);\n      transport.dispose();\n      errorCb.call(\n        { event: \"disconnected\" },\n        new ErrorInfo(\"Timeout waiting for transport to indicate itself viable\", 5e4, 500)\n      );\n    }, realtimeRequestTimeout);\n    transport.on([\"failed\", \"disconnected\"], errorCb);\n    transport.on(\"preconnect\", function() {\n      logger_default.logAction(\n        connectionManager.logger,\n        logger_default.LOG_MINOR,\n        \"Transport.tryConnect()\",\n        \"viable transport \" + transport\n      );\n      clearTimeout(transportAttemptTimer);\n      transport.off([\"failed\", \"disconnected\"], errorCb);\n      callback(null, transport);\n    });\n    transport.connect();\n    return transport;\n  }\n  static isAvailable() {\n    throw new ErrorInfo(\"isAvailable not implemented for transport\", 5e4, 500);\n  }\n};\nvar transport_default = Transport;\n\n// src/common/constants/TransportName.ts\nvar TransportNames;\n((TransportNames2) => {\n  TransportNames2.WebSocket = \"web_socket\";\n  TransportNames2.Comet = \"comet\";\n  TransportNames2.XhrPolling = \"xhr_polling\";\n})(TransportNames || (TransportNames = {}));\n\n// src/common/lib/transport/connectionmanager.ts\nvar globalObject2 = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : self;\nvar haveWebStorage = () => {\n  var _a2;\n  return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.localSupported);\n};\nvar haveSessionStorage = () => {\n  var _a2;\n  return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.sessionSupported);\n};\nvar noop2 = function() {\n};\nvar transportPreferenceName = \"ably-transport-preference\";\nfunction bundleWith(dest, src, maxSize) {\n  let action;\n  if (dest.channel !== src.channel) {\n    return false;\n  }\n  if ((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {\n    return false;\n  }\n  if (action !== src.action) {\n    return false;\n  }\n  const kind = action === actions.PRESENCE ? \"presence\" : \"messages\", proposed = dest[kind].concat(src[kind]), size = getMessagesSize(proposed);\n  if (size > maxSize) {\n    return false;\n  }\n  if (!allSame(proposed, \"clientId\")) {\n    return false;\n  }\n  if (!proposed.every(function(msg) {\n    return !msg.id;\n  })) {\n    return false;\n  }\n  dest[kind] = proposed;\n  return true;\n}\nfunction decodeRecoveryKey(recoveryKey) {\n  try {\n    return JSON.parse(recoveryKey);\n  } catch (e) {\n    return null;\n  }\n}\nvar TransportParams = class {\n  constructor(options, host, mode, connectionKey) {\n    this.options = options;\n    this.host = host;\n    this.mode = mode;\n    this.connectionKey = connectionKey;\n    this.format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n  }\n  getConnectParams(authParams) {\n    const params = authParams ? copy(authParams) : {};\n    const options = this.options;\n    switch (this.mode) {\n      case \"resume\":\n        params.resume = this.connectionKey;\n        break;\n      case \"recover\": {\n        const recoveryContext = decodeRecoveryKey(options.recover);\n        if (recoveryContext) {\n          params.recover = recoveryContext.connectionKey;\n        }\n        break;\n      }\n      default:\n    }\n    if (options.clientId !== void 0) {\n      params.clientId = options.clientId;\n    }\n    if (options.echoMessages === false) {\n      params.echo = \"false\";\n    }\n    if (this.format !== void 0) {\n      params.format = this.format;\n    }\n    if (this.stream !== void 0) {\n      params.stream = this.stream;\n    }\n    if (this.heartbeats !== void 0) {\n      params.heartbeats = this.heartbeats;\n    }\n    params.v = defaults_default.protocolVersion;\n    params.agent = getAgentString(this.options);\n    if (options.transportParams !== void 0) {\n      mixin(params, options.transportParams);\n    }\n    return params;\n  }\n  toString() {\n    let result = \"[mode=\" + this.mode;\n    if (this.host) {\n      result += \",host=\" + this.host;\n    }\n    if (this.connectionKey) {\n      result += \",connectionKey=\" + this.connectionKey;\n    }\n    if (this.format) {\n      result += \",format=\" + this.format;\n    }\n    result += \"]\";\n    return result;\n  }\n};\nvar ConnectionManager = class _ConnectionManager extends eventemitter_default {\n  constructor(realtime, options) {\n    super(realtime.logger);\n    this.supportedTransports = {};\n    this.disconnectedRetryCount = 0;\n    this.pendingChannelMessagesState = { isProcessing: false, queue: [] };\n    this.realtime = realtime;\n    this.initTransports();\n    this.options = options;\n    const timeouts = options.timeouts;\n    const connectingTimeout = timeouts.webSocketConnectTimeout + timeouts.realtimeRequestTimeout;\n    this.states = {\n      initialized: {\n        state: \"initialized\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        failState: \"disconnected\"\n      },\n      connecting: {\n        state: \"connecting\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: connectingTimeout,\n        failState: \"disconnected\"\n      },\n      connected: {\n        state: \"connected\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: true,\n        failState: \"disconnected\"\n      },\n      disconnected: {\n        state: \"disconnected\",\n        terminal: false,\n        queueEvents: true,\n        sendEvents: false,\n        retryDelay: timeouts.disconnectedRetryTimeout,\n        failState: \"disconnected\"\n      },\n      suspended: {\n        state: \"suspended\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.suspendedRetryTimeout,\n        failState: \"suspended\"\n      },\n      closing: {\n        state: \"closing\",\n        terminal: false,\n        queueEvents: false,\n        sendEvents: false,\n        retryDelay: timeouts.realtimeRequestTimeout,\n        failState: \"closed\"\n      },\n      closed: { state: \"closed\", terminal: true, queueEvents: false, sendEvents: false, failState: \"closed\" },\n      failed: { state: \"failed\", terminal: true, queueEvents: false, sendEvents: false, failState: \"failed\" }\n    };\n    this.state = this.states.initialized;\n    this.errorReason = null;\n    this.queuedMessages = new messagequeue_default(this.logger);\n    this.msgSerial = 0;\n    this.connectionDetails = void 0;\n    this.connectionId = void 0;\n    this.connectionKey = void 0;\n    this.connectionStateTtl = timeouts.connectionStateTtl;\n    this.maxIdleInterval = null;\n    this.transports = intersect(options.transports || defaults_default.defaultTransports, this.supportedTransports);\n    this.transportPreference = null;\n    if (this.transports.includes(TransportNames.WebSocket)) {\n      this.webSocketTransportAvailable = true;\n    }\n    if (this.transports.includes(TransportNames.XhrPolling)) {\n      this.baseTransport = TransportNames.XhrPolling;\n    } else if (this.transports.includes(TransportNames.Comet)) {\n      this.baseTransport = TransportNames.Comet;\n    }\n    this.httpHosts = defaults_default.getHosts(options);\n    this.wsHosts = defaults_default.getHosts(options, true);\n    this.activeProtocol = null;\n    this.host = null;\n    this.lastAutoReconnectAttempt = null;\n    this.lastActivity = null;\n    this.forceFallbackHost = false;\n    this.connectCounter = 0;\n    this.wsCheckResult = null;\n    this.webSocketSlowTimer = null;\n    this.webSocketGiveUpTimer = null;\n    this.abandonedWebSocket = false;\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.ConnectionManager()\", \"started\");\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"requested transports = [\" + (options.transports || defaults_default.defaultTransports) + \"]\"\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"available transports = [\" + this.transports + \"]\"\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"Realtime.ConnectionManager()\",\n      \"http hosts = [\" + this.httpHosts + \"]\"\n    );\n    if (!this.transports.length) {\n      const msg = \"no requested transports available\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"realtime.ConnectionManager()\", msg);\n      throw new Error(msg);\n    }\n    const addEventListener = Platform.Config.addEventListener;\n    if (addEventListener) {\n      if (haveSessionStorage() && typeof options.recover === \"function\") {\n        addEventListener(\"beforeunload\", this.persistConnection.bind(this));\n      }\n      if (options.closeOnUnload === true) {\n        addEventListener(\"beforeunload\", () => {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"Realtime.ConnectionManager()\",\n            \"beforeunload event has triggered the connection to close as closeOnUnload is true\"\n          );\n          this.requestState({ state: \"closing\" });\n        });\n      }\n      addEventListener(\"online\", () => {\n        var _a2;\n        if (this.state == this.states.disconnected || this.state == this.states.suspended) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager caught browser \\u2018online\\u2019 event\",\n            \"reattempting connection\"\n          );\n          this.requestState({ state: \"connecting\" });\n        } else if (this.state == this.states.connecting) {\n          (_a2 = this.pendingTransport) == null ? void 0 : _a2.off();\n          this.disconnectAllTransports();\n          this.startConnect();\n        }\n      });\n      addEventListener(\"offline\", () => {\n        if (this.state == this.states.connected) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager caught browser \\u2018offline\\u2019 event\",\n            \"disconnecting active transport\"\n          );\n          this.disconnectAllTransports();\n        }\n      });\n    }\n  }\n  /*********************\n   * transport management\n   *********************/\n  // Used by tests\n  static supportedTransports(additionalImplementations) {\n    const storage = { supportedTransports: {} };\n    this.initTransports(additionalImplementations, storage);\n    return storage.supportedTransports;\n  }\n  static initTransports(additionalImplementations, storage) {\n    const implementations = __spreadValues(__spreadValues({}, Platform.Transports.bundledImplementations), additionalImplementations);\n    [TransportNames.WebSocket, ...Platform.Transports.order].forEach((transportName) => {\n      const transport = implementations[transportName];\n      if (transport && transport.isAvailable()) {\n        storage.supportedTransports[transportName] = transport;\n      }\n    });\n  }\n  initTransports() {\n    _ConnectionManager.initTransports(this.realtime._additionalTransportImplementations, this);\n  }\n  createTransportParams(host, mode) {\n    return new TransportParams(this.options, host, mode, this.connectionKey);\n  }\n  getTransportParams(callback) {\n    const decideMode = (modeCb) => {\n      if (this.connectionKey) {\n        modeCb(\"resume\");\n        return;\n      }\n      if (typeof this.options.recover === \"string\") {\n        modeCb(\"recover\");\n        return;\n      }\n      const recoverFn = this.options.recover, lastSessionData = this.getSessionRecoverData(), sessionRecoveryName = this.sessionRecoveryName();\n      if (lastSessionData && typeof recoverFn === \"function\") {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Calling clientOptions-provided recover function with last session data (recovery scope: \" + sessionRecoveryName + \")\"\n        );\n        recoverFn(lastSessionData, (shouldRecover) => {\n          if (shouldRecover) {\n            this.options.recover = lastSessionData.recoveryKey;\n            modeCb(\"recover\");\n          } else {\n            modeCb(\"clean\");\n          }\n        });\n        return;\n      }\n      modeCb(\"clean\");\n    };\n    decideMode((mode) => {\n      const transportParams = this.createTransportParams(null, mode);\n      if (mode === \"recover\") {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Transport recovery mode = recover; recoveryKey = \" + this.options.recover\n        );\n        const recoveryContext = decodeRecoveryKey(this.options.recover);\n        if (recoveryContext) {\n          this.msgSerial = recoveryContext.msgSerial;\n        }\n      } else {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager.getTransportParams()\",\n          \"Transport params = \" + transportParams.toString()\n        );\n      }\n      callback(transportParams);\n    });\n  }\n  /**\n   * Attempt to connect using a given transport\n   * @param transportParams\n   * @param candidate, the transport to try\n   * @param callback\n   */\n  tryATransport(transportParams, candidate, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.tryATransport()\", \"trying \" + candidate);\n    this.proposedTransport = transport_default.tryConnect(\n      this.supportedTransports[candidate],\n      this,\n      this.realtime.auth,\n      transportParams,\n      (wrappedErr, transport) => {\n        const state = this.state;\n        if (state == this.states.closing || state == this.states.closed || state == this.states.failed) {\n          if (transport) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MINOR,\n              \"ConnectionManager.tryATransport()\",\n              \"connection \" + state.state + \" while we were attempting the transport; closing \" + transport\n            );\n            transport.close();\n          }\n          callback(true);\n          return;\n        }\n        if (wrappedErr) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager.tryATransport()\",\n            \"transport \" + candidate + \" \" + wrappedErr.event + \", err: \" + wrappedErr.error.toString()\n          );\n          if (auth_default.isTokenErr(wrappedErr.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason))) {\n            this.errorReason = wrappedErr.error;\n            whenPromiseSettles(this.realtime.auth._forceNewToken(null, null), (err) => {\n              if (err) {\n                this.actOnErrorFromAuthorize(err);\n                return;\n              }\n              this.tryATransport(transportParams, candidate, callback);\n            });\n          } else if (wrappedErr.event === \"failed\") {\n            this.notifyState({ state: \"failed\", error: wrappedErr.error });\n            callback(true);\n          } else if (wrappedErr.event === \"disconnected\") {\n            if (!isRetriable(wrappedErr.error)) {\n              this.notifyState({ state: this.states.connecting.failState, error: wrappedErr.error });\n              callback(true);\n            } else {\n              callback(false);\n            }\n          }\n          return;\n        }\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.tryATransport()\",\n          \"viable transport \" + candidate + \"; setting pending\"\n        );\n        this.setTransportPending(transport, transportParams);\n        callback(null, transport);\n      }\n    );\n  }\n  /**\n   * Called when a transport is indicated to be viable, and the ConnectionManager\n   * expects to activate this transport as soon as it is connected.\n   * @param transport\n   * @param transportParams\n   */\n  setTransportPending(transport, transportParams) {\n    const mode = transportParams.mode;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.setTransportPending()\",\n      \"transport = \" + transport + \"; mode = \" + mode\n    );\n    this.pendingTransport = transport;\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    transport.once(\"connected\", (error, connectionId, connectionDetails) => {\n      this.activateTransport(error, transport, connectionId, connectionDetails);\n      if (mode === \"recover\" && this.options.recover) {\n        delete this.options.recover;\n        this.unpersistConnection();\n      }\n    });\n    const self2 = this;\n    transport.on([\"disconnected\", \"closed\", \"failed\"], function(error) {\n      self2.deactivateTransport(transport, this.event, error);\n    });\n    this.emit(\"transport.pending\", transport);\n  }\n  /**\n   * Called when a transport is connected, and the connectionmanager decides that\n   * it will now be the active transport. Returns whether or not it activated\n   * the transport (if the connection is closing/closed it will choose not to).\n   * @param transport the transport instance\n   * @param connectionId the id of the new active connection\n   * @param connectionDetails the details of the new active connection\n   */\n  activateTransport(error, transport, connectionId, connectionDetails) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.activateTransport()\",\n      \"transport = \" + transport\n    );\n    if (error) {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", \"error = \" + error);\n    }\n    if (connectionId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.activateTransport()\",\n        \"connectionId =  \" + connectionId\n      );\n    }\n    if (connectionDetails) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.activateTransport()\",\n        \"connectionDetails =  \" + JSON.stringify(connectionDetails)\n      );\n    }\n    this.persistTransportPreference(transport);\n    const existingState = this.state, connectedState = this.states.connected.state;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.activateTransport()\",\n      \"current state = \" + existingState.state\n    );\n    if (existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.activateTransport()\",\n        \"Disconnecting transport and abandoning\"\n      );\n      transport.disconnect();\n      return false;\n    }\n    delete this.pendingTransport;\n    if (!transport.isConnected) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.activateTransport()\",\n        \"Declining to activate transport \" + transport + \" since it appears to no longer be connected\"\n      );\n      return false;\n    }\n    const existingActiveProtocol = this.activeProtocol;\n    this.activeProtocol = new protocol_default(transport);\n    this.host = transport.params.host;\n    const connectionKey = connectionDetails.connectionKey;\n    if (connectionKey && this.connectionKey != connectionKey) {\n      this.setConnection(connectionId, connectionDetails, !!error);\n    }\n    this.onConnectionDetailsUpdate(connectionDetails, transport);\n    Platform.Config.nextTick(() => {\n      transport.on(\n        \"connected\",\n        (connectedErr, _connectionId, connectionDetails2) => {\n          this.onConnectionDetailsUpdate(connectionDetails2, transport);\n          this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, connectedErr));\n        }\n      );\n    });\n    if (existingState.state === this.states.connected.state) {\n      if (error) {\n        this.errorReason = this.realtime.connection.errorReason = error;\n        this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, error));\n      }\n    } else {\n      this.notifyState({ state: \"connected\", error });\n      this.errorReason = this.realtime.connection.errorReason = error || null;\n    }\n    this.emit(\"transport.active\", transport);\n    if (existingActiveProtocol) {\n      if (existingActiveProtocol.messageQueue.count() > 0) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"ConnectionManager.activateTransport()\",\n          \"Previous active protocol (for transport \" + existingActiveProtocol.transport.shortName + \", new one is \" + transport.shortName + \") finishing with \" + existingActiveProtocol.messageQueue.count() + \" messages still pending\"\n        );\n      }\n      if (existingActiveProtocol.transport === transport) {\n        const msg = \"Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = \" + transport.shortName + \"; stack = \" + new Error().stack;\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", msg);\n      } else {\n        existingActiveProtocol.finish();\n      }\n    }\n    return true;\n  }\n  /**\n   * Called when a transport is no longer the active transport. This can occur\n   * in any transport connection state.\n   * @param transport\n   */\n  deactivateTransport(transport, state, error) {\n    const currentProtocol = this.activeProtocol, wasActive = currentProtocol && currentProtocol.getTransport() === transport, wasPending = transport === this.pendingTransport, noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.deactivateTransport()\",\n      \"transport = \" + transport\n    );\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.deactivateTransport()\",\n      \"state = \" + state + (wasActive ? \"; was active\" : wasPending ? \"; was pending\" : \"\") + (noTransportsScheduledForActivation ? \"\" : \"; another transport is scheduled for activation\")\n    );\n    if (error && error.message)\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.deactivateTransport()\",\n        \"reason =  \" + error.message\n      );\n    if (wasActive) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.deactivateTransport()\",\n        \"Getting, clearing, and requeuing \" + this.activeProtocol.messageQueue.count() + \" pending messages\"\n      );\n      this.queuePendingMessages(currentProtocol.getPendingMessages());\n      currentProtocol.clearPendingMessages();\n      this.activeProtocol = this.host = null;\n    }\n    this.emit(\"transport.inactive\", transport);\n    if (wasActive && noTransportsScheduledForActivation || wasActive && state === \"failed\" || state === \"closed\" || currentProtocol === null && wasPending) {\n      if (state === \"disconnected\" && error && error.statusCode > 500 && this.httpHosts.length > 1) {\n        this.unpersistTransportPreference();\n        this.forceFallbackHost = true;\n        this.notifyState({ state, error, retryImmediately: true });\n        return;\n      }\n      const newConnectionState = state === \"failed\" && auth_default.isTokenErr(error) ? \"disconnected\" : state;\n      this.notifyState({ state: newConnectionState, error });\n      return;\n    }\n  }\n  /* Helper that returns true if there are no transports which are pending,\n   * have been connected, and are just waiting for onceNoPending to fire before\n   * being activated */\n  noTransportsScheduledForActivation() {\n    return !this.pendingTransport || !this.pendingTransport.isConnected;\n  }\n  setConnection(connectionId, connectionDetails, hasConnectionError) {\n    const prevConnId = this.connectionId, connIdChanged = prevConnId && prevConnId !== connectionId, recoverFailure = !prevConnId && hasConnectionError;\n    if (connIdChanged || recoverFailure) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.setConnection()\", \"Resetting msgSerial\");\n      this.msgSerial = 0;\n      this.queuedMessages.resetSendAttempted();\n    }\n    if (this.connectionId !== connectionId) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.setConnection()\",\n        \"New connectionId; reattaching any attached channels\"\n      );\n    }\n    this.realtime.connection.id = this.connectionId = connectionId;\n    this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;\n  }\n  clearConnection() {\n    this.realtime.connection.id = this.connectionId = void 0;\n    this.realtime.connection.key = this.connectionKey = void 0;\n    this.msgSerial = 0;\n    this.unpersistConnection();\n  }\n  createRecoveryKey() {\n    if (!this.connectionKey) {\n      return null;\n    }\n    return JSON.stringify({\n      connectionKey: this.connectionKey,\n      msgSerial: this.msgSerial,\n      channelSerials: this.realtime.channels.channelSerials()\n    });\n  }\n  checkConnectionStateFreshness() {\n    if (!this.lastActivity || !this.connectionId) {\n      return;\n    }\n    const sinceLast = Date.now() - this.lastActivity;\n    if (sinceLast > this.connectionStateTtl + this.maxIdleInterval) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.checkConnectionStateFreshness()\",\n        \"Last known activity from realtime was \" + sinceLast + \"ms ago; discarding connection state\"\n      );\n      this.clearConnection();\n      this.states.connecting.failState = \"suspended\";\n    }\n  }\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  persistConnection() {\n    if (haveSessionStorage()) {\n      const recoveryKey = this.createRecoveryKey();\n      if (recoveryKey) {\n        this.setSessionRecoverData({\n          recoveryKey,\n          disconnectedAt: Date.now(),\n          location: globalObject2.location,\n          clientId: this.realtime.auth.clientId\n        });\n      }\n    }\n  }\n  /**\n   * Called when the connectionmanager wants to persist transport\n   * state for later recovery. Only applicable in the browser context.\n   */\n  unpersistConnection() {\n    this.clearSessionRecoverData();\n  }\n  /*********************\n   * state management\n   *********************/\n  getError() {\n    if (this.errorReason) {\n      const newError = PartialErrorInfo.fromValues(this.errorReason);\n      newError.cause = this.errorReason;\n      return newError;\n    }\n    return this.getStateError();\n  }\n  getStateError() {\n    var _a2, _b;\n    return (_b = (_a2 = connectionerrors_default)[this.state.state]) == null ? void 0 : _b.call(_a2);\n  }\n  activeState() {\n    return this.state.queueEvents || this.state.sendEvents;\n  }\n  enactStateChange(stateChange) {\n    const action = \"Connection state\";\n    const message = stateChange.current + (stateChange.reason ? \"; reason: \" + stateChange.reason : \"\");\n    if (stateChange.current === \"failed\") {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, action, message);\n    } else {\n      logger_default.logAction(this.logger, logger_default.LOG_MAJOR, action, message);\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.enactStateChange\",\n      \"setting new state: \" + stateChange.current + \"; reason = \" + (stateChange.reason && stateChange.reason.message)\n    );\n    const newState = this.state = this.states[stateChange.current];\n    if (stateChange.reason) {\n      this.errorReason = stateChange.reason;\n      this.realtime.connection.errorReason = stateChange.reason;\n    }\n    if (newState.terminal || newState.state === \"suspended\") {\n      this.clearConnection();\n    }\n    this.emit(\"connectionstate\", stateChange);\n  }\n  /****************************************\n   * ConnectionManager connection lifecycle\n   ****************************************/\n  startTransitionTimer(transitionState) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.startTransitionTimer()\",\n      \"transitionState: \" + transitionState.state\n    );\n    if (this.transitionTimer) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.startTransitionTimer()\",\n        \"clearing already-running timer\"\n      );\n      clearTimeout(this.transitionTimer);\n    }\n    this.transitionTimer = setTimeout(() => {\n      if (this.transitionTimer) {\n        this.transitionTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager \" + transitionState.state + \" timer expired\",\n          \"requesting new state: \" + transitionState.failState\n        );\n        this.notifyState({ state: transitionState.failState });\n      }\n    }, transitionState.retryDelay);\n  }\n  cancelTransitionTimer() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.cancelTransitionTimer()\", \"\");\n    if (this.transitionTimer) {\n      clearTimeout(this.transitionTimer);\n      this.transitionTimer = null;\n    }\n  }\n  startSuspendTimer() {\n    if (this.suspendTimer)\n      return;\n    this.suspendTimer = setTimeout(() => {\n      if (this.suspendTimer) {\n        this.suspendTimer = null;\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager suspend timer expired\",\n          \"requesting new state: suspended\"\n        );\n        this.states.connecting.failState = \"suspended\";\n        this.notifyState({ state: \"suspended\" });\n      }\n    }, this.connectionStateTtl);\n  }\n  checkSuspendTimer(state) {\n    if (state !== \"disconnected\" && state !== \"suspended\" && state !== \"connecting\")\n      this.cancelSuspendTimer();\n  }\n  cancelSuspendTimer() {\n    this.states.connecting.failState = \"disconnected\";\n    if (this.suspendTimer) {\n      clearTimeout(this.suspendTimer);\n      this.suspendTimer = null;\n    }\n  }\n  startRetryTimer(interval) {\n    this.retryTimer = setTimeout(() => {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager retry timer expired\", \"retrying\");\n      this.retryTimer = null;\n      this.requestState({ state: \"connecting\" });\n    }, interval);\n  }\n  cancelRetryTimer() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n      this.retryTimer = null;\n    }\n  }\n  startWebSocketSlowTimer() {\n    this.webSocketSlowTimer = setTimeout(() => {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager WebSocket slow timer\",\n        \"checking connectivity\"\n      );\n      this.checkWsConnectivity().then(() => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager WebSocket slow timer\",\n          \"ws connectivity check succeeded\"\n        );\n        this.wsCheckResult = true;\n      }).catch(() => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MAJOR,\n          \"ConnectionManager WebSocket slow timer\",\n          \"ws connectivity check failed\"\n        );\n        this.wsCheckResult = false;\n      });\n      if (this.realtime.http.checkConnectivity) {\n        whenPromiseSettles(this.realtime.http.checkConnectivity(), (err, connectivity) => {\n          if (err || !connectivity) {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MAJOR,\n              \"ConnectionManager WebSocket slow timer\",\n              \"http connectivity check failed\"\n            );\n            this.cancelWebSocketGiveUpTimer();\n            this.notifyState({\n              state: \"disconnected\",\n              error: new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404)\n            });\n          } else {\n            logger_default.logAction(\n              this.logger,\n              logger_default.LOG_MINOR,\n              \"ConnectionManager WebSocket slow timer\",\n              \"http connectivity check succeeded\"\n            );\n          }\n        });\n      }\n    }, this.options.timeouts.webSocketSlowTimeout);\n  }\n  cancelWebSocketSlowTimer() {\n    if (this.webSocketSlowTimer) {\n      clearTimeout(this.webSocketSlowTimer);\n      this.webSocketSlowTimer = null;\n    }\n  }\n  startWebSocketGiveUpTimer(transportParams) {\n    this.webSocketGiveUpTimer = setTimeout(() => {\n      var _a2, _b;\n      if (!this.wsCheckResult) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MINOR,\n          \"ConnectionManager WebSocket give up timer\",\n          \"websocket connection took more than 10s; \" + (this.baseTransport ? \"trying base transport\" : \"\")\n        );\n        if (this.baseTransport) {\n          this.abandonedWebSocket = true;\n          (_a2 = this.proposedTransport) == null ? void 0 : _a2.dispose();\n          (_b = this.pendingTransport) == null ? void 0 : _b.dispose();\n          this.connectBase(transportParams, ++this.connectCounter);\n        } else {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MAJOR,\n            \"ConnectionManager WebSocket give up timer\",\n            \"websocket connectivity appears to be unavailable but no other transports to try\"\n          );\n        }\n      }\n    }, this.options.timeouts.webSocketConnectTimeout);\n  }\n  cancelWebSocketGiveUpTimer() {\n    if (this.webSocketGiveUpTimer) {\n      clearTimeout(this.webSocketGiveUpTimer);\n      this.webSocketGiveUpTimer = null;\n    }\n  }\n  notifyState(indicated) {\n    var _a2, _b;\n    const state = indicated.state;\n    const retryImmediately = state === \"disconnected\" && (this.state === this.states.connected || indicated.retryImmediately || this.state === this.states.connecting && indicated.error && auth_default.isTokenErr(indicated.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason)));\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.notifyState()\",\n      \"new state: \" + state + (retryImmediately ? \"; will retry connection immediately\" : \"\")\n    );\n    if (state == this.state.state)\n      return;\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.checkSuspendTimer(indicated.state);\n    if (state === \"suspended\" || state === \"connected\") {\n      this.disconnectedRetryCount = 0;\n    }\n    if (this.state.terminal)\n      return;\n    const newState = this.states[indicated.state];\n    let retryDelay = newState.retryDelay;\n    if (newState.state === \"disconnected\") {\n      this.disconnectedRetryCount++;\n      retryDelay = getRetryTime(newState.retryDelay, this.disconnectedRetryCount);\n    }\n    const change = new connectionstatechange_default(\n      this.state.state,\n      newState.state,\n      retryDelay,\n      indicated.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))\n    );\n    if (retryImmediately) {\n      const autoReconnect = () => {\n        if (this.state === this.states.disconnected) {\n          this.lastAutoReconnectAttempt = Date.now();\n          this.requestState({ state: \"connecting\" });\n        }\n      };\n      const sinceLast = this.lastAutoReconnectAttempt && Date.now() - this.lastAutoReconnectAttempt + 1;\n      if (sinceLast && sinceLast < 1e3) {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.notifyState()\",\n          \"Last reconnect attempt was only \" + sinceLast + \"ms ago, waiting another \" + (1e3 - sinceLast) + \"ms before trying again\"\n        );\n        setTimeout(autoReconnect, 1e3 - sinceLast);\n      } else {\n        Platform.Config.nextTick(autoReconnect);\n      }\n    } else if (state === \"disconnected\" || state === \"suspended\") {\n      this.startRetryTimer(retryDelay);\n    }\n    if (state === \"disconnected\" && !retryImmediately || state === \"suspended\" || newState.terminal) {\n      Platform.Config.nextTick(() => {\n        this.disconnectAllTransports();\n      });\n    }\n    if (state == \"connected\" && !this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.notifyState()\",\n        \"Broken invariant: attempted to go into connected state, but there is no active protocol\"\n      );\n    }\n    this.enactStateChange(change);\n    if (this.state.sendEvents) {\n      this.sendQueuedMessages();\n    } else if (!this.state.queueEvents) {\n      this.realtime.channels.propogateConnectionInterruption(state, change.reason);\n      this.failQueuedMessages(change.reason);\n    }\n  }\n  requestState(request) {\n    var _a2, _b;\n    const state = request.state;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.requestState()\",\n      \"requested state: \" + state + \"; current state: \" + this.state.state\n    );\n    if (state == this.state.state)\n      return;\n    this.cancelWebSocketSlowTimer();\n    this.cancelWebSocketGiveUpTimer();\n    this.cancelTransitionTimer();\n    this.cancelRetryTimer();\n    this.checkSuspendTimer(state);\n    if (state == \"connecting\" && this.state.state == \"connected\")\n      return;\n    if (state == \"closing\" && this.state.state == \"closed\")\n      return;\n    const newState = this.states[state], change = new connectionstatechange_default(\n      this.state.state,\n      newState.state,\n      null,\n      request.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))\n    );\n    this.enactStateChange(change);\n    if (state == \"connecting\") {\n      Platform.Config.nextTick(() => {\n        this.startConnect();\n      });\n    }\n    if (state == \"closing\") {\n      this.closeImpl();\n    }\n  }\n  startConnect() {\n    if (this.state !== this.states.connecting) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.startConnect()\",\n        \"Must be in connecting state to connect, but was \" + this.state.state\n      );\n      return;\n    }\n    const auth = this.realtime.auth;\n    const connectCount = ++this.connectCounter;\n    const connect = () => {\n      this.checkConnectionStateFreshness();\n      this.getTransportParams((transportParams) => {\n        if (transportParams.mode === \"recover\" && transportParams.options.recover) {\n          const recoveryContext = decodeRecoveryKey(transportParams.options.recover);\n          if (recoveryContext) {\n            this.realtime.channels.recoverChannels(recoveryContext.channelSerials);\n          }\n        }\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        this.connectImpl(transportParams, connectCount);\n      });\n    };\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.startConnect()\", \"starting connection\");\n    this.startSuspendTimer();\n    this.startTransitionTimer(this.states.connecting);\n    if (auth.method === \"basic\") {\n      connect();\n    } else {\n      const authCb = (err) => {\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        if (err) {\n          this.actOnErrorFromAuthorize(err);\n        } else {\n          connect();\n        }\n      };\n      if (this.errorReason && auth_default.isTokenErr(this.errorReason)) {\n        whenPromiseSettles(auth._forceNewToken(null, null), authCb);\n      } else {\n        whenPromiseSettles(auth._ensureValidAuthCredentials(false), authCb);\n      }\n    }\n  }\n  /*\n   * there are, at most, two transports available with which a connection may\n   * be attempted: web_socket and/or a base transport (xhr_polling in browsers,\n   * comet in nodejs). web_socket is always preferred, and the base transport is\n   * only used in case web_socket connectivity appears to be unavailable.\n   *\n   * connectImpl begins the transport selection process by checking which transports\n   * are available, and if there is a cached preference. It then defers to the\n   * transport-specific connect methods: connectWs and connectBase.\n   *\n   * It is also responsible for invalidating the cache in the case that a base\n   * transport preference is stored but web socket connectivity is now available.\n   *\n   * handling of the case where we need to failover from web_socket to the base\n   * transport is implemented in the connectWs method.\n   */\n  connectImpl(transportParams, connectCount) {\n    const state = this.state.state;\n    if (state !== this.states.connecting.state) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"ConnectionManager.connectImpl()\",\n        \"Must be in connecting state to connect, but was \" + state\n      );\n      return;\n    }\n    const transportPreference = this.getTransportPreference();\n    if (transportPreference && transportPreference === this.baseTransport && this.webSocketTransportAvailable) {\n      this.checkWsConnectivity().then(() => {\n        this.unpersistTransportPreference();\n        if (this.state === this.states.connecting) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_MINOR,\n            \"ConnectionManager.connectImpl():\",\n            \"web socket connectivity available, cancelling connection attempt with \" + this.baseTransport\n          );\n          this.disconnectAllTransports();\n          this.connectWs(transportParams, ++this.connectCounter);\n        }\n      }).catch(noop2);\n    }\n    if (transportPreference && transportPreference === this.baseTransport || this.baseTransport && !this.webSocketTransportAvailable) {\n      this.connectBase(transportParams, connectCount);\n    } else {\n      this.connectWs(transportParams, connectCount);\n    }\n  }\n  /*\n   * connectWs starts two timers to monitor the success of a web_socket connection attempt:\n   * - webSocketSlowTimer: if this timer fires before the connection succeeds,\n   *   cm will simultaneously check websocket and http/xhr connectivity. if the http\n   *   connectivity check fails, we give up the connection sequence entirely and\n   *   transition to disconnected. if the websocket connectivity check fails then\n   *   we assume no ws connectivity and failover to base transport. in the case that\n   *   the checks succeed, we continue with websocket and wait for it to try fallback hosts\n   *   and, if unsuccessful, ultimately transition to disconnected.\n   * - webSocketGiveUpTimer: if this timer fires, and the preceding websocket\n   *   connectivity check is still pending then we assume that there is an issue\n   *   with the transport and fallback to base transport.\n   */\n  connectWs(transportParams, connectCount) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.connectWs()\");\n    this.wsCheckResult = null;\n    this.abandonedWebSocket = false;\n    this.startWebSocketSlowTimer();\n    this.startWebSocketGiveUpTimer(transportParams);\n    this.tryTransportWithFallbacks(\"web_socket\", transportParams, true, connectCount, () => {\n      return this.wsCheckResult !== false && !this.abandonedWebSocket;\n    });\n  }\n  connectBase(transportParams, connectCount) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.connectBase()\");\n    if (this.baseTransport) {\n      this.tryTransportWithFallbacks(this.baseTransport, transportParams, false, connectCount, () => true);\n    } else {\n      this.notifyState({\n        state: \"disconnected\",\n        error: new ErrorInfo(\"No transports left to try\", 8e4, 404)\n      });\n    }\n  }\n  tryTransportWithFallbacks(transportName, transportParams, ws, connectCount, shouldContinue) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"ConnectionManager.tryTransportWithFallbacks()\",\n      transportName\n    );\n    const giveUp = (err) => {\n      this.notifyState({ state: this.states.connecting.failState, error: err });\n    };\n    const candidateHosts = ws ? this.wsHosts.slice() : this.httpHosts.slice();\n    const hostAttemptCb = (fatal, transport) => {\n      if (connectCount !== this.connectCounter) {\n        return;\n      }\n      if (!shouldContinue()) {\n        if (transport) {\n          transport.dispose();\n        }\n        return;\n      }\n      if (!transport && !fatal) {\n        tryFallbackHosts();\n      }\n    };\n    const host = candidateHosts.shift();\n    if (!host) {\n      giveUp(new ErrorInfo(\"Unable to connect (no available host)\", 80003, 404));\n      return;\n    }\n    transportParams.host = host;\n    const tryFallbackHosts = () => {\n      if (!candidateHosts.length) {\n        giveUp(new ErrorInfo(\"Unable to connect (and no more fallback hosts to try)\", 80003, 404));\n        return;\n      }\n      if (!this.realtime.http.checkConnectivity) {\n        giveUp(new PartialErrorInfo(\"Internal error: Http.checkConnectivity not set\", null, 500));\n        return;\n      }\n      whenPromiseSettles(\n        this.realtime.http.checkConnectivity(),\n        (err, connectivity) => {\n          if (connectCount !== this.connectCounter) {\n            return;\n          }\n          if (!shouldContinue()) {\n            return;\n          }\n          if (err) {\n            giveUp(err);\n            return;\n          }\n          if (!connectivity) {\n            giveUp(new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404));\n            return;\n          }\n          transportParams.host = arrPopRandomElement(candidateHosts);\n          this.tryATransport(transportParams, transportName, hostAttemptCb);\n        }\n      );\n    };\n    if (this.forceFallbackHost && candidateHosts.length) {\n      this.forceFallbackHost = false;\n      tryFallbackHosts();\n      return;\n    }\n    this.tryATransport(transportParams, transportName, hostAttemptCb);\n  }\n  closeImpl() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.closeImpl()\", \"closing connection\");\n    this.cancelSuspendTimer();\n    this.startTransitionTimer(this.states.closing);\n    if (this.pendingTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.closeImpl()\",\n        \"Closing pending transport: \" + this.pendingTransport\n      );\n      this.pendingTransport.close();\n    }\n    if (this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.closeImpl()\",\n        \"Closing active transport: \" + this.activeProtocol.getTransport()\n      );\n      this.activeProtocol.getTransport().close();\n    }\n    this.notifyState({ state: \"closed\" });\n  }\n  onAuthUpdated(tokenDetails, callback) {\n    var _a2;\n    switch (this.state.state) {\n      case \"connected\": {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Sending AUTH message on active transport\"\n        );\n        const activeTransport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n        if (activeTransport && activeTransport.onAuthUpdated) {\n          activeTransport.onAuthUpdated(tokenDetails);\n        }\n        const authMsg = fromValues({\n          action: actions.AUTH,\n          auth: {\n            accessToken: tokenDetails.token\n          }\n        });\n        this.send(authMsg);\n        const successListener = () => {\n          this.off(failureListener);\n          callback(null, tokenDetails);\n        };\n        const failureListener = (stateChange) => {\n          if (stateChange.current === \"failed\") {\n            this.off(successListener);\n            this.off(failureListener);\n            callback(stateChange.reason || this.getStateError());\n          }\n        };\n        this.once(\"connectiondetails\", successListener);\n        this.on(\"connectionstate\", failureListener);\n        break;\n      }\n      case \"connecting\":\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Aborting current connection attempts in order to start again with the new auth details\"\n        );\n        this.disconnectAllTransports();\n      default: {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_MICRO,\n          \"ConnectionManager.onAuthUpdated()\",\n          \"Connection state is \" + this.state.state + \"; waiting until either connected or failed\"\n        );\n        const listener = (stateChange) => {\n          switch (stateChange.current) {\n            case \"connected\":\n              this.off(listener);\n              callback(null, tokenDetails);\n              break;\n            case \"failed\":\n            case \"closed\":\n            case \"suspended\":\n              this.off(listener);\n              callback(stateChange.reason || this.getStateError());\n              break;\n            default:\n              break;\n          }\n        };\n        this.on(\"connectionstate\", listener);\n        if (this.state.state === \"connecting\") {\n          this.startConnect();\n        } else {\n          this.requestState({ state: \"connecting\" });\n        }\n      }\n    }\n  }\n  disconnectAllTransports() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"ConnectionManager.disconnectAllTransports()\",\n      \"Disconnecting all transports\"\n    );\n    this.connectCounter++;\n    if (this.pendingTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting pending transport: \" + this.pendingTransport\n      );\n      this.pendingTransport.disconnect();\n    }\n    delete this.pendingTransport;\n    if (this.proposedTransport) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting proposed transport: \" + this.pendingTransport\n      );\n      this.proposedTransport.disconnect();\n    }\n    delete this.pendingTransport;\n    if (this.activeProtocol) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.disconnectAllTransports()\",\n        \"Disconnecting active transport: \" + this.activeProtocol.getTransport()\n      );\n      this.activeProtocol.getTransport().disconnect();\n    }\n  }\n  /******************\n   * event queueing\n   ******************/\n  send(msg, queueEvent, callback) {\n    callback = callback || noop2;\n    const state = this.state;\n    if (state.sendEvents) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.send()\", \"sending event\");\n      this.sendImpl(new PendingMessage(msg, callback));\n      return;\n    }\n    const shouldQueue = queueEvent && state.queueEvents;\n    if (!shouldQueue) {\n      const err = \"rejecting event, queueEvent was \" + queueEvent + \", state was \" + state.state;\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.send()\", err);\n      callback(this.errorReason || new ErrorInfo(err, 9e4, 400));\n      return;\n    }\n    if (this.logger.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.send()\",\n        \"queueing msg; \" + stringify(msg, this.realtime._RealtimePresence, this.realtime._Annotations)\n      );\n    }\n    this.queue(msg, callback);\n  }\n  sendImpl(pendingMessage) {\n    const msg = pendingMessage.message;\n    if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {\n      msg.msgSerial = this.msgSerial++;\n    }\n    try {\n      this.activeProtocol.send(pendingMessage);\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.sendImpl()\",\n        \"Unexpected exception in transport.send(): \" + e.stack\n      );\n    }\n  }\n  queue(msg, callback) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"ConnectionManager.queue()\", \"queueing event\");\n    const lastQueued = this.queuedMessages.last();\n    const maxSize = this.options.maxMessageSize;\n    if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {\n      if (!lastQueued.merged) {\n        lastQueued.callback = multicaster_default.create(this.logger, [lastQueued.callback]);\n        lastQueued.merged = true;\n      }\n      lastQueued.callback.push(callback);\n    } else {\n      this.queuedMessages.push(new PendingMessage(msg, callback));\n    }\n  }\n  sendQueuedMessages() {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"ConnectionManager.sendQueuedMessages()\",\n      \"sending \" + this.queuedMessages.count() + \" queued messages\"\n    );\n    let pendingMessage;\n    while (pendingMessage = this.queuedMessages.shift())\n      this.sendImpl(pendingMessage);\n  }\n  queuePendingMessages(pendingMessages) {\n    if (pendingMessages && pendingMessages.length) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"ConnectionManager.queuePendingMessages()\",\n        \"queueing \" + pendingMessages.length + \" pending messages\"\n      );\n      this.queuedMessages.prepend(pendingMessages);\n    }\n  }\n  failQueuedMessages(err) {\n    const numQueued = this.queuedMessages.count();\n    if (numQueued > 0) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"ConnectionManager.failQueuedMessages()\",\n        \"failing \" + numQueued + \" queued messages, err = \" + inspectError(err)\n      );\n      this.queuedMessages.completeAllMessages(err);\n    }\n  }\n  onChannelMessage(message, transport) {\n    this.pendingChannelMessagesState.queue.push({ message, transport });\n    if (!this.pendingChannelMessagesState.isProcessing) {\n      this.processNextPendingChannelMessage();\n    }\n  }\n  processNextPendingChannelMessage() {\n    if (this.pendingChannelMessagesState.queue.length > 0) {\n      this.pendingChannelMessagesState.isProcessing = true;\n      const pendingChannelMessage = this.pendingChannelMessagesState.queue.shift();\n      this.processChannelMessage(pendingChannelMessage.message).catch((err) => {\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"ConnectionManager.processNextPendingChannelMessage() received error \",\n          err\n        );\n      }).finally(() => {\n        this.pendingChannelMessagesState.isProcessing = false;\n        this.processNextPendingChannelMessage();\n      });\n    }\n  }\n  async processChannelMessage(message) {\n    await this.realtime.channels.processChannelMessage(message);\n  }\n  async ping() {\n    var _a2;\n    if (this.state.state !== \"connected\") {\n      throw new ErrorInfo(\"Unable to ping service; not connected\", 4e4, 400);\n    }\n    const transport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n    if (!transport) {\n      throw this.getStateError();\n    }\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.ping()\", \"transport = \" + transport);\n    const pingStart = Date.now();\n    const id = cheapRandStr();\n    return withTimeoutAsync(\n      new Promise((resolve) => {\n        const onHeartbeat = (responseId) => {\n          if (responseId === id) {\n            transport.off(\"heartbeat\", onHeartbeat);\n            resolve(Date.now() - pingStart);\n          }\n        };\n        transport.on(\"heartbeat\", onHeartbeat);\n        transport.ping(id);\n      }),\n      this.options.timeouts.realtimeRequestTimeout,\n      \"Timeout waiting for heartbeat response\"\n    );\n  }\n  abort(error) {\n    this.activeProtocol.getTransport().fail(error);\n  }\n  getTransportPreference() {\n    var _a2, _b;\n    return this.transportPreference || haveWebStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.get) == null ? void 0 : _b.call(_a2, transportPreferenceName));\n  }\n  persistTransportPreference(transport) {\n    var _a2, _b;\n    this.transportPreference = transport.shortName;\n    if (haveWebStorage()) {\n      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.set) == null ? void 0 : _b.call(_a2, transportPreferenceName, transport.shortName);\n    }\n  }\n  unpersistTransportPreference() {\n    var _a2, _b;\n    this.transportPreference = null;\n    if (haveWebStorage()) {\n      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.remove) == null ? void 0 : _b.call(_a2, transportPreferenceName);\n    }\n  }\n  /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,\n   * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual\n   * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth\n   * server returns 403. */\n  actOnErrorFromAuthorize(err) {\n    if (err.code === 40171) {\n      this.notifyState({ state: \"failed\", error: err });\n    } else if (err.code === 40102) {\n      this.notifyState({ state: \"failed\", error: err });\n    } else if (err.statusCode === HttpStatusCodes_default.Forbidden) {\n      const msg = \"Client configured authentication provider returned 403; failing the connection\";\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.actOnErrorFromAuthorize()\", msg);\n      this.notifyState({ state: \"failed\", error: new ErrorInfo(msg, 80019, 403, err) });\n    } else {\n      const msg = \"Client configured authentication provider request failed\";\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"ConnectionManager.actOnErrorFromAuthorize\", msg);\n      this.notifyState({ state: this.state.failState, error: new ErrorInfo(msg, 80019, 401, err) });\n    }\n  }\n  onConnectionDetailsUpdate(connectionDetails, transport) {\n    if (!connectionDetails) {\n      return;\n    }\n    this.connectionDetails = connectionDetails;\n    if (connectionDetails.maxMessageSize) {\n      this.options.maxMessageSize = connectionDetails.maxMessageSize;\n    }\n    const clientId = connectionDetails.clientId;\n    if (clientId) {\n      const err = this.realtime.auth._uncheckedSetClientId(clientId);\n      if (err) {\n        logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"ConnectionManager.onConnectionDetailsUpdate()\", err.message);\n        transport.fail(err);\n        return;\n      }\n    }\n    const connectionStateTtl = connectionDetails.connectionStateTtl;\n    if (connectionStateTtl) {\n      this.connectionStateTtl = connectionStateTtl;\n    }\n    this.maxIdleInterval = connectionDetails.maxIdleInterval;\n    this.emit(\"connectiondetails\", connectionDetails);\n  }\n  checkWsConnectivity() {\n    const wsConnectivityCheckUrl = this.options.wsConnectivityCheckUrl || defaults_default.wsConnectivityCheckUrl;\n    const ws = new Platform.Config.WebSocket(wsConnectivityCheckUrl);\n    return new Promise((resolve, reject) => {\n      let finished = false;\n      ws.onopen = () => {\n        if (!finished) {\n          finished = true;\n          resolve();\n          ws.close();\n        }\n      };\n      ws.onclose = ws.onerror = () => {\n        if (!finished) {\n          finished = true;\n          reject();\n        }\n      };\n    });\n  }\n  sessionRecoveryName() {\n    return this.options.recoveryKeyStorageName || \"ably-connection-recovery\";\n  }\n  getSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.getSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName()));\n  }\n  setSessionRecoverData(value) {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.setSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName(), value));\n  }\n  clearSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.removeSession) == null ? void 0 : _b.call(_a2, this.sessionRecoveryName()));\n  }\n};\nvar connectionmanager_default = ConnectionManager;\n\n// src/common/lib/client/connection.ts\nvar Connection = class extends eventemitter_default {\n  constructor(ably, options) {\n    super(ably.logger);\n    this.whenState = (state) => {\n      return eventemitter_default.prototype.whenState.call(this, state, this.state);\n    };\n    this.ably = ably;\n    this.connectionManager = new connectionmanager_default(ably, options);\n    this.state = this.connectionManager.state.state;\n    this.key = void 0;\n    this.id = void 0;\n    this.errorReason = null;\n    this.connectionManager.on(\"connectionstate\", (stateChange) => {\n      const state = this.state = stateChange.current;\n      Platform.Config.nextTick(() => {\n        this.emit(state, stateChange);\n      });\n    });\n    this.connectionManager.on(\"update\", (stateChange) => {\n      Platform.Config.nextTick(() => {\n        this.emit(\"update\", stateChange);\n      });\n    });\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.connect()\", \"\");\n    this.connectionManager.requestState({ state: \"connecting\" });\n  }\n  async ping() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.ping()\", \"\");\n    return this.connectionManager.ping();\n  }\n  close() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Connection.close()\", \"connectionKey = \" + this.key);\n    this.connectionManager.requestState({ state: \"closing\" });\n  }\n  get recoveryKey() {\n    this.logger.deprecationWarning(\n      \"The `Connection.recoveryKey` attribute has been replaced by the `Connection.createRecoveryKey()` method. Replace your usage of `recoveryKey` with the return value of `createRecoveryKey()`. `recoveryKey` will be removed in a future version.\"\n    );\n    return this.createRecoveryKey();\n  }\n  createRecoveryKey() {\n    return this.connectionManager.createRecoveryKey();\n  }\n};\nvar connection_default = Connection;\n\n// src/common/lib/client/baserealtime.ts\nvar _BaseRealtime = class _BaseRealtime extends baseclient_default {\n  /*\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n   *\n   * 1. passes a string (which is quite likely if they’re e.g. migrating from the default variant to the modular variant)\n   * 2. passes no argument at all\n   *\n   * tell the compiler that these cases are possible so that it forces us to handle them.\n   */\n  constructor(options) {\n    var _a2, _b;\n    super(defaults_default.objectifyOptions(options, false, \"BaseRealtime\", logger_default.defaultLogger));\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime()\", \"\");\n    if (typeof EdgeRuntime === \"string\") {\n      throw new ErrorInfo(\n        `Ably.Realtime instance cannot be used in Vercel Edge runtime. If you are running Vercel Edge functions, please replace your \"new Ably.Realtime()\" with \"new Ably.Rest()\" and use Ably Rest API instead of the Realtime API. If you are server-rendering your application in the Vercel Edge runtime, please use the condition \"if (typeof EdgeRuntime === 'string')\" to prevent instantiating Ably.Realtime instance during SSR in the Vercel Edge runtime.`,\n        4e4,\n        400\n      );\n    }\n    this._additionalTransportImplementations = _BaseRealtime.transportImplementationsFromPlugins(this.options.plugins);\n    this._RealtimePresence = (_b = (_a2 = this.options.plugins) == null ? void 0 : _a2.RealtimePresence) != null ? _b : null;\n    this.connection = new connection_default(this, this.options);\n    this._channels = new Channels2(this);\n    if (this.options.autoConnect !== false)\n      this.connect();\n  }\n  static transportImplementationsFromPlugins(plugins) {\n    const transports = {};\n    if (plugins == null ? void 0 : plugins.WebSocketTransport) {\n      transports[TransportNames.WebSocket] = plugins.WebSocketTransport;\n    }\n    if (plugins == null ? void 0 : plugins.XHRPolling) {\n      transports[TransportNames.XhrPolling] = plugins.XHRPolling;\n    }\n    return transports;\n  }\n  get channels() {\n    return this._channels;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.connect()\", \"\");\n    this.connection.connect();\n  }\n  close() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"Realtime.close()\", \"\");\n    this.connection.close();\n  }\n};\n// internal API to make EventEmitter usable in other SDKs\n_BaseRealtime.EventEmitter = eventemitter_default;\nvar BaseRealtime = _BaseRealtime;\nvar Channels2 = class extends eventemitter_default {\n  constructor(realtime) {\n    super(realtime.logger);\n    this.realtime = realtime;\n    this.all = /* @__PURE__ */ Object.create(null);\n    realtime.connection.connectionManager.on(\"transport.active\", () => {\n      this.onTransportActive();\n    });\n  }\n  channelSerials() {\n    let serials = {};\n    for (const name of keysArray(this.all, true)) {\n      const channel = this.all[name];\n      if (channel.properties.channelSerial) {\n        serials[name] = channel.properties.channelSerial;\n      }\n    }\n    return serials;\n  }\n  // recoverChannels gets the given channels and sets their channel serials.\n  recoverChannels(channelSerials) {\n    for (const name of keysArray(channelSerials, true)) {\n      const channel = this.get(name);\n      channel.properties.channelSerial = channelSerials[name];\n    }\n  }\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage.\n  async processChannelMessage(msg) {\n    const channelName = msg.channel;\n    if (channelName === void 0) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Channels.processChannelMessage()\",\n        \"received event unspecified channel, action = \" + msg.action\n      );\n      return;\n    }\n    const channel = this.all[channelName];\n    if (!channel) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"Channels.processChannelMessage()\",\n        \"received event for non-existent channel: \" + channelName\n      );\n      return;\n    }\n    await channel.processMessage(msg);\n  }\n  /* called when a transport becomes connected; reattempt attach/detach\n   * for channels that are attaching or detaching. */\n  onTransportActive() {\n    for (const channelName in this.all) {\n      const channel = this.all[channelName];\n      if (channel.state === \"attaching\" || channel.state === \"detaching\") {\n        channel.checkPendingState();\n      } else if (channel.state === \"suspended\") {\n        channel._attach(false, null);\n      } else if (channel.state === \"attached\") {\n        channel.requestState(\"attaching\");\n      }\n    }\n  }\n  /* Connection interruptions (ie when the connection will no longer queue\n   * events) imply connection state changes for any channel which is either\n   * attached, pending, or will attempt to become attached in the future */\n  propogateConnectionInterruption(connectionState, reason) {\n    const connectionStateToChannelState = {\n      closing: \"detached\",\n      closed: \"detached\",\n      failed: \"failed\",\n      suspended: \"suspended\"\n    };\n    const fromChannelStates = [\"attaching\", \"attached\", \"detaching\", \"suspended\"];\n    const toChannelState = connectionStateToChannelState[connectionState];\n    for (const channelId in this.all) {\n      const channel = this.all[channelId];\n      if (fromChannelStates.includes(channel.state)) {\n        channel.notifyState(toChannelState, reason);\n      }\n    }\n  }\n  get(name, channelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      channel = this.all[name] = new realtimechannel_default(this.realtime, name, channelOptions);\n    } else if (channelOptions) {\n      if (channel._shouldReattachToSetOptions(channelOptions, channel.channelOptions)) {\n        throw new ErrorInfo(\n          \"Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.\",\n          4e4,\n          400\n        );\n      }\n      channel.setOptions(channelOptions);\n    }\n    return channel;\n  }\n  getDerived(name, deriveOptions, channelOptions) {\n    if (deriveOptions.filter) {\n      const filter = toBase64(deriveOptions.filter);\n      const match = matchDerivedChannel(name);\n      name = `[filter=${filter}${match.qualifierParam}]${match.channelName}`;\n    }\n    return this.get(name, channelOptions);\n  }\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name) {\n    name = String(name);\n    const channel = this.all[name];\n    if (!channel) {\n      return;\n    }\n    const releaseErr = channel.getReleaseErr();\n    if (releaseErr) {\n      throw releaseErr;\n    }\n    delete this.all[name];\n  }\n};\nvar baserealtime_default = BaseRealtime;\n\n// src/common/lib/client/presencemap.ts\nfunction newerThan(item, existing) {\n  if (item.isSynthesized() || existing.isSynthesized()) {\n    return item.timestamp >= existing.timestamp;\n  }\n  const itemOrderings = item.parseId(), existingOrderings = existing.parseId();\n  if (itemOrderings.msgSerial === existingOrderings.msgSerial) {\n    return itemOrderings.index > existingOrderings.index;\n  } else {\n    return itemOrderings.msgSerial > existingOrderings.msgSerial;\n  }\n}\nvar PresenceMap = class extends eventemitter_default {\n  constructor(presence, memberKey, newer = newerThan) {\n    super(presence.logger);\n    this.presence = presence;\n    this.map = /* @__PURE__ */ Object.create(null);\n    this.syncInProgress = false;\n    this.residualMembers = null;\n    this.memberKey = memberKey;\n    this.newerThan = newer;\n  }\n  get(key) {\n    return this.map[key];\n  }\n  getClient(clientId) {\n    const map = this.map, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.clientId == clientId && item.action != \"absent\")\n        result.push(item);\n    }\n    return result;\n  }\n  list(params) {\n    const map = this.map, clientId = params && params.clientId, connectionId = params && params.connectionId, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action === \"absent\")\n        continue;\n      if (clientId && clientId != item.clientId)\n        continue;\n      if (connectionId && connectionId != item.connectionId)\n        continue;\n      result.push(item);\n    }\n    return result;\n  }\n  put(item) {\n    if (item.action === \"enter\" || item.action === \"update\") {\n      item = presencemessage_default.fromValues(item);\n      item.action = \"present\";\n    }\n    const map = this.map, key = this.memberKey(item);\n    if (this.residualMembers)\n      delete this.residualMembers[key];\n    const existingItem = map[key];\n    if (existingItem && !this.newerThan(item, existingItem)) {\n      return false;\n    }\n    map[key] = item;\n    return true;\n  }\n  values() {\n    const map = this.map, result = [];\n    for (const key in map) {\n      const item = map[key];\n      if (item.action != \"absent\")\n        result.push(item);\n    }\n    return result;\n  }\n  remove(item) {\n    const map = this.map, key = this.memberKey(item);\n    const existingItem = map[key];\n    if (existingItem && !this.newerThan(item, existingItem)) {\n      return false;\n    }\n    if (this.syncInProgress) {\n      item = presencemessage_default.fromValues(item);\n      item.action = \"absent\";\n      map[key] = item;\n    } else {\n      delete map[key];\n    }\n    return !!existingItem;\n  }\n  startSync() {\n    const map = this.map, syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.startSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (!this.syncInProgress) {\n      this.residualMembers = copy(map);\n      this.setInProgress(true);\n    }\n  }\n  endSync() {\n    const map = this.map, syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.endSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (syncInProgress) {\n      for (const memberKey in map) {\n        const entry = map[memberKey];\n        if (entry.action === \"absent\") {\n          delete map[memberKey];\n        }\n      }\n      this.presence._synthesizeLeaves(valuesArray(this.residualMembers));\n      for (const memberKey in this.residualMembers) {\n        delete map[memberKey];\n      }\n      this.residualMembers = null;\n      this.setInProgress(false);\n    }\n    this.emit(\"sync\");\n  }\n  waitSync(callback) {\n    const syncInProgress = this.syncInProgress;\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"PresenceMap.waitSync()\",\n      \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress\n    );\n    if (!syncInProgress) {\n      callback();\n      return;\n    }\n    this.once(\"sync\", callback);\n  }\n  clear() {\n    this.map = {};\n    this.setInProgress(false);\n    this.residualMembers = null;\n  }\n  setInProgress(inProgress) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"PresenceMap.setInProgress()\", \"inProgress = \" + inProgress);\n    this.syncInProgress = inProgress;\n    this.presence.syncComplete = !inProgress;\n  }\n};\n\n// src/common/lib/client/realtimepresence.ts\nfunction getClientId(realtimePresence) {\n  return realtimePresence.channel.client.auth.clientId;\n}\nfunction isAnonymousOrWildcard(realtimePresence) {\n  const realtime = realtimePresence.channel.client;\n  const clientId = realtime.auth.clientId;\n  return (!clientId || clientId === \"*\") && realtime.connection.state === \"connected\";\n}\nfunction waitAttached(channel, callback, action) {\n  switch (channel.state) {\n    case \"attached\":\n    case \"suspended\":\n      action();\n      break;\n    case \"initialized\":\n    case \"detached\":\n    case \"detaching\":\n    case \"attaching\":\n      whenPromiseSettles(channel.attach(), function(err) {\n        if (err)\n          callback(err);\n        else\n          action();\n      });\n      break;\n    default:\n      callback(ErrorInfo.fromValues(channel.invalidStateError()));\n  }\n}\nvar RealtimePresence = class extends eventemitter_default {\n  constructor(channel) {\n    super(channel.logger);\n    this.channel = channel;\n    this.syncComplete = false;\n    this.members = new PresenceMap(this, (item) => item.clientId + \":\" + item.connectionId);\n    this._myMembers = new PresenceMap(this, (item) => item.clientId);\n    this.subscriptions = new eventemitter_default(this.logger);\n    this.pendingPresence = [];\n  }\n  async enter(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must be specified to enter a presence channel\", 40012, 400);\n    }\n    return this._enterOrUpdateClient(void 0, void 0, data, \"enter\");\n  }\n  async update(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must be specified to update presence data\", 40012, 400);\n    }\n    return this._enterOrUpdateClient(void 0, void 0, data, \"update\");\n  }\n  async enterClient(clientId, data) {\n    return this._enterOrUpdateClient(void 0, clientId, data, \"enter\");\n  }\n  async updateClient(clientId, data) {\n    return this._enterOrUpdateClient(void 0, clientId, data, \"update\");\n  }\n  async _enterOrUpdateClient(id, clientId, data, action) {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.\" + action + \"Client()\",\n      \"channel = \" + channel.name + \", id = \" + id + \", client = \" + (clientId || \"(implicit) \" + getClientId(this))\n    );\n    const presence = presencemessage_default.fromData(data);\n    presence.action = action;\n    if (id) {\n      presence.id = id;\n    }\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    const wirePresMsg = await presence.encode(channel.channelOptions);\n    switch (channel.state) {\n      case \"attached\":\n        return channel.sendPresence([wirePresMsg]);\n      case \"initialized\":\n      case \"detached\":\n        channel.attach();\n      case \"attaching\":\n        return new Promise((resolve, reject) => {\n          this.pendingPresence.push({\n            presence: wirePresMsg,\n            callback: (err) => err ? reject(err) : resolve()\n          });\n        });\n      default: {\n        const err = new PartialErrorInfo(\n          \"Unable to \" + action + \" presence channel while in \" + channel.state + \" state\",\n          90001\n        );\n        err.code = 90001;\n        throw err;\n      }\n    }\n  }\n  async leave(data) {\n    if (isAnonymousOrWildcard(this)) {\n      throw new ErrorInfo(\"clientId must have been specified to enter or leave a presence channel\", 40012, 400);\n    }\n    return this.leaveClient(void 0, data);\n  }\n  async leaveClient(clientId, data) {\n    const channel = this.channel;\n    if (!channel.connectionManager.activeState()) {\n      throw channel.connectionManager.getError();\n    }\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.leaveClient()\",\n      \"leaving; channel = \" + this.channel.name + \", client = \" + clientId\n    );\n    const presence = presencemessage_default.fromData(data);\n    presence.action = \"leave\";\n    if (clientId) {\n      presence.clientId = clientId;\n    }\n    const wirePresMsg = await presence.encode(channel.channelOptions);\n    switch (channel.state) {\n      case \"attached\":\n        return channel.sendPresence([wirePresMsg]);\n      case \"attaching\":\n        return new Promise((resolve, reject) => {\n          this.pendingPresence.push({\n            presence: wirePresMsg,\n            callback: (err) => err ? reject(err) : resolve()\n          });\n        });\n      case \"initialized\":\n      case \"failed\": {\n        throw new PartialErrorInfo(\"Unable to leave presence channel (incompatible state)\", 90001);\n      }\n      default:\n        throw channel.invalidStateError();\n    }\n  }\n  async get(params) {\n    const waitForSync = !params || (\"waitForSync\" in params ? params.waitForSync : true);\n    return new Promise((resolve, reject) => {\n      function returnMembers(members) {\n        resolve(params ? members.list(params) : members.values());\n      }\n      if (this.channel.state === \"suspended\") {\n        if (waitForSync) {\n          reject(\n            ErrorInfo.fromValues({\n              statusCode: 400,\n              code: 91005,\n              message: \"Presence state is out of sync due to channel being in the SUSPENDED state\"\n            })\n          );\n        } else {\n          returnMembers(this.members);\n        }\n        return;\n      }\n      waitAttached(\n        this.channel,\n        (err) => reject(err),\n        () => {\n          const members = this.members;\n          if (waitForSync) {\n            members.waitSync(function() {\n              returnMembers(members);\n            });\n          } else {\n            returnMembers(members);\n          }\n        }\n      );\n    });\n  }\n  async history(params) {\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"RealtimePresence.history()\", \"channel = \" + this.name);\n    const restMixin = this.channel.client.rest.presenceMixin;\n    if (params && params.untilAttach) {\n      if (this.channel.state === \"attached\") {\n        delete params.untilAttach;\n        params.from_serial = this.channel.properties.attachSerial;\n      } else {\n        throw new ErrorInfo(\n          \"option untilAttach requires the channel to be attached, was: \" + this.channel.state,\n          4e4,\n          400\n        );\n      }\n    }\n    return restMixin.history(this, params);\n  }\n  setPresence(presenceSet, isSync, syncChannelSerial) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"RealtimePresence.setPresence()\",\n      \"received presence for \" + presenceSet.length + \" participants; syncChannelSerial = \" + syncChannelSerial\n    );\n    let syncCursor, match;\n    const members = this.members, myMembers = this._myMembers, broadcastMessages = [], connId = this.channel.connectionManager.connectionId;\n    if (isSync) {\n      this.members.startSync();\n      if (syncChannelSerial && (match = syncChannelSerial.match(/^[\\w-]+:(.*)$/))) {\n        syncCursor = match[1];\n      }\n    }\n    for (let presence of presenceSet) {\n      switch (presence.action) {\n        case \"leave\":\n          if (members.remove(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId && !presence.isSynthesized()) {\n            myMembers.remove(presence);\n          }\n          break;\n        case \"enter\":\n        case \"present\":\n        case \"update\":\n          if (members.put(presence)) {\n            broadcastMessages.push(presence);\n          }\n          if (presence.connectionId === connId) {\n            myMembers.put(presence);\n          }\n          break;\n      }\n    }\n    if (isSync && !syncCursor) {\n      members.endSync();\n      this.channel.syncChannelSerial = null;\n    }\n    for (let i = 0; i < broadcastMessages.length; i++) {\n      const presence = broadcastMessages[i];\n      this.subscriptions.emit(presence.action, presence);\n    }\n  }\n  onAttached(hasPresence) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"RealtimePresence.onAttached()\",\n      \"channel = \" + this.channel.name + \", hasPresence = \" + hasPresence\n    );\n    if (hasPresence) {\n      this.members.startSync();\n    } else {\n      this._synthesizeLeaves(this.members.values());\n      this.members.clear();\n    }\n    this._ensureMyMembersPresent();\n    const pendingPresence = this.pendingPresence, pendingPresCount = pendingPresence.length;\n    if (pendingPresCount) {\n      this.pendingPresence = [];\n      const presenceArray = [];\n      const multicaster = multicaster_default.create(this.logger);\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"RealtimePresence.onAttached\",\n        \"sending \" + pendingPresCount + \" queued presence messages\"\n      );\n      for (let i = 0; i < pendingPresCount; i++) {\n        const event = pendingPresence[i];\n        presenceArray.push(event.presence);\n        multicaster.push(event.callback);\n      }\n      this.channel.sendPresence(presenceArray).then(() => multicaster()).catch((err) => multicaster(err));\n    }\n  }\n  actOnChannelState(state, hasPresence, err) {\n    switch (state) {\n      case \"attached\":\n        this.onAttached(hasPresence);\n        break;\n      case \"detached\":\n      case \"failed\":\n        this._clearMyMembers();\n        this.members.clear();\n      case \"suspended\":\n        this.failPendingPresence(err);\n        break;\n    }\n  }\n  failPendingPresence(err) {\n    if (this.pendingPresence.length) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"RealtimeChannel.failPendingPresence\",\n        \"channel; name = \" + this.channel.name + \", err = \" + inspectError(err)\n      );\n      for (let i = 0; i < this.pendingPresence.length; i++)\n        try {\n          this.pendingPresence[i].callback(err);\n        } catch (e) {\n        }\n      this.pendingPresence = [];\n    }\n  }\n  _clearMyMembers() {\n    this._myMembers.clear();\n  }\n  _ensureMyMembersPresent() {\n    const myMembers = this._myMembers;\n    const connId = this.channel.connectionManager.connectionId;\n    for (const memberKey in myMembers.map) {\n      const entry = myMembers.map[memberKey];\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MICRO,\n        \"RealtimePresence._ensureMyMembersPresent()\",\n        'Auto-reentering clientId \"' + entry.clientId + '\" into the presence set'\n      );\n      const id = entry.connectionId === connId ? entry.id : void 0;\n      this._enterOrUpdateClient(id, entry.clientId, entry.data, \"enter\").catch((err) => {\n        const wrappedErr = new ErrorInfo(\"Presence auto re-enter failed\", 91004, 400, err);\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"RealtimePresence._ensureMyMembersPresent()\",\n          \"Presence auto re-enter failed; reason = \" + inspectError(err)\n        );\n        const change = new channelstatechange_default(this.channel.state, this.channel.state, true, false, wrappedErr);\n        this.channel.emit(\"update\", change);\n      });\n    }\n  }\n  _synthesizeLeaves(items) {\n    const subscriptions = this.subscriptions;\n    items.forEach(function(item) {\n      const presence = presencemessage_default.fromValues({\n        action: \"leave\",\n        connectionId: item.connectionId,\n        clientId: item.clientId,\n        data: item.data,\n        encoding: item.encoding,\n        timestamp: Date.now()\n      });\n      subscriptions.emit(\"leave\", presence);\n    });\n  }\n  async subscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    const channel = this.channel;\n    if (channel.state === \"failed\") {\n      throw ErrorInfo.fromValues(channel.invalidStateError());\n    }\n    this.subscriptions.on(event, listener);\n    if (channel.channelOptions.attachOnSubscribe !== false) {\n      await channel.attach();\n    }\n  }\n  unsubscribe(..._args) {\n    const args = realtimechannel_default.processListenerArgs(_args);\n    const event = args[0];\n    const listener = args[1];\n    this.subscriptions.off(event, listener);\n  }\n};\nvar realtimepresence_default = RealtimePresence;\n\n// src/common/lib/transport/websockettransport.ts\nvar shortName = TransportNames.WebSocket;\nfunction isNodeWebSocket(ws) {\n  return !!ws.on;\n}\nvar WebSocketTransport = class extends transport_default {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.shortName = shortName;\n    params.heartbeats = Platform.Config.useProtocolHeartbeats;\n    this.wsHost = params.host;\n  }\n  static isAvailable() {\n    return !!Platform.Config.WebSocket;\n  }\n  createWebSocket(uri, connectParams) {\n    this.uri = uri + toQueryString(connectParams);\n    return new Platform.Config.WebSocket(this.uri);\n  }\n  toString() {\n    return \"WebSocketTransport; uri=\" + this.uri;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"starting\");\n    transport_default.prototype.connect.call(this);\n    const self2 = this, params = this.params, options = params.options;\n    const wsScheme = options.tls ? \"wss://\" : \"ws://\";\n    const wsUri = wsScheme + this.wsHost + \":\" + defaults_default.getPort(options) + \"/\";\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"uri: \" + wsUri);\n    whenPromiseSettles(\n      this.auth.getAuthParams(),\n      function(err, authParams) {\n        if (self2.isDisposed) {\n          return;\n        }\n        let paramStr = \"\";\n        for (const param in authParams)\n          paramStr += \" \" + param + \": \" + authParams[param] + \";\";\n        logger_default.logAction(\n          self2.logger,\n          logger_default.LOG_MINOR,\n          \"WebSocketTransport.connect()\",\n          \"authParams:\" + paramStr + \" err: \" + err\n        );\n        if (err) {\n          self2.disconnect(err);\n          return;\n        }\n        const connectParams = params.getConnectParams(authParams);\n        try {\n          const wsConnection = self2.wsConnection = self2.createWebSocket(wsUri, connectParams);\n          wsConnection.binaryType = Platform.Config.binaryType;\n          wsConnection.onopen = function() {\n            self2.onWsOpen();\n          };\n          wsConnection.onclose = function(ev) {\n            self2.onWsClose(ev);\n          };\n          wsConnection.onmessage = function(ev) {\n            self2.onWsData(ev.data);\n          };\n          wsConnection.onerror = function(ev) {\n            self2.onWsError(ev);\n          };\n          if (isNodeWebSocket(wsConnection)) {\n            wsConnection.on(\"ping\", function() {\n              self2.onActivity();\n            });\n          }\n        } catch (e) {\n          logger_default.logAction(\n            self2.logger,\n            logger_default.LOG_ERROR,\n            \"WebSocketTransport.connect()\",\n            \"Unexpected exception creating websocket: err = \" + (e.stack || e.message)\n          );\n          self2.disconnect(e);\n        }\n      }\n    );\n  }\n  send(message) {\n    const wsConnection = this.wsConnection;\n    if (!wsConnection) {\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"WebSocketTransport.send()\", \"No socket connection\");\n      return;\n    }\n    try {\n      wsConnection.send(\n        serialize2(message, this.connectionManager.realtime._MsgPack, this.params.format)\n      );\n    } catch (e) {\n      const msg = \"Exception from ws connection when trying to send: \" + inspectError(e);\n      logger_default.logAction(this.logger, logger_default.LOG_ERROR, \"WebSocketTransport.send()\", msg);\n      this.finish(\"disconnected\", new ErrorInfo(msg, 5e4, 500));\n    }\n  }\n  onWsData(data) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MICRO,\n      \"WebSocketTransport.onWsData()\",\n      \"data received; length = \" + data.length + \"; type = \" + typeof data\n    );\n    try {\n      this.onProtocolMessage(\n        deserialize(\n          data,\n          this.connectionManager.realtime._MsgPack,\n          this.connectionManager.realtime._RealtimePresence,\n          this.connectionManager.realtime._Annotations,\n          this.format\n        )\n      );\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"WebSocketTransport.onWsData()\",\n        \"Unexpected exception handing channel message: \" + e.stack\n      );\n    }\n  }\n  onWsOpen() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsOpen()\", \"opened WebSocket\");\n    this.emit(\"preconnect\");\n  }\n  onWsClose(ev) {\n    let wasClean, code;\n    if (typeof ev == \"object\") {\n      code = ev.code;\n      wasClean = ev.wasClean || code === 1e3;\n    } else {\n      code = ev;\n      wasClean = code == 1e3;\n    }\n    delete this.wsConnection;\n    if (wasClean) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", \"Cleanly closed WebSocket\");\n      const err = new ErrorInfo(\"Websocket closed\", 80003, 400);\n      this.finish(\"disconnected\", err);\n    } else {\n      const msg = \"Unclean disconnection of WebSocket ; code = \" + code, err = new ErrorInfo(msg, 80003, 400);\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", msg);\n      this.finish(\"disconnected\", err);\n    }\n    this.emit(\"disposed\");\n  }\n  onWsError(err) {\n    logger_default.logAction(\n      this.logger,\n      logger_default.LOG_MINOR,\n      \"WebSocketTransport.onError()\",\n      \"Error from WebSocket: \" + err.message\n    );\n    Platform.Config.nextTick(() => {\n      this.disconnect(Error(err.message));\n    });\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"WebSocketTransport.dispose()\", \"\");\n    this.isDisposed = true;\n    const wsConnection = this.wsConnection;\n    if (wsConnection) {\n      wsConnection.onmessage = function() {\n      };\n      delete this.wsConnection;\n      Platform.Config.nextTick(() => {\n        logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"WebSocketTransport.dispose()\", \"closing websocket\");\n        if (!wsConnection) {\n          throw new Error(\"WebSocketTransport.dispose(): wsConnection is not defined\");\n        }\n        wsConnection.close();\n      });\n    }\n  }\n};\nvar websockettransport_default = WebSocketTransport;\n\n// src/common/lib/client/filteredsubscriptions.ts\nvar FilteredSubscriptions = class {\n  static subscribeFilter(channel, filter, listener) {\n    const filteredListener = (m) => {\n      var _a2, _b, _c, _d, _e, _f;\n      const mapping = {\n        name: m.name,\n        refTimeserial: (_b = (_a2 = m.extras) == null ? void 0 : _a2.ref) == null ? void 0 : _b.timeserial,\n        refType: (_d = (_c = m.extras) == null ? void 0 : _c.ref) == null ? void 0 : _d.type,\n        isRef: !!((_f = (_e = m.extras) == null ? void 0 : _e.ref) == null ? void 0 : _f.timeserial),\n        clientId: m.clientId\n      };\n      if (Object.entries(filter).find(\n        ([key, value]) => value !== void 0 ? mapping[key] !== value : false\n      )) {\n        return;\n      }\n      listener(m);\n    };\n    this.addFilteredSubscription(channel, filter, listener, filteredListener);\n    channel.subscriptions.on(filteredListener);\n  }\n  // Adds a new filtered subscription\n  static addFilteredSubscription(channel, filter, realListener, filteredListener) {\n    var _a2;\n    if (!channel.filteredSubscriptions) {\n      channel.filteredSubscriptions = /* @__PURE__ */ new Map();\n    }\n    if (channel.filteredSubscriptions.has(realListener)) {\n      const realListenerMap = channel.filteredSubscriptions.get(realListener);\n      realListenerMap.set(filter, ((_a2 = realListenerMap == null ? void 0 : realListenerMap.get(filter)) == null ? void 0 : _a2.concat(filteredListener)) || [filteredListener]);\n    } else {\n      channel.filteredSubscriptions.set(\n        realListener,\n        /* @__PURE__ */ new Map([[filter, [filteredListener]]])\n      );\n    }\n  }\n  static getAndDeleteFilteredSubscriptions(channel, filter, realListener) {\n    if (!channel.filteredSubscriptions) {\n      return [];\n    }\n    if (!realListener && filter) {\n      return Array.from(channel.filteredSubscriptions.entries()).map(([key, filterMaps]) => {\n        var _a2;\n        let listenerMaps = filterMaps.get(filter);\n        filterMaps.delete(filter);\n        if (filterMaps.size === 0) {\n          (_a2 = channel.filteredSubscriptions) == null ? void 0 : _a2.delete(key);\n        }\n        return listenerMaps;\n      }).reduce(\n        (prev, cur) => cur ? prev.concat(...cur) : prev,\n        []\n      );\n    }\n    if (!realListener || !channel.filteredSubscriptions.has(realListener)) {\n      return [];\n    }\n    const realListenerMap = channel.filteredSubscriptions.get(realListener);\n    if (!filter) {\n      const listeners2 = Array.from(realListenerMap.values()).reduce((prev, cur) => prev.concat(...cur), []);\n      channel.filteredSubscriptions.delete(realListener);\n      return listeners2;\n    }\n    let listeners = realListenerMap.get(filter);\n    realListenerMap.delete(filter);\n    return listeners || [];\n  }\n};\n\n// src/common/lib/client/defaultrealtime.ts\nvar _DefaultRealtime = class _DefaultRealtime extends baserealtime_default {\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n  constructor(options) {\n    var _a2;\n    const MsgPack = _DefaultRealtime._MsgPack;\n    if (!MsgPack) {\n      throw new Error(\"Expected DefaultRealtime._MsgPack to have been set\");\n    }\n    super(\n      defaults_default.objectifyOptions(options, true, \"Realtime\", logger_default.defaultLogger, __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRealtime.Crypto) != null ? _a2 : void 0,\n        MsgPack,\n        RealtimePresence: {\n          RealtimePresence: realtimepresence_default,\n          PresenceMessage: presencemessage_default,\n          WirePresenceMessage\n        },\n        Annotations: {\n          Annotation: annotation_default,\n          WireAnnotation,\n          RealtimeAnnotations: realtimeannotations_default,\n          RestAnnotations: restannotations_default\n        },\n        WebSocketTransport: websockettransport_default,\n        MessageInteractions: FilteredSubscriptions\n      }))\n    );\n  }\n  static get Crypto() {\n    if (this._Crypto === null) {\n      throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n    }\n    return this._Crypto;\n  }\n  static set Crypto(newValue) {\n    this._Crypto = newValue;\n  }\n};\n_DefaultRealtime.Utils = utils_exports;\n_DefaultRealtime.ConnectionManager = connectionmanager_default;\n_DefaultRealtime.ProtocolMessage = protocolmessage_default;\n_DefaultRealtime._Crypto = null;\n_DefaultRealtime.Message = DefaultMessage;\n_DefaultRealtime.PresenceMessage = DefaultPresenceMessage;\n_DefaultRealtime.Annotation = DefaultAnnotation;\n_DefaultRealtime._MsgPack = null;\n// Used by tests\n_DefaultRealtime._Http = Http;\n_DefaultRealtime._PresenceMap = PresenceMap;\nvar DefaultRealtime = _DefaultRealtime;\n\n// src/platform/nodejs/lib/util/bufferutils.ts\nvar import_crypto = __toESM(__webpack_require__(/*! crypto */ \"crypto\"));\nvar BufferUtils = class {\n  constructor() {\n    this.base64CharSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    this.hexCharSet = \"0123456789abcdef\";\n  }\n  base64Decode(string) {\n    return Buffer.from(string, \"base64\");\n  }\n  base64Encode(buffer) {\n    return this.toBuffer(buffer).toString(\"base64\");\n  }\n  areBuffersEqual(buffer1, buffer2) {\n    if (!buffer1 || !buffer2)\n      return false;\n    return this.toBuffer(buffer1).compare(this.toBuffer(buffer2)) == 0;\n  }\n  byteLength(buffer) {\n    return buffer.byteLength;\n  }\n  hexDecode(string) {\n    return Buffer.from(string, \"hex\");\n  }\n  hexEncode(buffer) {\n    return this.toBuffer(buffer).toString(\"hex\");\n  }\n  /* In node, BufferUtils methods that return binary objects return a Buffer\n   * for historical reasons; the browser equivalents return ArrayBuffers */\n  isBuffer(buffer) {\n    return Buffer.isBuffer(buffer) || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);\n  }\n  toArrayBuffer(buffer) {\n    const nodeBuffer = this.toBuffer(buffer);\n    return nodeBuffer.buffer.slice(nodeBuffer.byteOffset, nodeBuffer.byteOffset + nodeBuffer.byteLength);\n  }\n  toBuffer(buffer) {\n    if (Buffer.isBuffer(buffer)) {\n      return buffer;\n    }\n    if (buffer instanceof ArrayBuffer) {\n      return Buffer.from(buffer);\n    }\n    return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  }\n  arrayBufferViewToBuffer(arrayBufferView) {\n    return this.toBuffer(arrayBufferView);\n  }\n  utf8Decode(buffer) {\n    if (!this.isBuffer(buffer)) {\n      throw new Error(\"Expected input of utf8Decode to be a buffer, arraybuffer, or view\");\n    }\n    return this.toBuffer(buffer).toString(\"utf8\");\n  }\n  utf8Encode(string) {\n    return Buffer.from(string, \"utf8\");\n  }\n  hmacSha256(message, key) {\n    const messageBuffer = this.toBuffer(message);\n    const keyBuffer = this.toBuffer(key);\n    const hmac2 = import_crypto.default.createHmac(\"SHA256\", keyBuffer);\n    hmac2.update(messageBuffer);\n    return hmac2.digest();\n  }\n};\nvar bufferutils_default = new BufferUtils();\n\n// src/platform/nodejs/lib/util/crypto.ts\nvar import_crypto2 = __toESM(__webpack_require__(/*! crypto */ \"crypto\"));\nvar import_util = __toESM(__webpack_require__(/*! util */ \"util\"));\nvar createCryptoClass = function(bufferUtils) {\n  var DEFAULT_ALGORITHM = \"aes\";\n  var DEFAULT_KEYLENGTH = 256;\n  var DEFAULT_MODE = \"cbc\";\n  var DEFAULT_BLOCKLENGTH = 16;\n  async function generateRandom(bytes) {\n    return import_util.default.promisify(import_crypto2.default.randomBytes)(bytes);\n  }\n  function getPaddedLength(plaintextLength) {\n    return plaintextLength + DEFAULT_BLOCKLENGTH & -DEFAULT_BLOCKLENGTH;\n  }\n  function validateCipherParams(params) {\n    if (params.algorithm === \"aes\" && params.mode === \"cbc\") {\n      if (params.keyLength === 128 || params.keyLength === 256) {\n        return;\n      }\n      throw new Error(\n        \"Unsupported key length \" + params.keyLength + \" for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)\"\n      );\n    }\n  }\n  function normaliseBase64(string) {\n    return string.replace(\"_\", \"/\").replace(\"-\", \"+\");\n  }\n  function filledBuffer(length, value) {\n    var result = Buffer.alloc(length);\n    result.fill(value);\n    return result;\n  }\n  var pkcs5Padding = [filledBuffer(16, 16)];\n  for (var i = 1; i <= 16; i++)\n    pkcs5Padding.push(filledBuffer(i, i));\n  class CipherParams {\n    constructor(algorithm, keyLength, mode, key) {\n      this.algorithm = algorithm;\n      this.keyLength = keyLength;\n      this.mode = mode;\n      this.key = key;\n      this.iv = null;\n    }\n  }\n  function isInstCipherParams(params) {\n    return !!(params.algorithm && params.key && params.keyLength && params.mode);\n  }\n  class Crypto2 {\n    /**\n     * Obtain a complete CipherParams instance from the provided params, filling\n     * in any not provided with default values, calculating a keyLength from\n     * the supplied key, and validating the result.\n     * @param params an object containing at a minimum a `key` key with value the\n     * key, as either a binary or a base64-encoded string.\n     * May optionally also contain: algorithm (defaults to AES),\n     * mode (defaults to 'cbc')\n     */\n    static getDefaultParams(params) {\n      var key;\n      if (!params.key) {\n        throw new Error(\"Crypto.getDefaultParams: a key is required\");\n      }\n      if (typeof params.key === \"string\") {\n        key = bufferUtils.base64Decode(normaliseBase64(params.key));\n      } else if (params.key instanceof ArrayBuffer) {\n        key = Buffer.from(params.key);\n      } else {\n        key = params.key;\n      }\n      var algorithm = params.algorithm || DEFAULT_ALGORITHM;\n      var keyLength = key.length * 8;\n      var mode = params.mode || DEFAULT_MODE;\n      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);\n      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\n        throw new Error(\n          \"Crypto.getDefaultParams: a keyLength of \" + params.keyLength + \" was specified, but the key actually has length \" + cipherParams.keyLength\n        );\n      }\n      validateCipherParams(cipherParams);\n      return cipherParams;\n    }\n    /**\n     * Generate a random encryption key from the supplied keylength (or the\n     * default keyLength if none supplied) as a Buffer\n     * @param keyLength (optional) the required keyLength in bits\n     */\n    static async generateRandomKey(keyLength) {\n      try {\n        return generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8);\n      } catch (err) {\n        throw new ErrorInfo(\"Failed to generate random key: \" + err.message, 500, 5e4, err);\n      }\n    }\n    /**\n     * Internal; get a ChannelCipher instance based on the given cipherParams\n     * @param params either a CipherParams instance or some subset of its\n     * fields that includes a key\n     */\n    static getCipher(params, logger) {\n      var _a2;\n      var cipherParams = isInstCipherParams(params) ? params : this.getDefaultParams(params);\n      return {\n        cipherParams,\n        cipher: new CBCCipher(cipherParams, (_a2 = params.iv) != null ? _a2 : null, logger)\n      };\n    }\n  }\n  Crypto2.CipherParams = CipherParams;\n  Crypto2;\n  class CBCCipher {\n    constructor(params, iv, logger) {\n      this.logger = logger;\n      this.encryptCipher = null;\n      this.algorithm = params.algorithm + \"-\" + String(params.keyLength) + \"-\" + params.mode;\n      this.key = params.key;\n      this.iv = iv;\n    }\n    async encrypt(plaintext) {\n      logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CBCCipher.encrypt()\", \"\");\n      const iv = await this.getIv();\n      if (!this.encryptCipher) {\n        this.encryptCipher = import_crypto2.default.createCipheriv(this.algorithm, this.key, iv);\n      }\n      var plaintextBuffer = bufferUtils.toBuffer(plaintext);\n      var plaintextLength = plaintextBuffer.length, paddedLength = getPaddedLength(plaintextLength);\n      var cipherOut = this.encryptCipher.update(\n        Buffer.concat([plaintextBuffer, pkcs5Padding[paddedLength - plaintextLength]])\n      );\n      var ciphertext = Buffer.concat([iv, cipherOut]);\n      return ciphertext;\n    }\n    async decrypt(ciphertext) {\n      var decryptCipher = import_crypto2.default.createDecipheriv(this.algorithm, this.key, ciphertext.slice(0, DEFAULT_BLOCKLENGTH)), plaintext = decryptCipher.update(ciphertext.slice(DEFAULT_BLOCKLENGTH)), final = decryptCipher.final();\n      if (final && final.length)\n        plaintext = Buffer.concat([plaintext, final]);\n      return plaintext;\n    }\n    async getIv() {\n      if (this.iv) {\n        var iv = this.iv;\n        this.iv = null;\n        return iv;\n      }\n      var randomBlock = await generateRandom(DEFAULT_BLOCKLENGTH);\n      if (!this.encryptCipher) {\n        return randomBlock;\n      } else {\n        return this.encryptCipher.update(randomBlock);\n      }\n    }\n  }\n  return Crypto2;\n};\n\n// src/platform/nodejs/lib/util/http.ts\nvar import_got = __toESM(__webpack_require__(/*! got */ \"(rsc)/./node_modules/got/dist/source/index.js\"));\nvar import_http5 = __toESM(__webpack_require__(/*! http */ \"http\"));\nvar import_https = __toESM(__webpack_require__(/*! https */ \"https\"));\nvar globalAgentPool = [];\nvar _a;\nvar Http2 = (_a = class {\n  constructor(client) {\n    this.agent = null;\n    this.supportsAuthHeaders = true;\n    this.supportsLinkHeaders = true;\n    this.checkConnectivity = async () => {\n      var _a2, _b, _c, _d, _e;\n      if ((_a2 = this.client) == null ? void 0 : _a2.options.disableConnectivityCheck) {\n        return true;\n      }\n      const connectivityCheckUrl = ((_b = this.client) == null ? void 0 : _b.options.connectivityCheckUrl) || defaults_default.connectivityCheckUrl;\n      const connectivityCheckParams = (_d = (_c = this.client) == null ? void 0 : _c.options.connectivityCheckParams) != null ? _d : null;\n      const connectivityUrlIsDefault = !((_e = this.client) == null ? void 0 : _e.options.connectivityCheckUrl);\n      const { error, statusCode, body } = await this.doUri(\n        HttpMethods_default.Get,\n        connectivityCheckUrl,\n        null,\n        null,\n        connectivityCheckParams\n      );\n      if (!error && !connectivityUrlIsDefault) {\n        return isSuccessCode(statusCode);\n      }\n      return !error && (body == null ? void 0 : body.toString().trim()) === \"yes\";\n    };\n    this.client = client != null ? client : null;\n  }\n  async doUri(method, uri, headers, body, params) {\n    var _a2;\n    const agentOptions = this.client && this.client.options.restAgentOptions || defaults_default.restAgentOptions;\n    const doOptions = { headers: headers || void 0, responseType: \"buffer\" };\n    if (!this.agent) {\n      const persistedAgent = (_a2 = globalAgentPool.find((x) => shallowEquals(agentOptions, x.options))) == null ? void 0 : _a2.agents;\n      if (persistedAgent) {\n        this.agent = persistedAgent;\n      } else {\n        this.agent = {\n          http: new import_http5.default.Agent(agentOptions),\n          https: new import_https.default.Agent(agentOptions)\n        };\n        globalAgentPool.push({\n          options: agentOptions,\n          agents: this.agent\n        });\n      }\n    }\n    if (body) {\n      doOptions.body = body;\n    }\n    if (params)\n      doOptions.searchParams = params;\n    doOptions.agent = this.agent;\n    doOptions.url = uri;\n    doOptions.timeout = {\n      request: (this.client && this.client.options.timeouts || defaults_default.TIMEOUTS).httpRequestTimeout\n    };\n    doOptions.retry = { limit: 0 };\n    try {\n      const res = await import_got.default[method](doOptions);\n      return this._handler(null, res, res.body);\n    } catch (err) {\n      if (err instanceof import_got.default.HTTPError) {\n        return this._handler(null, err.response, err.response.body);\n      }\n      return this._handler(err);\n    }\n  }\n  shouldFallback(err) {\n    const { code, statusCode } = err;\n    return code === \"ENETUNREACH\" || code === \"EHOSTUNREACH\" || code === \"EHOSTDOWN\" || code === \"ETIMEDOUT\" || code === \"ESOCKETTIMEDOUT\" || code === \"ENOTFOUND\" || code === \"ECONNRESET\" || code === \"ECONNREFUSED\" || statusCode >= 500 && statusCode <= 504;\n  }\n  _handler(err, response, body) {\n    var _a2;\n    if (err) {\n      return { error: err };\n    }\n    const statusCode = response.statusCode, headers = response.headers;\n    if (statusCode >= 300) {\n      switch (headers[\"content-type\"]) {\n        case \"application/json\":\n          body = JSON.parse(body);\n          break;\n        case \"application/x-msgpack\":\n          if (!((_a2 = this.client) == null ? void 0 : _a2._MsgPack)) {\n            return { error: createMissingPluginError(\"MsgPack\") };\n          }\n          body = this.client._MsgPack.decode(body);\n          break;\n      }\n      const error = body.error ? ErrorInfo.fromValues(body.error) : new ErrorInfo(\n        headers[\"x-ably-errormessage\"] || \"Error response received from server: \" + statusCode + \" body was: \" + Platform.Config.inspect(body),\n        Number(headers[\"x-ably-errorcode\"]),\n        statusCode\n      );\n      return { error, body, headers, unpacked: true, statusCode };\n    }\n    return { error: null, body, headers, unpacked: false, statusCode };\n  }\n}, _a.methods = [HttpMethods_default.Get, HttpMethods_default.Delete, HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a.methodsWithoutBody = [HttpMethods_default.Get, HttpMethods_default.Delete], _a.methodsWithBody = [HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a);\nvar http_default = Http2;\n\n// src/platform/nodejs/config.ts\nvar import_crypto3 = __toESM(__webpack_require__(/*! crypto */ \"crypto\"));\nvar import_ws = __toESM(__webpack_require__(/*! ws */ \"(rsc)/./node_modules/ably/node_modules/ws/index.js\"));\nvar import_util2 = __toESM(__webpack_require__(/*! util */ \"util\"));\nvar Config = {\n  agent: \"nodejs/\" + process.versions.node,\n  logTimestamps: true,\n  userAgent: null,\n  binaryType: \"nodebuffer\",\n  WebSocket: import_ws.default,\n  useProtocolHeartbeats: false,\n  supportsBinary: true,\n  preferBinary: true,\n  nextTick: process.nextTick,\n  inspect: import_util2.default.inspect,\n  stringByteSize: Buffer.byteLength,\n  inherits: import_util2.default.inherits,\n  addEventListener: null,\n  getRandomArrayBuffer: async function(byteLength) {\n    return import_util2.default.promisify(import_crypto3.default.randomBytes)(byteLength);\n  }\n};\nvar config_default = Config;\n\n// src/common/constants/XHRStates.ts\nvar XHRStates = /* @__PURE__ */ ((XHRStates2) => {\n  XHRStates2[XHRStates2[\"REQ_SEND\"] = 0] = \"REQ_SEND\";\n  XHRStates2[XHRStates2[\"REQ_RECV\"] = 1] = \"REQ_RECV\";\n  XHRStates2[XHRStates2[\"REQ_RECV_POLL\"] = 2] = \"REQ_RECV_POLL\";\n  XHRStates2[XHRStates2[\"REQ_RECV_STREAM\"] = 3] = \"REQ_RECV_STREAM\";\n  return XHRStates2;\n})(XHRStates || {});\nvar XHRStates_default = XHRStates;\n\n// src/common/lib/transport/comettransport.ts\nfunction shouldBeErrorAction(err) {\n  const UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];\n  if (err.code) {\n    if (auth_default.isTokenErr(err))\n      return false;\n    if (UNRESOLVABLE_ERROR_CODES.includes(err.code))\n      return true;\n    return err.code >= 4e4 && err.code < 5e4;\n  } else {\n    return false;\n  }\n}\nfunction protocolMessageFromRawError(err) {\n  if (shouldBeErrorAction(err)) {\n    return [fromValues({ action: actions.ERROR, error: err })];\n  } else {\n    return [fromValues({ action: actions.DISCONNECTED, error: err })];\n  }\n}\nvar CometTransport = class extends transport_default {\n  constructor(connectionManager, auth, params) {\n    super(\n      connectionManager,\n      auth,\n      params,\n      /* binary not supported for comet so force JSON protocol */\n      true\n    );\n    /* Historical comment, back from when we supported JSONP:\n     *\n     * > For comet, we could do the auth update by aborting the current recv and\n     * > starting a new one with the new token, that'd be sufficient for realtime.\n     * > Problem is JSONP - you can't cancel truly abort a recv once started. So\n     * > we need to send an AUTH for jsonp. In which case it's simpler to keep all\n     * > comet transports the same and do it for all of them. So we send the AUTH\n     * > instead, and don't need to abort the recv\n     *\n     * Now that we’ve dropped JSONP support, we may be able to revisit the above;\n     * see https://github.com/ably/ably-js/issues/1214.\n     */\n    this.onAuthUpdated = (tokenDetails) => {\n      this.authParams = { access_token: tokenDetails.token };\n    };\n    this.stream = \"stream\" in params ? params.stream : true;\n    this.sendRequest = null;\n    this.recvRequest = null;\n    this.pendingCallback = null;\n    this.pendingItems = null;\n  }\n  connect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.connect()\", \"starting\");\n    transport_default.prototype.connect.call(this);\n    const params = this.params;\n    const options = params.options;\n    const host = defaults_default.getHost(options, params.host);\n    const port = defaults_default.getPort(options);\n    const cometScheme = options.tls ? \"https://\" : \"http://\";\n    this.baseUri = cometScheme + host + \":\" + port + \"/comet/\";\n    const connectUri = this.baseUri + \"connect\";\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.connect()\", \"uri: \" + connectUri);\n    whenPromiseSettles(this.auth.getAuthParams(), (err, authParams) => {\n      if (err) {\n        this.disconnect(err);\n        return;\n      }\n      if (this.isDisposed) {\n        return;\n      }\n      this.authParams = authParams;\n      const connectParams = this.params.getConnectParams(authParams);\n      if (\"stream\" in connectParams)\n        this.stream = connectParams.stream;\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_MINOR,\n        \"CometTransport.connect()\",\n        \"connectParams:\" + toQueryString(connectParams)\n      );\n      let preconnected = false;\n      const connectRequest = this.recvRequest = this.createRequest(\n        connectUri,\n        null,\n        connectParams,\n        null,\n        this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV\n      );\n      connectRequest.on(\"data\", (data) => {\n        if (!this.recvRequest) {\n          return;\n        }\n        if (!preconnected) {\n          preconnected = true;\n          this.emit(\"preconnect\");\n        }\n        this.onData(data);\n      });\n      connectRequest.on(\"complete\", (err2) => {\n        if (!this.recvRequest) {\n          err2 = err2 || new ErrorInfo(\"Request cancelled\", 80003, 400);\n        }\n        this.recvRequest = null;\n        if (!preconnected && !err2) {\n          preconnected = true;\n          this.emit(\"preconnect\");\n        }\n        this.onActivity();\n        if (err2) {\n          if (err2.code) {\n            this.onData(protocolMessageFromRawError(err2));\n          } else {\n            this.disconnect(err2);\n          }\n          return;\n        }\n        Platform.Config.nextTick(() => {\n          this.recv();\n        });\n      });\n      connectRequest.exec();\n    });\n  }\n  requestClose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.requestClose()\");\n    this._requestCloseOrDisconnect(true);\n  }\n  requestDisconnect() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.requestDisconnect()\");\n    this._requestCloseOrDisconnect(false);\n  }\n  _requestCloseOrDisconnect(closing) {\n    const closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;\n    if (closeOrDisconnectUri) {\n      const request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates_default.REQ_SEND);\n      request.on(\"complete\", (err) => {\n        if (err) {\n          logger_default.logAction(\n            this.logger,\n            logger_default.LOG_ERROR,\n            \"CometTransport.request\" + (closing ? \"Close()\" : \"Disconnect()\"),\n            \"request returned err = \" + inspectError(err)\n          );\n          this.finish(\"disconnected\", err);\n        }\n      });\n      request.exec();\n    }\n  }\n  dispose() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"\");\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      if (this.recvRequest) {\n        logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"aborting recv request\");\n        this.recvRequest.abort();\n        this.recvRequest = null;\n      }\n      this.finish(\"disconnected\", connectionerrors_default.disconnected());\n      Platform.Config.nextTick(() => {\n        this.emit(\"disposed\");\n      });\n    }\n  }\n  onConnect(message) {\n    var _a2;\n    if (this.isDisposed) {\n      return;\n    }\n    const connectionStr = (_a2 = message.connectionDetails) == null ? void 0 : _a2.connectionKey;\n    transport_default.prototype.onConnect.call(this, message);\n    const baseConnectionUri = this.baseUri + connectionStr;\n    logger_default.logAction(this.logger, logger_default.LOG_MICRO, \"CometTransport.onConnect()\", \"baseUri = \" + baseConnectionUri);\n    this.sendUri = baseConnectionUri + \"/send\";\n    this.recvUri = baseConnectionUri + \"/recv\";\n    this.closeUri = baseConnectionUri + \"/close\";\n    this.disconnectUri = baseConnectionUri + \"/disconnect\";\n  }\n  send(message) {\n    if (this.sendRequest) {\n      this.pendingItems = this.pendingItems || [];\n      this.pendingItems.push(message);\n      return;\n    }\n    const pendingItems = this.pendingItems || [];\n    pendingItems.push(message);\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n  sendAnyPending() {\n    const pendingItems = this.pendingItems;\n    if (!pendingItems) {\n      return;\n    }\n    this.pendingItems = null;\n    this.sendItems(pendingItems);\n  }\n  sendItems(items) {\n    const sendRequest = this.sendRequest = this.createRequest(\n      this.sendUri,\n      null,\n      this.authParams,\n      this.encodeRequest(items),\n      XHRStates_default.REQ_SEND\n    );\n    sendRequest.on(\"complete\", (err, data) => {\n      if (err)\n        logger_default.logAction(\n          this.logger,\n          logger_default.LOG_ERROR,\n          \"CometTransport.sendItems()\",\n          \"on complete: err = \" + inspectError(err)\n        );\n      this.sendRequest = null;\n      if (err) {\n        if (err.code) {\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          this.disconnect(err);\n        }\n        return;\n      }\n      if (data) {\n        this.onData(data);\n      }\n      if (this.pendingItems) {\n        Platform.Config.nextTick(() => {\n          if (!this.sendRequest) {\n            this.sendAnyPending();\n          }\n        });\n      }\n    });\n    sendRequest.exec();\n  }\n  recv() {\n    if (this.recvRequest)\n      return;\n    if (!this.isConnected)\n      return;\n    const recvRequest = this.recvRequest = this.createRequest(\n      this.recvUri,\n      null,\n      this.authParams,\n      null,\n      this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV_POLL\n    );\n    recvRequest.on(\"data\", (data) => {\n      this.onData(data);\n    });\n    recvRequest.on(\"complete\", (err) => {\n      this.recvRequest = null;\n      this.onActivity();\n      if (err) {\n        if (err.code) {\n          this.onData(protocolMessageFromRawError(err));\n        } else {\n          this.disconnect(err);\n        }\n        return;\n      }\n      Platform.Config.nextTick(() => {\n        this.recv();\n      });\n    });\n    recvRequest.exec();\n  }\n  onData(responseData) {\n    try {\n      const items = this.decodeResponse(responseData);\n      if (items && items.length)\n        for (let i = 0; i < items.length; i++)\n          this.onProtocolMessage(\n            fromDeserialized(\n              items[i],\n              this.connectionManager.realtime._RealtimePresence,\n              this.connectionManager.realtime._Annotations\n            )\n          );\n    } catch (e) {\n      logger_default.logAction(\n        this.logger,\n        logger_default.LOG_ERROR,\n        \"CometTransport.onData()\",\n        \"Unexpected exception handing channel event: \" + e.stack\n      );\n    }\n  }\n  encodeRequest(requestItems) {\n    return JSON.stringify(requestItems);\n  }\n  decodeResponse(responseData) {\n    if (typeof responseData == \"string\")\n      return JSON.parse(responseData);\n    return responseData;\n  }\n};\nvar comettransport_default = CometTransport;\n\n// src/platform/nodejs/lib/transport/nodecomettransport.js\nvar import_http6 = __toESM(__webpack_require__(/*! http */ \"http\"));\nvar import_https2 = __toESM(__webpack_require__(/*! https */ \"https\"));\nvar import_url = __toESM(__webpack_require__(/*! url */ \"url\"));\nvar import_util3 = __toESM(__webpack_require__(/*! util */ \"util\"));\nvar noop3 = function() {\n};\nvar shortName2 = TransportNames.Comet;\nvar NodeCometTransport = class extends comettransport_default {\n  constructor(connectionManager, auth, params) {\n    super(connectionManager, auth, params);\n    this.httpAgent = null;\n    this.httpsAgent = null;\n    this.pendingRequests = 0;\n    this.shortName = shortName2;\n  }\n  static isAvailable() {\n    return true;\n  }\n  toString() {\n    return \"NodeCometTransport; uri=\" + this.baseUri + \"; isConnected=\" + this.isConnected + \"; format=\" + this.format + \"; stream=\" + this.stream;\n  }\n  getAgent(tls) {\n    var prop = tls ? \"httpsAgent\" : \"httpAgent\", agent2 = this[prop];\n    if (!agent2)\n      agent2 = this[prop] = new (tls ? import_https2.default : import_http6.default).Agent({ keepAlive: true });\n    return agent2;\n  }\n  dispose() {\n    var self2 = this;\n    this.onceNoPending(function() {\n      if (self2.httpAgent)\n        self2.httpAgent.destroy();\n      if (self2.httpsAgent)\n        self2.httpsAgent.destroy();\n    });\n    comettransport_default.prototype.dispose.call(this);\n  }\n  /* valid in non-streaming mode only, or data only contains last update */\n  request(uri, params, body, requestMode, callback) {\n    var req = this.createRequest(uri, params, body, requestMode);\n    req.once(\"complete\", callback);\n    req.exec();\n    return req;\n  }\n  createRequest(uri, headers, params, body, requestMode) {\n    return new Request(uri, headers, params, body, requestMode, this.format, this.timeouts, this);\n  }\n  addPending() {\n    ++this.pendingRequests;\n  }\n  removePending() {\n    if (--this.pendingRequests <= 0) {\n      this.emit(\"nopending\");\n    }\n  }\n  onceNoPending(listener) {\n    if (this.pendingRequests == 0) {\n      listener();\n      return;\n    }\n    this.once(\"nopending\", listener);\n  }\n};\nvar Request = class extends eventemitter_default {\n  constructor(uri, headers, params, body, requestMode, format, timeouts, transport) {\n    super(transport.logger);\n    if (typeof uri == \"string\")\n      uri = import_url.default.parse(uri);\n    var tls = uri.protocol == \"https:\";\n    this.client = tls ? import_https2.default : import_http6.default;\n    this.requestMode = requestMode;\n    this.timeouts = timeouts;\n    this.transport = transport;\n    this.requestComplete = false;\n    this.req = this.res = null;\n    var method = \"GET\", contentType = format == \"msgpack\" ? \"application/x-msgpack\" : \"application/json\";\n    headers = headers ? mixin({}, headers) : {};\n    headers[\"accept\"] = contentType;\n    if (body) {\n      method = \"POST\";\n      if (!Buffer.isBuffer(body)) {\n        if (typeof body == \"object\")\n          body = JSON.stringify(body);\n        body = Buffer.from(body);\n      }\n      this.body = body;\n      headers[\"Content-Length\"] = body.length;\n      headers[\"Content-Type\"] = contentType;\n    }\n    var requestOptions = this.requestOptions = {\n      hostname: uri.hostname,\n      port: uri.port,\n      path: uri.path + toQueryString(params),\n      method,\n      headers\n    };\n    if (transport)\n      requestOptions.agent = transport.getAgent(tls);\n  }\n  exec() {\n    var timeout = this.requestMode == XHRStates_default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout, self2 = this;\n    var timer = this.timer = setTimeout(function() {\n      self2.abort();\n    }, timeout), req = this.req = this.client.request(this.requestOptions);\n    req.on(\n      \"error\",\n      this.onReqError = function(err) {\n        err = new PartialErrorInfo(\"Request error: \" + err.message, null, 400);\n        clearTimeout(timer);\n        self2.timer = null;\n        self2.complete(err);\n      }\n    );\n    req.on(\"response\", function(res) {\n      clearTimeout(timer);\n      self2.timer = null;\n      var statusCode = res.statusCode;\n      if (statusCode == HttpStatusCodes_default.NoContent) {\n        res.resume();\n        self2.complete();\n        return;\n      }\n      res.on(\n        \"error\",\n        self2.onResError = function(err) {\n          err = new PartialErrorInfo(\"Response error: \" + err.message, null, 400);\n          self2.complete(err);\n        }\n      );\n      self2.res = res;\n      if (self2.requestMode == XHRStates_default.REQ_RECV_STREAM && statusCode < 400) {\n        self2.readStream();\n      } else {\n        self2.readFully();\n      }\n    });\n    if (this.transport)\n      this.transport.addPending();\n    req.end(this.body);\n  }\n  readStream() {\n    var res = this.res, self2 = this;\n    this.chunks = [];\n    this.streamComplete = false;\n    function onChunk(chunk) {\n      try {\n        chunk = JSON.parse(chunk);\n      } catch (e) {\n        var msg = \"Malformed response body from server: \" + e.message;\n        logger_default.logAction(self2.logger, logger_default.LOG_ERROR, \"NodeCometTransport.Request.readStream()\", msg);\n        self2.complete(new PartialErrorInfo(msg, null, 400));\n        return;\n      }\n      self2.emit(\"data\", chunk);\n    }\n    res.on(\n      \"data\",\n      this.ondata = function(data) {\n        var newChunks = String(data).split(\"\\n\"), chunks = self2.chunks;\n        if (newChunks.length > 1 && chunks.length > 0) {\n          chunks.push(newChunks.shift());\n          self2.chunks = [];\n          onChunk(chunks.join(\"\"));\n        }\n        var trailingNewChunk = newChunks.pop();\n        if (trailingNewChunk.length) {\n          self2.chunks.push(trailingNewChunk);\n        }\n        newChunks.map(onChunk);\n      }\n    );\n    res.on(\"end\", function() {\n      self2.streamComplete = true;\n      process.nextTick(function() {\n        self2.complete();\n      });\n    });\n  }\n  readFully() {\n    var res = this.res, chunks = [], self2 = this;\n    res.on(\"data\", function(chunk) {\n      chunks.push(chunk);\n    });\n    res.on(\"end\", function() {\n      process.nextTick(function() {\n        var body = Buffer.concat(chunks), statusCode = res.statusCode;\n        try {\n          body = JSON.parse(String(body));\n        } catch (e) {\n          var msg = \"Malformed response body from server: \" + e.message;\n          logger_default.logAction(self2.logger, logger_default.LOG_ERROR, \"NodeCometTransport.Request.readFully()\", msg);\n          self2.complete(new PartialErrorInfo(msg, null, 400));\n          return;\n        }\n        if (statusCode < 400 || Array.isArray(body)) {\n          self2.complete(null, body);\n          return;\n        }\n        var err = body.error && ErrorInfo.fromValues(body.error);\n        if (!err) {\n          err = new PartialErrorInfo(\n            \"Error response received from server: \" + statusCode + \", body was: \" + import_util3.default.inspect(body),\n            null,\n            statusCode\n          );\n        }\n        self2.complete(err);\n      });\n    });\n  }\n  complete(err, body) {\n    if (!this.requestComplete) {\n      this.requestComplete = true;\n      if (body)\n        this.emit(\"data\", body);\n      this.emit(\"complete\", err, body);\n      if (err) {\n        if (this.ondata && !this.streamComplete) {\n          if (this.ondata && this.res)\n            this.res.removeListener(\"data\", this.ondata);\n        }\n      }\n      if (this.transport) {\n        this.transport.removePending();\n      }\n    }\n  }\n  abort() {\n    logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"NodeCometTransport.Request.abort()\", \"\");\n    var timer = this.timer;\n    if (timer) {\n      clearTimeout(timer);\n      this.timer = null;\n    }\n    var req = this.req;\n    if (req) {\n      logger_default.logAction(this.logger, logger_default.LOG_MINOR, \"NodeCometTransport.Request.abort()\", \"aborting request\");\n      req.removeListener(\"error\", this.onReqError);\n      req.on(\"error\", noop3);\n      req.abort();\n      this.req = null;\n    }\n    this.complete({ statusCode: 400, code: 80003, message: \"Cancelled\" });\n  }\n};\nvar nodecomettransport_default = NodeCometTransport;\n\n// src/platform/nodejs/lib/transport/index.ts\nvar transport_default2 = {\n  order: [TransportNames.Comet],\n  bundledImplementations: {\n    [TransportNames.WebSocket]: websockettransport_default,\n    [TransportNames.Comet]: nodecomettransport_default\n  }\n};\n\n// src/platform/nodejs/lib/util/defaults.ts\nvar Defaults2 = {\n  connectivityCheckUrl: \"https://internet-up.ably-realtime.com/is-the-internet-up.txt\",\n  wsConnectivityCheckUrl: \"wss://ws-up.ably-realtime.com\",\n  /* Note: order matters here: the base transport is the leftmost one in the\n   * intersection of baseTransportOrder and the transports clientOption that's supported. */\n  defaultTransports: [TransportNames.WebSocket],\n  restAgentOptions: { maxSockets: 40, keepAlive: true }\n};\nvar defaults_default2 = Defaults2;\n\n// src/platform/nodejs/index.ts\nvar msgpack = require_msgpack();\nvar Crypto = createCryptoClass(bufferutils_default);\nPlatform.Crypto = Crypto;\nPlatform.BufferUtils = bufferutils_default;\nPlatform.Http = http_default;\nPlatform.Config = config_default;\nPlatform.Transports = transport_default2;\nPlatform.WebStorage = null;\nfor (const clientClass of [DefaultRest, DefaultRealtime]) {\n  clientClass.Crypto = Crypto;\n  clientClass._MsgPack = msgpack;\n}\nlogger_default.initLogHandlers();\nPlatform.Defaults = getDefaults(defaults_default2);\nif (Platform.Config.agent) {\n  Platform.Defaults.agent += \" \" + Platform.Config.agent;\n}\nmodule.exports = {\n  ErrorInfo,\n  Rest: DefaultRest,\n  Realtime: DefaultRealtime,\n  msgpack: null,\n  protocolMessageFromDeserialized: fromDeserializedIncludingDependencies\n};\nif (typeof module.exports == \"object\" && typeof exports == \"object\") {\n  var __cp = (to, from, except, desc) => {\n    if ((from && typeof from === \"object\") || typeof from === \"function\") {\n      for (let key of Object.getOwnPropertyNames(from)) {\n        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)\n        Object.defineProperty(to, key, {\n          get: () => from[key],\n          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,\n        });\n      }\n    }\n    return to;\n  };\n  module.exports = __cp(module.exports, exports);\n}\nreturn module.exports;\n}))\n//# sourceMappingURL=ably-node.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9idWlsZC9hYmx5LW5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBdUQ7QUFDL0QseUJBQXlCLG1CQUFPLENBQUMsOERBQUksR0FBRyxtQkFBTyxDQUFDLDBEQUFLO0FBQ3JELE1BQU0sS0FBSyxFQU1OO0FBQ0wsR0FBRztBQUNIO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQXdCO0FBQzFDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQXdCO0FBQzFDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGtCQUFrQixtQ0FBbUMsT0FBTztBQUN2STtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsa0JBQWtCLHNDQUFzQyxPQUFPO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGtCQUFrQixzQ0FBc0MsT0FBTztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxrQkFBa0Isc0NBQXNDLE9BQU87QUFDMUk7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYSx5REFBeUQsSUFBSTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRLHlDQUF5QyxRQUFRLHVDQUF1QyxRQUFRLGdCQUFnQixRQUFRO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVLGNBQWMsUUFBUSxrQ0FBa0MsUUFBUSx1Q0FBdUMsUUFBUSxnQkFBZ0IsUUFBUTtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9RQUFvUSx3QkFBd0I7QUFDNVI7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELG1CQUFtQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxjQUFjO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyUUFBMlEsUUFBUTtBQUNuUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0NBQStDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9OQUFvTixRQUFRO0FBQzVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrVEFBa1QsUUFBUTtBQUMxVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxtQkFBbUIsd0NBQXdDO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwrREFBK0Q7QUFDckUsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUNBQXFDLENBQVU7QUFDaEU7QUFDQTtBQUNBLDRCQUE0Qix1Q0FBdUM7QUFDbkU7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUtBQWlLO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQ0FBZ0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSSxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQscUNBQXFDLDRCQUE0QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNERBQTREO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QjtBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFD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QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFxRDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsb0JBQW9CO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RCxNQUFNO0FBQ04seUJBQXlCLDZCQUE2QjtBQUN0RCxNQUFNO0FBQ04sMkVBQTJFO0FBQzNFO0FBQ0EseUJBQXlCLDZEQUE2RDtBQUN0RixNQUFNO0FBQ047QUFDQTtBQUNBLHlCQUF5Qix5RUFBeUU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU8sRUFBRSxxQkFBcUIsR0FBRyxrQkFBa0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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cEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdJQUFnSTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsa0JBQU07QUFDekMsNEJBQTRCLG1CQUFPLENBQUMsb0JBQU87QUFDM0MseUJBQXlCLG1CQUFPLENBQUMsZ0JBQUs7QUFDdEMsMkJBQTJCLG1CQUFPLENBQUMsa0JBQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBCQUEwQixzQ0FBc0MsNEJBQTRCO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGlCQUFpQjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxIYWNrYXRob25cXEhhY2tzcGlyZVxcbm9kZV9tb2R1bGVzXFxhYmx5XFxidWlsZFxcYWJseS1ub2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMTUtMjAyMiBBYmx5IFJlYWwtdGltZSBMdGQgKGFibHkuY29tKVxuXG5BYmx5IEphdmFTY3JpcHQgTGlicmFyeSB2Mi43LjBcbmh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanNcblxuUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbmNlIHYyLjAqLyhmdW5jdGlvbiAoZywgZikge1xuICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZSkge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmKHJlcXVpcmUoJ3dzJyksIHJlcXVpcmUoJ2dvdCcpKTtcbiAgICB9IGVsc2UgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIGRlZmluZShbJ3dzJywgJ2dvdCddLCBmKTtcbiAgICB9IGVsc2UgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHNbXCJBYmx5XCJdID0gZihyZXF1aXJlKCd3cycpLCByZXF1aXJlKCdnb3QnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdbXCJBYmx5XCJdID0gZihnW1wid3NcIl0sIGdbXCJnb3RcIl0pO1xuICAgIH1cbiAgfSh0aGlzLCAoX19kYSwgX19kYikgPT4ge1xudmFyIGV4cG9ydHMgPSB7fTtcbnZhciBtb2R1bGUgPSB7IGV4cG9ydHMgfTtcblwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fb2JqUmVzdCA9IChzb3VyY2UsIGV4Y2x1ZGUpID0+IHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSAmJiBleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBpZiAoc291cmNlICE9IG51bGwgJiYgX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKSkge1xuICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDAgJiYgX19wcm9wSXNFbnVtLmNhbGwoc291cmNlLCBwcm9wKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ib3BzL2Zyb20uanNcbnZhciByZXF1aXJlX2Zyb20gPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy9mcm9tLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICB2YXIgQnVmZmVyMiA9IHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgIHZhciB2ZXJzaW9uMiA9ICgocHJvY2VzcyB8fCB7fSkudmVyc2lvbiB8fCBcInYwLjAuMFwiKS5zbGljZSgxKS5zcGxpdChcIi5cIilbMF07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gTnVtYmVyKHZlcnNpb24yKSA8IDYgPyBmdW5jdGlvbiBmcm9tKHNvdXJjZSwgZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyMihzb3VyY2UsIGVuY29kaW5nKTtcbiAgICB9IDogZnVuY3Rpb24gZnJvbShzb3VyY2UsIGVuY29kaW5nKSB7XG4gICAgICByZXR1cm4gQnVmZmVyMi5mcm9tKHNvdXJjZSwgZW5jb2RpbmcpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy90by5qc1xudmFyIHJlcXVpcmVfdG8gPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy90by5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24oc291cmNlLCBlbmNvZGluZykge1xuICAgICAgcmV0dXJuIHNvdXJjZS50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ib3BzL2lzLmpzXG52YXIgcmVxdWlyZV9pcyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9ib3BzL2lzLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICB2YXIgQnVmZmVyMiA9IHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIEJ1ZmZlcjIuaXNCdWZmZXIoYnVmZmVyKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2JvcHMvc3ViYXJyYXkuanNcbnZhciByZXF1aXJlX3N1YmFycmF5ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2JvcHMvc3ViYXJyYXkuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKHNvdXJjZSwgZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAyID8gc291cmNlLnNsaWNlKGZyb20pIDogc291cmNlLnNsaWNlKGZyb20sIHRvKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2JvcHMvam9pbi5qc1xudmFyIHJlcXVpcmVfam9pbiA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9ib3BzL2pvaW4uanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIHZhciBCdWZmZXIyID0gcmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0cywgaGludCkge1xuICAgICAgcmV0dXJuIGhpbnQgIT09IHZvaWQgMCA/IEJ1ZmZlcjIuY29uY2F0KHRhcmdldHMsIGhpbnQpIDogQnVmZmVyMi5jb25jYXQodGFyZ2V0cyk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ib3BzL2NvcHkuanNcbnZhciByZXF1aXJlX2NvcHkgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYm9wcy9jb3B5LmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBjb3B5MjtcbiAgICBmdW5jdGlvbiBjb3B5Mihzb3VyY2UsIHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzb3VyY2Vfc3RhcnQsIHNvdXJjZV9lbmQpIHtcbiAgICAgIHJldHVybiBzb3VyY2UuY29weSh0YXJnZXQsIHRhcmdldF9zdGFydCwgc291cmNlX3N0YXJ0LCBzb3VyY2VfZW5kKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy9jcmVhdGUuanNcbnZhciByZXF1aXJlX2NyZWF0ZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9ib3BzL2NyZWF0ZS5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgdmFyIEJ1ZmZlcjIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICB2YXIgdmVyc2lvbjIgPSAoKHByb2Nlc3MgfHwge30pLnZlcnNpb24gfHwgXCJ2MC4wLjBcIikuc2xpY2UoMSkuc3BsaXQoXCIuXCIpWzBdO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IE51bWJlcih2ZXJzaW9uMikgPCA2ID8gZnVuY3Rpb24gY3JlYXRlKHNpemUpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyMihzaXplKTtcbiAgICB9IDogZnVuY3Rpb24gY3JlYXRlKHNpemUpIHtcbiAgICAgIHJldHVybiBCdWZmZXIyLmFsbG9jKHNpemUpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYm9wcy9yZWFkLmpzXG52YXIgcmVxdWlyZV9yZWFkID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2JvcHMvcmVhZC5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgdmFyIHByb3RvID0ge307XG4gICAgdmFyIHJleCA9IC9yZWFkLisvO1xuICAgIHZhciBidWlsZEZuO1xuICAgIGJ1aWxkRm4gPSBmdW5jdGlvbihrZXkyKSB7XG4gICAgICB2YXIgY29kZSA9IFwicmV0dXJuIGJ1Zi5cIiArIGtleTIgKyBcIihcIiArIFtcImFcIiwgXCJiXCIsIFwiY1wiXS5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihbXCJidWZcIiwgXCJhXCIsIFwiYlwiLCBcImNcIl0sIGNvZGUpO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcHJvdG87XG4gICAgZm9yIChrZXkgaW4gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgaWYgKHJleC50ZXN0KGtleSkpIHtcbiAgICAgICAgcHJvdG9ba2V5XSA9IGJ1aWxkRm4oa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGtleTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ib3BzL3dyaXRlLmpzXG52YXIgcmVxdWlyZV93cml0ZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9ib3BzL3dyaXRlLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICB2YXIgQnVmZmVyMiA9IHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgIHZhciBwcm90byA9IHt9O1xuICAgIHZhciByZXggPSAvd3JpdGUuKy87XG4gICAgdmFyIGJ1aWxkRm47XG4gICAgYnVpbGRGbiA9IGZ1bmN0aW9uKGtleTIpIHtcbiAgICAgIHZhciBjb2RlID0gXCJyZXR1cm4gYnVmLlwiICsga2V5MiArIFwiKFwiICsgW1wiYVwiLCBcImJcIiwgXCJjXCJdLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFtcImJ1ZlwiLCBcImFcIiwgXCJiXCIsIFwiY1wiXSwgY29kZSk7XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBwcm90bztcbiAgICBmb3IgKGtleSBpbiBCdWZmZXIyLnByb3RvdHlwZSkge1xuICAgICAgaWYgKHJleC50ZXN0KGtleSkpIHtcbiAgICAgICAgcHJvdG9ba2V5XSA9IGJ1aWxkRm4oa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGtleTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ib3BzL2luZGV4LmpzXG52YXIgcmVxdWlyZV9ib3BzID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2JvcHMvaW5kZXguanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIHZhciBwcm90byA9IHt9O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHByb3RvO1xuICAgIHByb3RvLmZyb20gPSByZXF1aXJlX2Zyb20oKTtcbiAgICBwcm90by50byA9IHJlcXVpcmVfdG8oKTtcbiAgICBwcm90by5pcyA9IHJlcXVpcmVfaXMoKTtcbiAgICBwcm90by5zdWJhcnJheSA9IHJlcXVpcmVfc3ViYXJyYXkoKTtcbiAgICBwcm90by5qb2luID0gcmVxdWlyZV9qb2luKCk7XG4gICAgcHJvdG8uY29weSA9IHJlcXVpcmVfY29weSgpO1xuICAgIHByb3RvLmNyZWF0ZSA9IHJlcXVpcmVfY3JlYXRlKCk7XG4gICAgbWl4KHJlcXVpcmVfcmVhZCgpLCBwcm90byk7XG4gICAgbWl4KHJlcXVpcmVfd3JpdGUoKSwgcHJvdG8pO1xuICAgIGZ1bmN0aW9uIG1peChmcm9tLCBpbnRvKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgICBpbnRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BhYmx5L21zZ3BhY2stanMvbXNncGFjay5qc1xudmFyIHJlcXVpcmVfbXNncGFjayA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9AYWJseS9tc2dwYWNrLWpzL21zZ3BhY2suanNcIihleHBvcnRzMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBib3BzID0gcmVxdWlyZV9ib3BzKCk7XG4gICAgZXhwb3J0czIuZW5jb2RlID0gZnVuY3Rpb24odmFsdWUsIHNwYXJzZSkge1xuICAgICAgdmFyIHNpemUgPSBzaXplb2YodmFsdWUsIHNwYXJzZSk7XG4gICAgICBpZiAoc2l6ZSA9PSAwKVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgdmFyIGJ1ZmZlciA9IGJvcHMuY3JlYXRlKHNpemUpO1xuICAgICAgZW5jb2RlMih2YWx1ZSwgYnVmZmVyLCAwLCBzcGFyc2UpO1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9O1xuICAgIGV4cG9ydHMyLmRlY29kZSA9IGRlY29kZTI7XG4gICAgdmFyIFNIX0xfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNik7XG4gICAgdmFyIFNIX1JfMzIgPSAxIC8gU0hfTF8zMjtcbiAgICBmdW5jdGlvbiByZWFkSW50NjRCRShidWYsIG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICByZXR1cm4gYnVmLnJlYWRJbnQzMkJFKG9mZnNldCArIDApICogU0hfTF8zMiArIGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0ICsgNCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRVSW50NjRCRShidWYsIG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MzJCRShvZmZzZXQgKyAwKSAqIFNIX0xfMzIgKyBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUludDY0QkUoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgICAgaWYgKHZhbCA8IDkyMjMzNzIwMzY4NTQ3NzZlMykge1xuICAgICAgICBidWYud3JpdGVJbnQzMkJFKE1hdGguZmxvb3IodmFsICogU0hfUl8zMiksIG9mZnNldCk7XG4gICAgICAgIGJ1Zi53cml0ZUludDMyQkUodmFsICYgLTEsIG9mZnNldCArIDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmLndyaXRlVUludDMyQkUoMjE0NzQ4MzY0Nywgb2Zmc2V0KTtcbiAgICAgICAgYnVmLndyaXRlVUludDMyQkUoNDI5NDk2NzI5NSwgb2Zmc2V0ICsgNCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlVUludDY0QkUoYnVmLCB2YWwsIG9mZnNldCkge1xuICAgICAgaWYgKHZhbCA8IDE4NDQ2NzQ0MDczNzA5NTUyZTMpIHtcbiAgICAgICAgYnVmLndyaXRlVUludDMyQkUoTWF0aC5mbG9vcih2YWwgKiBTSF9SXzMyKSwgb2Zmc2V0KTtcbiAgICAgICAgYnVmLndyaXRlSW50MzJCRSh2YWwgJiAtMSwgb2Zmc2V0ICsgNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYud3JpdGVVSW50MzJCRSg0Mjk0OTY3Mjk1LCBvZmZzZXQpO1xuICAgICAgICBidWYud3JpdGVVSW50MzJCRSg0Mjk0OTY3Mjk1LCBvZmZzZXQgKyA0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gRGVjb2RlcihidWZmZXIsIG9mZnNldCkge1xuICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgdGhpcy5idWZmZXJMZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICBEZWNvZGVyLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggKiAyID4gdGhpcy5idWZmZXJMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtYWxmb3JtZWQgbWVzc2FnZXBhY2sgZGV0ZWN0ZWQ6IGJ1ZmZlciBzaXplIHdhcyAke3RoaXMuYnVmZmVyTGVuZ3RofSwgYnV0IHJlZmVyZW5jZWQgYSBtYXAgb2YgbGVuZ3RoICR7bGVuZ3RofSlgKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5wYXJzZSgpO1xuICAgICAgICB2YWx1ZVtrZXldID0gdGhpcy5wYXJzZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgRGVjb2Rlci5wcm90b3R5cGUuYmluID0gRGVjb2Rlci5wcm90b3R5cGUuYnVmID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoID4gdGhpcy5idWZmZXJMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtYWxmb3JtZWQgbWVzc2FnZXBhY2sgZGV0ZWN0ZWQ6IGJ1ZmZlciBzaXplIHdhcyAke3RoaXMuYnVmZmVyTGVuZ3RofSwgYnV0IHJlZmVyZW5jZWQgYSBiaW5hcnkgb2YgbGVuZ3RoICR7bGVuZ3RofSlgKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGJvcHMuc3ViYXJyYXkodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIGxlbmd0aCk7XG4gICAgICB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5zdHIgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPiB0aGlzLmJ1ZmZlckxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1hbGZvcm1lZCBtZXNzYWdlcGFjayBkZXRlY3RlZDogYnVmZmVyIHNpemUgd2FzICR7dGhpcy5idWZmZXJMZW5ndGh9LCBidXQgcmVmZXJlbmNlZCBhIHN0cmluZyBvZiBsZW5ndGggJHtsZW5ndGh9KWApO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYm9wcy50byhib3BzLnN1YmFycmF5KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBsZW5ndGgpKTtcbiAgICAgIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIERlY29kZXIucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoID4gdGhpcy5idWZmZXJMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtYWxmb3JtZWQgbWVzc2FnZXBhY2sgZGV0ZWN0ZWQ6IGJ1ZmZlciBzaXplIHdhcyAke3RoaXMuYnVmZmVyTGVuZ3RofSwgYnV0IHJlZmVyZW5jZWQgYW4gYXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3RofSlgKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZVtpXSA9IHRoaXMucGFyc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIERlY29kZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMuYnVmZmVyW3RoaXMub2Zmc2V0XTtcbiAgICAgIHZhciB2YWx1ZSwgbGVuZ3RoLCBleHRUeXBlO1xuICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYWxmb3JtZWQgbWVzc2FnZXBhY2sgKHJlZmVyZW5jZWQgb2Zmc2V0IGlzIG91dHNpZGUgYnVmZmVyKVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICgodHlwZSAmIDEyOCkgPT09IDApIHtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAyNDApID09PSAxMjgpIHtcbiAgICAgICAgbGVuZ3RoID0gdHlwZSAmIDE1O1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmICgodHlwZSAmIDI0MCkgPT09IDE0NCkge1xuICAgICAgICBsZW5ndGggPSB0eXBlICYgMTU7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5KGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgJiAyMjQpID09PSAxNjApIHtcbiAgICAgICAgbGVuZ3RoID0gdHlwZSAmIDMxO1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHIobGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmICgodHlwZSAmIDIyNCkgPT09IDIyNCkge1xuICAgICAgICB2YWx1ZSA9IGJvcHMucmVhZEludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgMTkyOlxuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgMTk0OlxuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlIDE5NTpcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIDE5NjpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50OCh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgIHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xuICAgICAgICBjYXNlIDE5NzpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MTZCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xuICAgICAgICBjYXNlIDE5ODpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MzJCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgIHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xuICAgICAgICBjYXNlIDE5OTpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50OCh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICBleHRUeXBlID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMik7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICByZXR1cm4gW2V4dFR5cGUsIHRoaXMuYmluKGxlbmd0aCldO1xuICAgICAgICBjYXNlIDIwMDpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MTZCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICBleHRUeXBlID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMyk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgICByZXR1cm4gW2V4dFR5cGUsIHRoaXMuYmluKGxlbmd0aCldO1xuICAgICAgICBjYXNlIDIwMTpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MzJCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICBleHRUeXBlID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgNSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNjtcbiAgICAgICAgICByZXR1cm4gW2V4dFR5cGUsIHRoaXMuYmluKGxlbmd0aCldO1xuICAgICAgICBjYXNlIDIwMjpcbiAgICAgICAgICB2YWx1ZSA9IGJvcHMucmVhZEZsb2F0QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjAzOlxuICAgICAgICAgIHZhbHVlID0gYm9wcy5yZWFkRG91YmxlQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gOTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgIHZhbHVlID0gdGhpcy5idWZmZXJbdGhpcy5vZmZzZXQgKyAxXTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAyMDU6XG4gICAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRVSW50MTZCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAyMDY6XG4gICAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRVSW50MzJCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAyMDc6XG4gICAgICAgICAgdmFsdWUgPSByZWFkVUludDY0QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gOTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjA4OlxuICAgICAgICAgIHZhbHVlID0gYm9wcy5yZWFkSW50OCh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAyMDk6XG4gICAgICAgICAgdmFsdWUgPSBib3BzLnJlYWRJbnQxNkJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIDIxMDpcbiAgICAgICAgICB2YWx1ZSA9IGJvcHMucmVhZEludDMyQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjExOlxuICAgICAgICAgIHZhbHVlID0gcmVhZEludDY0QkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gOTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgMjEyOlxuICAgICAgICAgIGV4dFR5cGUgPSBib3BzLnJlYWRVSW50OCh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB2YWx1ZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDIpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIGV4dFR5cGUgPT09IDAgJiYgdmFsdWUgPT09IDAgPyB2b2lkIDAgOiBbZXh0VHlwZSwgdmFsdWVdO1xuICAgICAgICBjYXNlIDIxMzpcbiAgICAgICAgICBleHRUeXBlID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gW2V4dFR5cGUsIHRoaXMuYmluKDIpXTtcbiAgICAgICAgY2FzZSAyMTQ6XG4gICAgICAgICAgZXh0VHlwZSA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIFtleHRUeXBlLCB0aGlzLmJpbig0KV07XG4gICAgICAgIGNhc2UgMjE1OlxuICAgICAgICAgIGV4dFR5cGUgPSBib3BzLnJlYWRVSW50OCh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgIHJldHVybiBbZXh0VHlwZSwgdGhpcy5iaW4oOCldO1xuICAgICAgICBjYXNlIDIxNjpcbiAgICAgICAgICBleHRUeXBlID0gYm9wcy5yZWFkVUludDgodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICByZXR1cm4gW2V4dFR5cGUsIHRoaXMuYmluKDE2KV07XG4gICAgICAgIGNhc2UgMjE3OlxuICAgICAgICAgIGxlbmd0aCA9IGJvcHMucmVhZFVJbnQ4KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjE4OlxuICAgICAgICAgIGxlbmd0aCA9IGJvcHMucmVhZFVJbnQxNkJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjE5OlxuICAgICAgICAgIGxlbmd0aCA9IGJvcHMucmVhZFVJbnQzMkJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG4gICAgICAgIGNhc2UgMjIwOlxuICAgICAgICAgIGxlbmd0aCA9IGJvcHMucmVhZFVJbnQxNkJFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyMjE6XG4gICAgICAgICAgbGVuZ3RoID0gYm9wcy5yZWFkVUludDMyQkUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hcnJheShsZW5ndGgpO1xuICAgICAgICBjYXNlIDIyMjpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MTZCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hcChsZW5ndGgpO1xuICAgICAgICBjYXNlIDIyMzpcbiAgICAgICAgICBsZW5ndGggPSBib3BzLnJlYWRVSW50MzJCRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hcChsZW5ndGgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIDB4XCIgKyB0eXBlLnRvU3RyaW5nKDE2KSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkZWNvZGUyKGJ1ZmZlcikge1xuICAgICAgdmFyIGRlY29kZXIgPSBuZXcgRGVjb2RlcihidWZmZXIpO1xuICAgICAgdmFyIHZhbHVlID0gZGVjb2Rlci5wYXJzZSgpO1xuICAgICAgaWYgKGRlY29kZXIub2Zmc2V0ICE9PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYnVmZmVyLmxlbmd0aCAtIGRlY29kZXIub2Zmc2V0ICsgXCIgdHJhaWxpbmcgYnl0ZXNcIik7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHZhbCA9IHZhbHVlW2VdLCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgICAgICAgcmV0dXJuICghc3BhcnNlIHx8IHZhbCAhPT0gdm9pZCAwICYmIHZhbCAhPT0gbnVsbCkgJiYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZSB8fCAhIXZhbC50b0pTT04pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZTIodmFsdWUsIGJ1ZmZlciwgb2Zmc2V0LCBzcGFyc2UsIGlzTWFwRWxlbWVudCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICB2YXIgbGVuZ3RoLCBzaXplO1xuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBib3BzLmZyb20odmFsdWUpO1xuICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCAzMikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gbGVuZ3RoIHwgMTYwO1xuICAgICAgICAgIGJvcHMuY29weSh2YWx1ZSwgYnVmZmVyLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICByZXR1cm4gMSArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgMjU2KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMTc7XG4gICAgICAgICAgYm9wcy53cml0ZVVJbnQ4KGJ1ZmZlciwgbGVuZ3RoLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICBib3BzLmNvcHkodmFsdWUsIGJ1ZmZlciwgb2Zmc2V0ICsgMik7XG4gICAgICAgICAgcmV0dXJuIDIgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDY1NTM2KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMTg7XG4gICAgICAgICAgYm9wcy53cml0ZVVJbnQxNkJFKGJ1ZmZlciwgbGVuZ3RoLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICBib3BzLmNvcHkodmFsdWUsIGJ1ZmZlciwgb2Zmc2V0ICsgMyk7XG4gICAgICAgICAgcmV0dXJuIDMgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDQyOTQ5NjcyOTYpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDIxOTtcbiAgICAgICAgICBib3BzLndyaXRlVUludDMyQkUoYnVmZmVyLCBsZW5ndGgsIG9mZnNldCArIDEpO1xuICAgICAgICAgIGJvcHMuY29weSh2YWx1ZSwgYnVmZmVyLCBvZmZzZXQgKyA1KTtcbiAgICAgICAgICByZXR1cm4gNSArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJvcHMuaXModmFsdWUpKSB7XG4gICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDI1Nikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMTk2O1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50OChidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgYm9wcy5jb3B5KHZhbHVlLCBidWZmZXIsIG9mZnNldCArIDIpO1xuICAgICAgICAgIHJldHVybiAyICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMTk3O1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50MTZCRShidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgYm9wcy5jb3B5KHZhbHVlLCBidWZmZXIsIG9mZnNldCArIDMpO1xuICAgICAgICAgIHJldHVybiAzICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAxOTg7XG4gICAgICAgICAgYm9wcy53cml0ZVVJbnQzMkJFKGJ1ZmZlciwgbGVuZ3RoLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICBib3BzLmNvcHkodmFsdWUsIGJ1ZmZlciwgb2Zmc2V0ICsgNSk7XG4gICAgICAgICAgcmV0dXJuIDUgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDIwMztcbiAgICAgICAgICBib3BzLndyaXRlRG91YmxlQkUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgICBpZiAodmFsdWUgPCAxMjgpIHtcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIDwgMjU2KSB7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDIwNDtcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAxXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA8IDY1NTM2KSB7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDIwNTtcbiAgICAgICAgICAgIGJvcHMud3JpdGVVSW50MTZCRShidWZmZXIsIHZhbHVlLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgICAgICAgICAgIGJvcHMud3JpdGVVSW50MzJCRShidWZmZXIsIHZhbHVlLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPCAxODQ0Njc0NDA3MzcwOTU1MmUzKSB7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDIwNztcbiAgICAgICAgICAgIHdyaXRlVUludDY0QkUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBiaWcgMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID49IC0zMikge1xuICAgICAgICAgIGJvcHMud3JpdGVJbnQ4KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCk7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID49IC0xMjgpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDIwODtcbiAgICAgICAgICBib3BzLndyaXRlSW50OChidWZmZXIsIHZhbHVlLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPj0gLTMyNzY4KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMDk7XG4gICAgICAgICAgYm9wcy53cml0ZUludDE2QkUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID49IC0yMTQ3NDgzNjQ4KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAyMTA7XG4gICAgICAgICAgYm9wcy53cml0ZUludDMyQkUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID49IC05MjIzMzcyMDM2ODU0Nzc2ZTMpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDIxMTtcbiAgICAgICAgICB3cml0ZUludDY0QkUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBzbWFsbCAtMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHNwYXJzZSAmJiBpc01hcEVsZW1lbnQpXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMjEyO1xuICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSAwO1xuICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMl0gPSAwO1xuICAgICAgICByZXR1cm4gMztcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoc3BhcnNlICYmIGlzTWFwRWxlbWVudClcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgYnVmZmVyW29mZnNldF0gPSAxOTI7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gdmFsdWUgPyAxOTUgOiAxOTQ7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlLnRvSlNPTilcbiAgICAgICAgcmV0dXJuIGVuY29kZTIodmFsdWUudG9KU09OKCksIGJ1ZmZlciwgb2Zmc2V0LCBzcGFyc2UpO1xuICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgc2l6ZSA9IDA7XG4gICAgICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBrZXlzID0gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSk7XG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDE2KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSBsZW5ndGggfCAoaXNBcnJheSA/IDE0NCA6IDEyOCk7XG4gICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IGlzQXJyYXkgPyAyMjAgOiAyMjI7XG4gICAgICAgICAgYm9wcy53cml0ZVVJbnQxNkJFKGJ1ZmZlciwgbGVuZ3RoLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICBzaXplID0gMztcbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSBpc0FycmF5ID8gMjIxIDogMjIzO1xuICAgICAgICAgIGJvcHMud3JpdGVVSW50MzJCRShidWZmZXIsIGxlbmd0aCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgc2l6ZSA9IDU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzaXplICs9IGVuY29kZTIodmFsdWVbaV0sIGJ1ZmZlciwgb2Zmc2V0ICsgc2l6ZSwgc3BhcnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBzaXplICs9IGVuY29kZTIoa2V5LCBidWZmZXIsIG9mZnNldCArIHNpemUpO1xuICAgICAgICAgICAgc2l6ZSArPSBlbmNvZGUyKHZhbHVlW2tleV0sIGJ1ZmZlciwgb2Zmc2V0ICsgc2l6ZSwgc3BhcnNlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIFwiICsgdHlwZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpemVvZih2YWx1ZSwgc3BhcnNlLCBpc01hcEVsZW1lbnQpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgdmFyIGxlbmd0aCwgc2l6ZTtcbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxlbmd0aCA9IGJvcHMuZnJvbSh2YWx1ZSkubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMzIpIHtcbiAgICAgICAgICByZXR1cm4gMSArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgMjU2KSB7XG4gICAgICAgICAgcmV0dXJuIDIgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDY1NTM2KSB7XG4gICAgICAgICAgcmV0dXJuIDMgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDQyOTQ5NjcyOTYpIHtcbiAgICAgICAgICByZXR1cm4gNSArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJvcHMuaXModmFsdWUpKSB7XG4gICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDI1Nikge1xuICAgICAgICAgIHJldHVybiAyICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgICAgIHJldHVybiAzICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgICAgcmV0dXJuIDUgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgMjU2KVxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgNjU1MzYpXG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICBpZiAodmFsdWUgPCA0Mjk0OTY3Mjk2KVxuICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgMTg0NDY3NDQwNzM3MDk1NTJlMylcbiAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gYmlnIDB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMzIpXG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMTI4KVxuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBpZiAodmFsdWUgPj0gLTMyNzY4KVxuICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICBpZiAodmFsdWUgPj0gLTIxNDc0ODM2NDgpXG4gICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtOTIyMzM3MjAzNjg1NDc3NmUzKVxuICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIHNtYWxsIC0weFwiICsgdmFsdWUudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICByZXR1cm4gc3BhcnNlICYmIGlzTWFwRWxlbWVudCA/IDAgOiAxO1xuICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiBzcGFyc2UgJiYgaXNNYXBFbGVtZW50ID8gMCA6IDM7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUudG9KU09OKVxuICAgICAgICByZXR1cm4gc2l6ZW9mKHZhbHVlLnRvSlNPTigpLCBzcGFyc2UpO1xuICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgc2l6ZSA9IDA7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzaXplICs9IHNpemVvZih2YWx1ZVtpXSwgc3BhcnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGtleXMgPSBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKTtcbiAgICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHNpemUgKz0gc2l6ZW9mKGtleSkgKyBzaXplb2YodmFsdWVba2V5XSwgc3BhcnNlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDE2KSB7XG4gICAgICAgICAgcmV0dXJuIDEgKyBzaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA2NTUzNikge1xuICAgICAgICAgIHJldHVybiAzICsgc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNDI5NDk2NzI5Nikge1xuICAgICAgICAgIHJldHVybiA1ICsgc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheSBvciBvYmplY3QgdG9vIGxvbmcgMHhcIiArIGxlbmd0aC50b1N0cmluZygxNikpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIgKyB0eXBlKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBzcmMvY29tbW9uL3BsYXRmb3JtLnRzXG52YXIgUGxhdGZvcm0gPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi91dGlsL2xvZ2dlci50c1xudmFyIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogc2VsZjtcbmZ1bmN0aW9uIHBhZCh0aW1lU2VnbWVudCwgdGhyZWUpIHtcbiAgcmV0dXJuIGAke3RpbWVTZWdtZW50fWAucGFkU3RhcnQodGhyZWUgPyAzIDogMiwgXCIwXCIpO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlcihsb2dnZXIpIHtcbiAgcmV0dXJuIFBsYXRmb3JtLkNvbmZpZy5sb2dUaW1lc3RhbXBzID8gZnVuY3Rpb24obXNnKSB7XG4gICAgY29uc3QgdGltZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGxvZ2dlcihcbiAgICAgIHBhZCh0aW1lLmdldEhvdXJzKCkpICsgXCI6XCIgKyBwYWQodGltZS5nZXRNaW51dGVzKCkpICsgXCI6XCIgKyBwYWQodGltZS5nZXRTZWNvbmRzKCkpICsgXCIuXCIgKyBwYWQodGltZS5nZXRNaWxsaXNlY29uZHMoKSwgMSkgKyBcIiBcIiArIG1zZ1xuICAgICk7XG4gIH0gOiBmdW5jdGlvbihtc2cpIHtcbiAgICBsb2dnZXIobXNnKTtcbiAgfTtcbn1cbnZhciBnZXREZWZhdWx0TG9nZ2VycyA9ICgpID0+IHtcbiAgdmFyIF9hMjtcbiAgbGV0IGNvbnNvbGVMb2dnZXI7XG4gIGxldCBlcnJvckxvZ2dlcjtcbiAgaWYgKHR5cGVvZiAoKF9hMiA9IGdsb2JhbE9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsT2JqZWN0LmNvbnNvbGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubG9nKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc29sZUxvZ2dlciA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH07XG4gICAgZXJyb3JMb2dnZXIgPSBjb25zb2xlLndhcm4gPyBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfSA6IGNvbnNvbGVMb2dnZXI7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZUxvZ2dlciA9IGVycm9yTG9nZ2VyID0gZnVuY3Rpb24oKSB7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gW2NvbnNvbGVMb2dnZXIsIGVycm9yTG9nZ2VyXS5tYXAoZ2V0SGFuZGxlcik7XG59O1xudmFyIF9Mb2dnZXIgPSBjbGFzcyBfTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kZXByZWNhdGVkID0gKGRlc2NyaXB0aW9uLCBtc2cpID0+IHtcbiAgICAgIHRoaXMuZGVwcmVjYXRpb25XYXJuaW5nKGAke2Rlc2NyaXB0aW9ufSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gJHttc2d9YCk7XG4gICAgfTtcbiAgICAvKiBXaGVyZSBhIGxvZ2dpbmcgb3BlcmF0aW9uIGlzIGV4cGVuc2l2ZSwgc3VjaCBhcyBzZXJpYWxpc2F0aW9uIG9mIGRhdGEsIHVzZSBzaG91bGRMb2cgd2lsbCBwcmV2ZW50XG4gICAgICB0aGUgb2JqZWN0IGJlaW5nIHNlcmlhbGlzZWQgaWYgdGhlIGxvZyBsZXZlbCB3aWxsIG5vdCBvdXRwdXQgdGhlIG1lc3NhZ2UgKi9cbiAgICB0aGlzLnNob3VsZExvZyA9IChsZXZlbCkgPT4ge1xuICAgICAgcmV0dXJuIGxldmVsIDw9IHRoaXMubG9nTGV2ZWw7XG4gICAgfTtcbiAgICB0aGlzLnNldExvZyA9IChsZXZlbCwgaGFuZGxlcikgPT4ge1xuICAgICAgaWYgKGxldmVsICE9PSB2b2lkIDApXG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSBsZXZlbDtcbiAgICAgIGlmIChoYW5kbGVyICE9PSB2b2lkIDApXG4gICAgICAgIHRoaXMubG9nSGFuZGxlciA9IHRoaXMubG9nRXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB9O1xuICAgIHRoaXMubG9nTGV2ZWwgPSBfTG9nZ2VyLmRlZmF1bHRMb2dMZXZlbDtcbiAgICB0aGlzLmxvZ0hhbmRsZXIgPSBfTG9nZ2VyLmRlZmF1bHRMb2dIYW5kbGVyO1xuICAgIHRoaXMubG9nRXJyb3JIYW5kbGVyID0gX0xvZ2dlci5kZWZhdWx0TG9nRXJyb3JIYW5kbGVyO1xuICB9XG4gIHN0YXRpYyBpbml0TG9nSGFuZGxlcnMoKSB7XG4gICAgY29uc3QgW2xvZ0hhbmRsZXIsIGxvZ0Vycm9ySGFuZGxlcl0gPSBnZXREZWZhdWx0TG9nZ2VycygpO1xuICAgIHRoaXMuZGVmYXVsdExvZ0hhbmRsZXIgPSBsb2dIYW5kbGVyO1xuICAgIHRoaXMuZGVmYXVsdExvZ0Vycm9ySGFuZGxlciA9IGxvZ0Vycm9ySGFuZGxlcjtcbiAgICB0aGlzLmRlZmF1bHRMb2dnZXIgPSBuZXcgX0xvZ2dlcigpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyB0byB0aGlzIG1ldGhvZCBhcmUgbmV2ZXIgc3RyaXBwZWQgYnkgdGhlIGBzdHJpcExvZ3NgIGVzYnVpbGQgcGx1Z2luLiBVc2UgaXQgZm9yIGxvZyBzdGF0ZW1lbnRzIHRoYXQgeW91IHdpc2ggdG8gYWx3YXlzIGJlIGluY2x1ZGVkIGluIHRoZSBtb2R1bGFyIHZhcmlhbnQgb2YgdGhlIFNESy5cbiAgICovXG4gIHN0YXRpYyBsb2dBY3Rpb25Ob1N0cmlwKGxvZ2dlciwgbGV2ZWwsIGFjdGlvbiwgbWVzc2FnZSkge1xuICAgIGxvZ2dlci5sb2dBY3Rpb24obGV2ZWwsIGFjdGlvbiwgbWVzc2FnZSk7XG4gIH1cbiAgbG9nQWN0aW9uKGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5zaG91bGRMb2cobGV2ZWwpKSB7XG4gICAgICAobGV2ZWwgPT09IDEgLyogRXJyb3IgKi8gPyB0aGlzLmxvZ0Vycm9ySGFuZGxlciA6IHRoaXMubG9nSGFuZGxlcikoXCJBYmx5OiBcIiArIGFjdGlvbiArIFwiOiBcIiArIG1lc3NhZ2UsIGxldmVsKTtcbiAgICB9XG4gIH1cbiAgcmVuYW1lZENsaWVudE9wdGlvbihvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgdGhpcy5kZXByZWNhdGlvbldhcm5pbmcoXG4gICAgICBgVGhlIFxcYCR7b2xkTmFtZX1cXGAgY2xpZW50IG9wdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYCR7bmV3TmFtZX1cXGAuIFBsZWFzZSB1cGRhdGUgeW91ciBjb2RlIHRvIHVzZSBcXGAke25ld05hbWV9XFxgIGluc3RlYWQuIFxcYCR7b2xkTmFtZX1cXGAgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uYFxuICAgICk7XG4gIH1cbiAgcmVuYW1lZE1ldGhvZChjbGFzc05hbWUsIG9sZE5hbWUsIG5ld05hbWUpIHtcbiAgICB0aGlzLmRlcHJlY2F0aW9uV2FybmluZyhcbiAgICAgIGBcXGAke2NsYXNzTmFtZX1cXGBcXHUyMDE5cyBcXGAke29sZE5hbWV9XFxgIG1ldGhvZCBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYCR7bmV3TmFtZX1cXGAuIFBsZWFzZSB1cGRhdGUgeW91ciBjb2RlIHRvIHVzZSBcXGAke25ld05hbWV9XFxgIGluc3RlYWQuIFxcYCR7b2xkTmFtZX1cXGAgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uYFxuICAgICk7XG4gIH1cbiAgZGVwcmVjYXRpb25XYXJuaW5nKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5zaG91bGRMb2coMSAvKiBFcnJvciAqLykpIHtcbiAgICAgIHRoaXMubG9nRXJyb3JIYW5kbGVyKGBBYmx5OiBEZXByZWNhdGlvbiB3YXJuaW5nIC0gJHttZXNzYWdlfWAsIDEgLyogRXJyb3IgKi8pO1xuICAgIH1cbiAgfVxufTtcbl9Mb2dnZXIuZGVmYXVsdExvZ0xldmVsID0gMSAvKiBFcnJvciAqLztcbi8vIHB1YmxpYyBjb25zdGFudHNcbl9Mb2dnZXIuTE9HX05PTkUgPSAwIC8qIE5vbmUgKi87XG5fTG9nZ2VyLkxPR19FUlJPUiA9IDEgLyogRXJyb3IgKi87XG5fTG9nZ2VyLkxPR19NQUpPUiA9IDIgLyogTWFqb3IgKi87XG5fTG9nZ2VyLkxPR19NSU5PUiA9IDMgLyogTWlub3IgKi87XG5fTG9nZ2VyLkxPR19NSUNSTyA9IDQgLyogTWljcm8gKi87XG4vKiBwdWJsaWMgc3RhdGljIGZ1bmN0aW9ucyAqL1xuLyoqXG4gKiBJbiB0aGUgbW9kdWxhciB2YXJpYW50IG9mIHRoZSBTREssIHRoZSBgc3RyaXBMb2dzYCBlc2J1aWxkIHBsdWdpbiBzdHJpcHMgb3V0IGFsbCBjYWxscyB0byB0aGlzIG1ldGhvZCAod2hlbiBpbnZva2VkIGFzIGBMb2dnZXIubG9nQWN0aW9uKC4uLilgKSBleGNlcHQgd2hlbiBjYWxsZWQgd2l0aCBsZXZlbCBgTG9nZ2VyLkxPR19FUlJPUmAuIElmIHlvdSB3aXNoIGZvciBhIGxvZyBzdGF0ZW1lbnQgdG8gbmV2ZXIgYmUgc3RyaXBwZWQsIHVzZSB0aGUge0BsaW5rIGxvZ0FjdGlvbk5vU3RyaXB9IG1ldGhvZCBpbnN0ZWFkLlxuICpcbiAqIFRoZSBhZm9yZW1lbnRpb25lZCBwbHVnaW4gZXhwZWN0cyBgbGV2ZWxgIHRvIGJlIGFuIGV4cHJlc3Npb24gb2YgdGhlIGZvcm0gYExvZ2dlci5MT0dfKmA7IHRoYXQgaXMsIHlvdSBjYW7igJl0IGR5bmFtaWNhbGx5IHNwZWNpZnkgdGhlIGxvZyBsZXZlbC5cbiAqL1xuX0xvZ2dlci5sb2dBY3Rpb24gPSAobG9nZ2VyLCBsZXZlbCwgYWN0aW9uLCBtZXNzYWdlKSA9PiB7XG4gIF9Mb2dnZXIubG9nQWN0aW9uTm9TdHJpcChsb2dnZXIsIGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpO1xufTtcbnZhciBMb2dnZXIgPSBfTG9nZ2VyO1xudmFyIGxvZ2dlcl9kZWZhdWx0ID0gTG9nZ2VyO1xuXG4vLyBzcmMvY29tbW9uL2xpYi91dGlsL3V0aWxzLnRzXG52YXIgdXRpbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbHNfZXhwb3J0cywge1xuICBGb3JtYXQ6ICgpID0+IEZvcm1hdCxcbiAgYWxsU2FtZTogKCkgPT4gYWxsU2FtZSxcbiAgYWxsVG9Mb3dlckNhc2U6ICgpID0+IGFsbFRvTG93ZXJDYXNlLFxuICBhbGxUb1VwcGVyQ2FzZTogKCkgPT4gYWxsVG9VcHBlckNhc2UsXG4gIGFyckNob29zZU46ICgpID0+IGFyckNob29zZU4sXG4gIGFyckRlbGV0ZVZhbHVlOiAoKSA9PiBhcnJEZWxldGVWYWx1ZSxcbiAgYXJyRXF1YWxzOiAoKSA9PiBhcnJFcXVhbHMsXG4gIGFyckludGVyc2VjdDogKCkgPT4gYXJySW50ZXJzZWN0LFxuICBhcnJJbnRlcnNlY3RPYjogKCkgPT4gYXJySW50ZXJzZWN0T2IsXG4gIGFyclBvcFJhbmRvbUVsZW1lbnQ6ICgpID0+IGFyclBvcFJhbmRvbUVsZW1lbnQsXG4gIGFyclN1YnRyYWN0OiAoKSA9PiBhcnJTdWJ0cmFjdCxcbiAgYXJyV2l0aG91dFZhbHVlOiAoKSA9PiBhcnJXaXRob3V0VmFsdWUsXG4gIGNoZWFwUmFuZFN0cjogKCkgPT4gY2hlYXBSYW5kU3RyLFxuICBjb250YWluc1ZhbHVlOiAoKSA9PiBjb250YWluc1ZhbHVlLFxuICBjb3B5OiAoKSA9PiBjb3B5LFxuICBjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3I6ICgpID0+IGNyZWF0ZU1pc3NpbmdQbHVnaW5FcnJvcixcbiAgZGF0YVNpemVCeXRlczogKCkgPT4gZGF0YVNpemVCeXRlcyxcbiAgZGVjb2RlQm9keTogKCkgPT4gZGVjb2RlQm9keSxcbiAgZW5jb2RlQm9keTogKCkgPT4gZW5jb2RlQm9keSxcbiAgZW5zdXJlQXJyYXk6ICgpID0+IGVuc3VyZUFycmF5LFxuICBmb3JJbk93bk5vbk51bGxQcm9wZXJ0aWVzOiAoKSA9PiBmb3JJbk93bk5vbk51bGxQcm9wZXJ0aWVzLFxuICBnZXRCYWNrb2ZmQ29lZmZpY2llbnQ6ICgpID0+IGdldEJhY2tvZmZDb2VmZmljaWVudCxcbiAgZ2V0R2xvYmFsT2JqZWN0OiAoKSA9PiBnZXRHbG9iYWxPYmplY3QsXG4gIGdldEppdHRlckNvZWZmaWNpZW50OiAoKSA9PiBnZXRKaXR0ZXJDb2VmZmljaWVudCxcbiAgZ2V0UmV0cnlUaW1lOiAoKSA9PiBnZXRSZXRyeVRpbWUsXG4gIGluaGVyaXRzOiAoKSA9PiBpbmhlcml0cyxcbiAgaW5zcGVjdEJvZHk6ICgpID0+IGluc3BlY3RCb2R5LFxuICBpbnNwZWN0RXJyb3I6ICgpID0+IGluc3BlY3RFcnJvcixcbiAgaW50ZXJzZWN0OiAoKSA9PiBpbnRlcnNlY3QsXG4gIGlzRW1wdHk6ICgpID0+IGlzRW1wdHksXG4gIGlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvOiAoKSA9PiBpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyxcbiAgaXNOaWw6ICgpID0+IGlzTmlsLFxuICBpc09iamVjdDogKCkgPT4gaXNPYmplY3QsXG4gIGtleXNBcnJheTogKCkgPT4ga2V5c0FycmF5LFxuICBtYXRjaERlcml2ZWRDaGFubmVsOiAoKSA9PiBtYXRjaERlcml2ZWRDaGFubmVsLFxuICBtaXhpbjogKCkgPT4gbWl4aW4sXG4gIHBhcnNlUXVlcnlTdHJpbmc6ICgpID0+IHBhcnNlUXVlcnlTdHJpbmcsXG4gIHByb3RvdHlwaWNhbENsb25lOiAoKSA9PiBwcm90b3R5cGljYWxDbG9uZSxcbiAgcmFuZG9tU3RyaW5nOiAoKSA9PiByYW5kb21TdHJpbmcsXG4gIHNoYWxsb3dDbG9uZTogKCkgPT4gc2hhbGxvd0Nsb25lLFxuICBzaGFsbG93RXF1YWxzOiAoKSA9PiBzaGFsbG93RXF1YWxzLFxuICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcjogKCkgPT4gdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IsXG4gIHRvQmFzZTY0OiAoKSA9PiB0b0Jhc2U2NCxcbiAgdG9RdWVyeVN0cmluZzogKCkgPT4gdG9RdWVyeVN0cmluZyxcbiAgdmFsdWVzQXJyYXk6ICgpID0+IHZhbHVlc0FycmF5LFxuICB3aGVuUHJvbWlzZVNldHRsZXM6ICgpID0+IHdoZW5Qcm9taXNlU2V0dGxlcyxcbiAgd2l0aFRpbWVvdXRBc3luYzogKCkgPT4gd2l0aFRpbWVvdXRBc3luY1xufSk7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL2Vycm9yaW5mby50c1xuZnVuY3Rpb24gdG9TdHJpbmcoZXJyKSB7XG4gIGxldCByZXN1bHQgPSBcIltcIiArIGVyci5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAoZXJyLm1lc3NhZ2UpXG4gICAgcmVzdWx0ICs9IFwiOiBcIiArIGVyci5tZXNzYWdlO1xuICBpZiAoZXJyLnN0YXR1c0NvZGUpXG4gICAgcmVzdWx0ICs9IFwiOyBzdGF0dXNDb2RlPVwiICsgZXJyLnN0YXR1c0NvZGU7XG4gIGlmIChlcnIuY29kZSlcbiAgICByZXN1bHQgKz0gXCI7IGNvZGU9XCIgKyBlcnIuY29kZTtcbiAgaWYgKGVyci5jYXVzZSlcbiAgICByZXN1bHQgKz0gXCI7IGNhdXNlPVwiICsgaW5zcGVjdEVycm9yKGVyci5jYXVzZSk7XG4gIGlmIChlcnIuaHJlZiAmJiAhKGVyci5tZXNzYWdlICYmIGVyci5tZXNzYWdlLmluZGV4T2YoXCJoZWxwLmFibHkuaW9cIikgPiAtMSkpXG4gICAgcmVzdWx0ICs9IFwiOyBzZWUgXCIgKyBlcnIuaHJlZiArIFwiIFwiO1xuICByZXN1bHQgKz0gXCJdXCI7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgRXJyb3JJbmZvID0gY2xhc3MgX0Vycm9ySW5mbyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBpZiAodHlwZW9mIE9iamVjdC5zZXRQcm90b3R5cGVPZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIF9FcnJvckluZm8ucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgY29uc3QgeyBtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlIH0gPSB2YWx1ZXM7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBjb2RlICE9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBzdGF0dXNDb2RlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvckluZm8uZnJvbVZhbHVlcygpOiBpbnZhbGlkIHZhbHVlczogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdCh2YWx1ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihuZXcgX0Vycm9ySW5mbyhtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlKSwgdmFsdWVzKTtcbiAgICBpZiAocmVzdWx0LmNvZGUgJiYgIXJlc3VsdC5ocmVmKSB7XG4gICAgICByZXN1bHQuaHJlZiA9IFwiaHR0cHM6Ly9oZWxwLmFibHkuaW8vZXJyb3IvXCIgKyByZXN1bHQuY29kZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbnZhciBQYXJ0aWFsRXJyb3JJbmZvID0gY2xhc3MgX1BhcnRpYWxFcnJvckluZm8gZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgaWYgKHR5cGVvZiBPYmplY3Quc2V0UHJvdG90eXBlT2YgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfUGFydGlhbEVycm9ySW5mby5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICBjb25zdCB7IG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUgfSA9IHZhbHVlcztcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIgfHwgIWlzTmlsKGNvZGUpICYmIHR5cGVvZiBjb2RlICE9PSBcIm51bWJlclwiIHx8ICFpc05pbChzdGF0dXNDb2RlKSAmJiB0eXBlb2Ygc3RhdHVzQ29kZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFydGlhbEVycm9ySW5mby5mcm9tVmFsdWVzKCk6IGludmFsaWQgdmFsdWVzOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KHZhbHVlcykpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKG5ldyBfUGFydGlhbEVycm9ySW5mbyhtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlKSwgdmFsdWVzKTtcbiAgICBpZiAocmVzdWx0LmNvZGUgJiYgIXJlc3VsdC5ocmVmKSB7XG4gICAgICByZXN1bHQuaHJlZiA9IFwiaHR0cHM6Ly9oZWxwLmFibHkuaW8vZXJyb3IvXCIgKyByZXN1bHQuY29kZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC91dGlscy50c1xuZnVuY3Rpb24gcmFuZG9tUG9zbihhcnJPclN0cikge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyT3JTdHIubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIG1peGluKHRhcmdldCwgLi4uYXJncykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzb3VyY2UgPSBhcmdzW2ldO1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gY29weShzcmMpIHtcbiAgcmV0dXJuIG1peGluKHt9LCBzcmMpO1xufVxuZnVuY3Rpb24gZW5zdXJlQXJyYXkob2JqKSB7XG4gIGlmIChpc05pbChvYmopKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHJldHVybiBbb2JqXTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2IpID09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBpc0VtcHR5KG9iKSB7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBvYilcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNOaWwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYikge1xuICBjb25zdCByZXN1bHQgPSBuZXcgT2JqZWN0KCk7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBvYilcbiAgICByZXN1bHRbcHJvcF0gPSBvYltwcm9wXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHByb3RvdHlwaWNhbENsb25lKG9iLCBvd25Qcm9wZXJ0aWVzKSB7XG4gIGNsYXNzIEYge1xuICB9XG4gIEYucHJvdG90eXBlID0gb2I7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBGKCk7XG4gIGlmIChvd25Qcm9wZXJ0aWVzKVxuICAgIG1peGluKHJlc3VsdCwgb3duUHJvcGVydGllcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcbiAgaWYgKFBsYXRmb3JtLkNvbmZpZy5pbmhlcml0cykge1xuICAgIFBsYXRmb3JtLkNvbmZpZy5pbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpO1xuICAgIHJldHVybjtcbiAgfVxuICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgY3Rvci5wcm90b3R5cGUgPSBwcm90b3R5cGljYWxDbG9uZShzdXBlckN0b3IucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiBjdG9yIH0pO1xufTtcbmZ1bmN0aW9uIGNvbnRhaW5zVmFsdWUob2IsIHZhbCkge1xuICBmb3IgKGNvbnN0IGkgaW4gb2IpIHtcbiAgICBpZiAob2JbaV0gPT0gdmFsKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0KGFyciwgb2IpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2IpID8gYXJySW50ZXJzZWN0KGFyciwgb2IpIDogYXJySW50ZXJzZWN0T2IoYXJyLCBvYik7XG59XG5mdW5jdGlvbiBhcnJJbnRlcnNlY3QoYXJyMSwgYXJyMikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWVtYmVyID0gYXJyMVtpXTtcbiAgICBpZiAoYXJyMi5pbmRleE9mKG1lbWJlcikgIT0gLTEpXG4gICAgICByZXN1bHQucHVzaChtZW1iZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhcnJJbnRlcnNlY3RPYihhcnIsIG9iKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1lbWJlciA9IGFycltpXTtcbiAgICBpZiAobWVtYmVyIGluIG9iKVxuICAgICAgcmVzdWx0LnB1c2gobWVtYmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXJyU3VidHJhY3QoYXJyMSwgYXJyMikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycjFbaV07XG4gICAgaWYgKGFycjIuaW5kZXhPZihlbGVtZW50KSA9PSAtMSlcbiAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhcnJEZWxldGVWYWx1ZShhcnIsIHZhbCkge1xuICBjb25zdCBpZHggPSBhcnIuaW5kZXhPZih2YWwpO1xuICBjb25zdCByZXMgPSBpZHggIT0gLTE7XG4gIGlmIChyZXMpXG4gICAgYXJyLnNwbGljZShpZHgsIDEpO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gYXJyV2l0aG91dFZhbHVlKGFyciwgdmFsKSB7XG4gIGNvbnN0IG5ld0FyciA9IGFyci5zbGljZSgpO1xuICBhcnJEZWxldGVWYWx1ZShuZXdBcnIsIHZhbCk7XG4gIHJldHVybiBuZXdBcnI7XG59XG5mdW5jdGlvbiBrZXlzQXJyYXkob2IsIG93bk9ubHkpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAoY29uc3QgcHJvcCBpbiBvYikge1xuICAgIGlmIChvd25Pbmx5ICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApKVxuICAgICAgY29udGludWU7XG4gICAgcmVzdWx0LnB1c2gocHJvcCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbHVlc0FycmF5KG9iLCBvd25Pbmx5KSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gb2IpIHtcbiAgICBpZiAob3duT25seSAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIHJlc3VsdC5wdXNoKG9iW3Byb3BdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyhvYiwgZm4pIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIG9iKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkgJiYgb2JbcHJvcF0pIHtcbiAgICAgIGZuKHByb3ApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWxsU2FtZShhcnIsIHByb3ApIHtcbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBmaXJzdCA9IGFyclswXVtwcm9wXTtcbiAgcmV0dXJuIGFyci5ldmVyeShmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1bcHJvcF0gPT09IGZpcnN0O1xuICB9KTtcbn1cbnZhciBGb3JtYXQgPSAvKiBAX19QVVJFX18gKi8gKChGb3JtYXQyKSA9PiB7XG4gIEZvcm1hdDJbXCJtc2dwYWNrXCJdID0gXCJtc2dwYWNrXCI7XG4gIEZvcm1hdDJbXCJqc29uXCJdID0gXCJqc29uXCI7XG4gIHJldHVybiBGb3JtYXQyO1xufSkoRm9ybWF0IHx8IHt9KTtcbmZ1bmN0aW9uIGFyclBvcFJhbmRvbUVsZW1lbnQoYXJyKSB7XG4gIHJldHVybiBhcnIuc3BsaWNlKHJhbmRvbVBvc24oYXJyKSwgMSlbMF07XG59XG5mdW5jdGlvbiB0b1F1ZXJ5U3RyaW5nKHBhcmFtcykge1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBpZiAocGFyYW1zKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKVxuICAgICAgcGFydHMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnRzLmxlbmd0aCA/IFwiP1wiICsgcGFydHMuam9pbihcIiZcIikgOiBcIlwiO1xufVxuZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZyhxdWVyeSkge1xuICBsZXQgbWF0Y2g7XG4gIGNvbnN0IHNlYXJjaCA9IC8oW14/Jj1dKyk9PyhbXiZdKikvZztcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIHdoaWxlIChtYXRjaCA9IHNlYXJjaC5leGVjKHF1ZXJ5KSlcbiAgICByZXN1bHRbZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzFdKV0gPSBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMl0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8oZXJyKSB7XG4gIHJldHVybiB0eXBlb2YgZXJyID09IFwib2JqZWN0XCIgJiYgZXJyICE9PSBudWxsICYmIChlcnIgaW5zdGFuY2VvZiBFcnJvckluZm8gfHwgZXJyIGluc3RhbmNlb2YgUGFydGlhbEVycm9ySW5mbyk7XG59XG5mdW5jdGlvbiBpbnNwZWN0RXJyb3IoZXJyKSB7XG4gIHZhciBfYTIsIF9iO1xuICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgfHwgKChfYTIgPSBlcnIgPT0gbnVsbCA/IHZvaWQgMCA6IGVyci5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5uYW1lKSA9PT0gXCJFcnJvckluZm9cIiB8fCAoKF9iID0gZXJyID09IG51bGwgPyB2b2lkIDAgOiBlcnIuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYi5uYW1lKSA9PT0gXCJQYXJ0aWFsRXJyb3JJbmZvXCIpXG4gICAgcmV0dXJuIGVyci50b1N0cmluZygpO1xuICByZXR1cm4gUGxhdGZvcm0uQ29uZmlnLmluc3BlY3QoZXJyKTtcbn1cbmZ1bmN0aW9uIGluc3BlY3RCb2R5KGJvZHkpIHtcbiAgaWYgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgcmV0dXJuIGJvZHkudG9TdHJpbmcoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBib2R5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChib2R5KTtcbiAgfVxufVxuZnVuY3Rpb24gZGF0YVNpemVCeXRlcyhkYXRhKSB7XG4gIGlmIChQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiBQbGF0Zm9ybS5CdWZmZXJVdGlscy5ieXRlTGVuZ3RoKGRhdGEpO1xuICB9XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBQbGF0Zm9ybS5Db25maWcuc3RyaW5nQnl0ZVNpemUoZGF0YSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgb2YgVXRpbHMuZGF0YVNpemVCeXRlcyB0byBiZSBhIGJ1ZmZlciBvciBzdHJpbmcsIGJ1dCB3YXM6IFwiICsgdHlwZW9mIGRhdGEpO1xufVxuZnVuY3Rpb24gY2hlYXBSYW5kU3RyKCkge1xuICByZXR1cm4gU3RyaW5nKE1hdGgucmFuZG9tKCkpLnN1YnN0cigyKTtcbn1cbnZhciByYW5kb21TdHJpbmcgPSBhc3luYyAobnVtQnl0ZXMpID0+IHtcbiAgY29uc3QgYnVmZmVyID0gYXdhaXQgUGxhdGZvcm0uQ29uZmlnLmdldFJhbmRvbUFycmF5QnVmZmVyKG51bUJ5dGVzKTtcbiAgcmV0dXJuIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShidWZmZXIpO1xufTtcbmZ1bmN0aW9uIGFyckNob29zZU4oYXJyLCBuKSB7XG4gIGNvbnN0IG51bUl0ZW1zID0gTWF0aC5taW4obiwgYXJyLmxlbmd0aCksIG11dGFibGVBcnIgPSBhcnIuc2xpY2UoKSwgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSXRlbXM7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKGFyclBvcFJhbmRvbUVsZW1lbnQobXV0YWJsZUFycikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3aGVuUHJvbWlzZVNldHRsZXMocHJvbWlzZSwgY2FsbGJhY2spIHtcbiAgcHJvbWlzZS50aGVuKChyZXN1bHQpID0+IHtcbiAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgIGNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFjayhlcnIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJvZHkoYm9keSwgTXNnUGFjaywgZm9ybWF0KSB7XG4gIGlmIChmb3JtYXQgPT0gXCJtc2dwYWNrXCIpIHtcbiAgICBpZiAoIU1zZ1BhY2spIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiTXNnUGFja1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIE1zZ1BhY2suZGVjb2RlKGJvZHkpO1xuICB9XG4gIHJldHVybiBKU09OLnBhcnNlKFN0cmluZyhib2R5KSk7XG59XG5mdW5jdGlvbiBlbmNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ID09IFwibXNncGFja1wiKSB7XG4gICAgaWYgKCFNc2dQYWNrKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1zZ1BhY2tcIik7XG4gICAgfVxuICAgIHJldHVybiBNc2dQYWNrLmVuY29kZShib2R5LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG59XG5mdW5jdGlvbiBhbGxUb0xvd2VyQ2FzZShhcnIpIHtcbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhbGxUb1VwcGVyQ2FzZShhcnIpIHtcbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRCYWNrb2ZmQ29lZmZpY2llbnQoY291bnQpIHtcbiAgcmV0dXJuIE1hdGgubWluKChjb3VudCArIDIpIC8gMywgMik7XG59XG5mdW5jdGlvbiBnZXRKaXR0ZXJDb2VmZmljaWVudCgpIHtcbiAgcmV0dXJuIDEgLSBNYXRoLnJhbmRvbSgpICogMC4yO1xufVxuZnVuY3Rpb24gZ2V0UmV0cnlUaW1lKGluaXRpYWxUaW1lb3V0LCByZXRyeUF0dGVtcHQpIHtcbiAgcmV0dXJuIGluaXRpYWxUaW1lb3V0ICogZ2V0QmFja29mZkNvZWZmaWNpZW50KHJldHJ5QXR0ZW1wdCkgKiBnZXRKaXR0ZXJDb2VmZmljaWVudCgpO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsT2JqZWN0KCkge1xuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gc2hhbGxvd0VxdWFscyhzb3VyY2UsIHRhcmdldCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5ldmVyeSgoa2V5KSA9PiBzb3VyY2Vba2V5XSA9PT0gdGFyZ2V0W2tleV0pICYmIE9iamVjdC5rZXlzKHRhcmdldCkuZXZlcnkoKGtleSkgPT4gdGFyZ2V0W2tleV0gPT09IHNvdXJjZVtrZXldKTtcbn1cbmZ1bmN0aW9uIG1hdGNoRGVyaXZlZENoYW5uZWwobmFtZSkge1xuICBjb25zdCByZWdleCA9IC9eKFxcWyhbXj9dKikoPzooLiopKVxcXSk/KC4rKSQvO1xuICBjb25zdCBtYXRjaCA9IG5hbWUubWF0Y2gocmVnZXgpO1xuICBpZiAoIW1hdGNoIHx8ICFtYXRjaC5sZW5ndGggfHwgbWF0Y2gubGVuZ3RoIDwgNSkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJyZWdleCBtYXRjaCBmYWlsZWRcIiwgNDAwLCA0MDAxMCk7XG4gIH1cbiAgaWYgKG1hdGNoWzJdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9ySW5mbyhgY2Fubm90IHVzZSBhIGRlcml2ZWQgb3B0aW9uIHdpdGggYSAke21hdGNoWzJdfSBjaGFubmVsYCwgNDAwLCA0MDAxMCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBxdWFsaWZpZXJQYXJhbTogbWF0Y2hbM10gfHwgXCJcIixcbiAgICBjaGFubmVsTmFtZTogbWF0Y2hbNF1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQmFzZTY0KHN0cikge1xuICBjb25zdCBidWZmZXJVdGlscyA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzO1xuICBjb25zdCB0ZXh0QnVmZmVyID0gYnVmZmVyVXRpbHMudXRmOEVuY29kZShzdHIpO1xuICByZXR1cm4gYnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHRleHRCdWZmZXIpO1xufVxuZnVuY3Rpb24gYXJyRXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uKHZhbCwgaSkge1xuICAgIHJldHVybiB2YWwgPT09IGJbaV07XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yKHBsdWdpbk5hbWUpIHtcbiAgcmV0dXJuIG5ldyBFcnJvckluZm8oYCR7cGx1Z2luTmFtZX0gcGx1Z2luIG5vdCBwcm92aWRlZGAsIDQwMDE5LCA0MDApO1xufVxuZnVuY3Rpb24gdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IocGx1Z2luTmFtZSkge1xuICB0aHJvdyBjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IocGx1Z2luTmFtZSk7XG59XG5hc3luYyBmdW5jdGlvbiB3aXRoVGltZW91dEFzeW5jKHByb21pc2UsIHRpbWVvdXQgPSA1ZTMsIGVyciA9IFwiVGltZW91dCBleHBpcmVkXCIpIHtcbiAgY29uc3QgZSA9IG5ldyBFcnJvckluZm8oZXJyLCA1ZTQsIDUwMCk7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW3Byb21pc2UsIG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChlKSwgdGltZW91dCkpXSk7XG59XG5cbi8vIHBhY2thZ2UuanNvblxudmFyIHZlcnNpb24gPSBcIjIuNy4wXCI7XG5cbi8vIHNyYy9jb21tb24vbGliL3V0aWwvZGVmYXVsdHMudHNcbnZhciBhZ2VudCA9IFwiYWJseS1qcy9cIiArIHZlcnNpb247XG52YXIgRGVmYXVsdHMgPSB7XG4gIEVOVklST05NRU5UOiBcIlwiLFxuICBSRVNUX0hPU1Q6IFwicmVzdC5hYmx5LmlvXCIsXG4gIFJFQUxUSU1FX0hPU1Q6IFwicmVhbHRpbWUuYWJseS5pb1wiLFxuICBGQUxMQkFDS19IT1NUUzogW1xuICAgIFwiQS5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIFwiQi5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIFwiQy5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIFwiRC5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAgIFwiRS5hYmx5LXJlYWx0aW1lLmNvbVwiXG4gIF0sXG4gIFBPUlQ6IDgwLFxuICBUTFNfUE9SVDogNDQzLFxuICBUSU1FT1VUUzoge1xuICAgIC8qIERvY3VtZW50ZWQgYXMgb3B0aW9ucyBwYXJhbXM6ICovXG4gICAgZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0OiAxNWUzLFxuICAgIHN1c3BlbmRlZFJldHJ5VGltZW91dDogM2U0LFxuICAgIC8qIFVuZG9jdW1lbnRlZCwgYnV0IHBhcnQgb2YgdGhlIGFwaSBhbmQgY2FuIGJlIHVzZWQgYnkgY3VzdG9tZXJzOiAqL1xuICAgIGh0dHBSZXF1ZXN0VGltZW91dDogMWU0LFxuICAgIGh0dHBNYXhSZXRyeUR1cmF0aW9uOiAxNWUzLFxuICAgIGNoYW5uZWxSZXRyeVRpbWVvdXQ6IDE1ZTMsXG4gICAgZmFsbGJhY2tSZXRyeVRpbWVvdXQ6IDZlNSxcbiAgICAvKiBGb3IgaW50ZXJuYWwgLyB0ZXN0IHVzZSBvbmx5OiAqL1xuICAgIGNvbm5lY3Rpb25TdGF0ZVR0bDogMTJlNCxcbiAgICByZWFsdGltZVJlcXVlc3RUaW1lb3V0OiAxZTQsXG4gICAgcmVjdlRpbWVvdXQ6IDllNCxcbiAgICB3ZWJTb2NrZXRDb25uZWN0VGltZW91dDogMWU0LFxuICAgIHdlYlNvY2tldFNsb3dUaW1lb3V0OiA0ZTNcbiAgfSxcbiAgaHR0cE1heFJldHJ5Q291bnQ6IDMsXG4gIG1heE1lc3NhZ2VTaXplOiA2NTUzNixcbiAgdmVyc2lvbixcbiAgcHJvdG9jb2xWZXJzaW9uOiAzLFxuICBhZ2VudCxcbiAgZ2V0SG9zdCxcbiAgZ2V0UG9ydCxcbiAgZ2V0SHR0cFNjaGVtZSxcbiAgZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzLFxuICBnZXRGYWxsYmFja0hvc3RzLFxuICBnZXRIb3N0cyxcbiAgY2hlY2tIb3N0LFxuICBvYmplY3RpZnlPcHRpb25zLFxuICBub3JtYWxpc2VPcHRpb25zLFxuICBkZWZhdWx0R2V0SGVhZGVycyxcbiAgZGVmYXVsdFBvc3RIZWFkZXJzXG59O1xuZnVuY3Rpb24gZ2V0SG9zdChvcHRpb25zLCBob3N0LCB3cykge1xuICBpZiAod3MpXG4gICAgaG9zdCA9IGhvc3QgPT0gb3B0aW9ucy5yZXN0SG9zdCAmJiBvcHRpb25zLnJlYWx0aW1lSG9zdCB8fCBob3N0IHx8IG9wdGlvbnMucmVhbHRpbWVIb3N0O1xuICBlbHNlXG4gICAgaG9zdCA9IGhvc3QgfHwgb3B0aW9ucy5yZXN0SG9zdDtcbiAgcmV0dXJuIGhvc3Q7XG59XG5mdW5jdGlvbiBnZXRQb3J0KG9wdGlvbnMsIHRscykge1xuICByZXR1cm4gdGxzIHx8IG9wdGlvbnMudGxzID8gb3B0aW9ucy50bHNQb3J0IDogb3B0aW9ucy5wb3J0O1xufVxuZnVuY3Rpb24gZ2V0SHR0cFNjaGVtZShvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnRscyA/IFwiaHR0cHM6Ly9cIiA6IFwiaHR0cDovL1wiO1xufVxuZnVuY3Rpb24gZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzKGVudmlyb25tZW50KSB7XG4gIHJldHVybiBbXG4gICAgZW52aXJvbm1lbnQgKyBcIi1hLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCIsXG4gICAgZW52aXJvbm1lbnQgKyBcIi1iLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCIsXG4gICAgZW52aXJvbm1lbnQgKyBcIi1jLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCIsXG4gICAgZW52aXJvbm1lbnQgKyBcIi1kLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCIsXG4gICAgZW52aXJvbm1lbnQgKyBcIi1lLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tXCJcbiAgXTtcbn1cbmZ1bmN0aW9uIGdldEZhbGxiYWNrSG9zdHMob3B0aW9ucykge1xuICBjb25zdCBmYWxsYmFja0hvc3RzID0gb3B0aW9ucy5mYWxsYmFja0hvc3RzLCBodHRwTWF4UmV0cnlDb3VudCA9IHR5cGVvZiBvcHRpb25zLmh0dHBNYXhSZXRyeUNvdW50ICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5odHRwTWF4UmV0cnlDb3VudCA6IERlZmF1bHRzLmh0dHBNYXhSZXRyeUNvdW50O1xuICByZXR1cm4gZmFsbGJhY2tIb3N0cyA/IGFyckNob29zZU4oZmFsbGJhY2tIb3N0cywgaHR0cE1heFJldHJ5Q291bnQpIDogW107XG59XG5mdW5jdGlvbiBnZXRIb3N0cyhvcHRpb25zLCB3cykge1xuICBjb25zdCBob3N0cyA9IFtvcHRpb25zLnJlc3RIb3N0XS5jb25jYXQoZ2V0RmFsbGJhY2tIb3N0cyhvcHRpb25zKSk7XG4gIHJldHVybiB3cyA/IGhvc3RzLm1hcCgoaG9zdCkgPT4gZ2V0SG9zdChvcHRpb25zLCBob3N0LCB0cnVlKSkgOiBob3N0cztcbn1cbmZ1bmN0aW9uIGNoZWNrSG9zdChob3N0KSB7XG4gIGlmICh0eXBlb2YgaG9zdCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJob3N0IG11c3QgYmUgYSBzdHJpbmc7IHdhcyBhIFwiICsgdHlwZW9mIGhvc3QsIDRlNCwgNDAwKTtcbiAgfVxuICBpZiAoIWhvc3QubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImhvc3QgbXVzdCBub3QgYmUgemVyby1sZW5ndGhcIiwgNGU0LCA0MDApO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZWFsdGltZUhvc3Qob3B0aW9ucywgcHJvZHVjdGlvbiwgZW52aXJvbm1lbnQsIGxvZ2dlcikge1xuICBpZiAob3B0aW9ucy5yZWFsdGltZUhvc3QpXG4gICAgcmV0dXJuIG9wdGlvbnMucmVhbHRpbWVIb3N0O1xuICBpZiAob3B0aW9ucy5yZXN0SG9zdCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9uc1wiLFxuICAgICAgJ3Jlc3RIb3N0IGlzIHNldCB0byBcIicgKyBvcHRpb25zLnJlc3RIb3N0ICsgJ1wiIGJ1dCByZWFsdGltZUhvc3QgaXMgbm90IHNldCwgc28gc2V0dGluZyByZWFsdGltZUhvc3QgdG8gXCInICsgb3B0aW9ucy5yZXN0SG9zdCArICdcIiB0b28uIElmIHRoaXMgaXMgbm90IHdoYXQgeW91IHdhbnQsIHBsZWFzZSBzZXQgcmVhbHRpbWVIb3N0IGV4cGxpY2l0bHkuJ1xuICAgICk7XG4gICAgcmV0dXJuIG9wdGlvbnMucmVzdEhvc3Q7XG4gIH1cbiAgcmV0dXJuIHByb2R1Y3Rpb24gPyBEZWZhdWx0cy5SRUFMVElNRV9IT1NUIDogZW52aXJvbm1lbnQgKyBcIi1cIiArIERlZmF1bHRzLlJFQUxUSU1FX0hPU1Q7XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0cyhvcHRpb25zKSB7XG4gIGNvbnN0IHRpbWVvdXRzID0ge307XG4gIGZvciAoY29uc3QgcHJvcCBpbiBEZWZhdWx0cy5USU1FT1VUUykge1xuICAgIHRpbWVvdXRzW3Byb3BdID0gb3B0aW9uc1twcm9wXSB8fCBEZWZhdWx0cy5USU1FT1VUU1twcm9wXTtcbiAgfVxuICByZXR1cm4gdGltZW91dHM7XG59XG5mdW5jdGlvbiBnZXRBZ2VudFN0cmluZyhvcHRpb25zKSB7XG4gIGxldCBhZ2VudFN0ciA9IERlZmF1bHRzLmFnZW50O1xuICBpZiAob3B0aW9ucy5hZ2VudHMpIHtcbiAgICBmb3IgKHZhciBhZ2VudDIgaW4gb3B0aW9ucy5hZ2VudHMpIHtcbiAgICAgIGFnZW50U3RyICs9IFwiIFwiICsgYWdlbnQyICsgXCIvXCIgKyBvcHRpb25zLmFnZW50c1thZ2VudDJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWdlbnRTdHI7XG59XG5mdW5jdGlvbiBvYmplY3RpZnlPcHRpb25zKG9wdGlvbnMsIGFsbG93S2V5T3JUb2tlbiwgc291cmNlRm9yRXJyb3JNZXNzYWdlLCBsb2dnZXIsIG1vZHVsYXJQbHVnaW5zVG9JbmNsdWRlKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBjb25zdCBtc2cgPSBhbGxvd0tleU9yVG9rZW4gPyBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9IG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBlaXRoZXIgYSBjbGllbnQgb3B0aW9ucyBvYmplY3QsIGFuIEFibHkgQVBJIGtleSwgb3IgYW4gQWJseSBUb2tlbmAgOiBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9IG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGNsaWVudCBvcHRpb25zIG9iamVjdGA7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9KClgLCBtc2cpO1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG4gIGxldCBvcHRpb25zT2JqO1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAob3B0aW9ucy5pbmRleE9mKFwiOlwiKSA9PSAtMSkge1xuICAgICAgaWYgKCFhbGxvd0tleU9yVG9rZW4pIHtcbiAgICAgICAgY29uc3QgbXNnID0gYCR7c291cmNlRm9yRXJyb3JNZXNzYWdlfSBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBqdXN0IGFuIEFibHkgVG9rZW47IHlvdSBtdXN0IHByb3ZpZGUgYSBjbGllbnQgb3B0aW9ucyBvYmplY3Qgd2l0aCBhIFxcYHBsdWdpbnNcXGAgcHJvcGVydHkuIChTZXQgdGhpcyBBYmx5IFRva2VuIGFzIHRoZSBvYmplY3RcXHUyMDE5cyBcXGB0b2tlblxcYCBwcm9wZXJ0eS4pYDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9KClgLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnNPYmogPSB7IHRva2VuOiBvcHRpb25zIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghYWxsb3dLZXlPclRva2VuKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGAke3NvdXJjZUZvckVycm9yTWVzc2FnZX0gY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGgganVzdCBhbiBBYmx5IEFQSSBrZXk7IHlvdSBtdXN0IHByb3ZpZGUgYSBjbGllbnQgb3B0aW9ucyBvYmplY3Qgd2l0aCBhIFxcYHBsdWdpbnNcXGAgcHJvcGVydHkuIChTZXQgdGhpcyBBYmx5IEFQSSBrZXkgYXMgdGhlIG9iamVjdFxcdTIwMTlzIFxcYGtleVxcYCBwcm9wZXJ0eS4pYDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBgJHtzb3VyY2VGb3JFcnJvck1lc3NhZ2V9KClgLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnNPYmogPSB7IGtleTogb3B0aW9ucyB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zT2JqID0gb3B0aW9ucztcbiAgfVxuICBpZiAobW9kdWxhclBsdWdpbnNUb0luY2x1ZGUpIHtcbiAgICBvcHRpb25zT2JqID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9uc09iaiksIHsgcGx1Z2luczogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIG1vZHVsYXJQbHVnaW5zVG9JbmNsdWRlKSwgb3B0aW9uc09iai5wbHVnaW5zKSB9KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc09iajtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZU9wdGlvbnMob3B0aW9ucywgTXNnUGFjaywgbG9nZ2VyKSB7XG4gIGNvbnN0IGxvZ2dlclRvVXNlID0gbG9nZ2VyICE9IG51bGwgPyBsb2dnZXIgOiBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyO1xuICBpZiAodHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gXCJmdW5jdGlvblwiICYmIG9wdGlvbnMuY2xvc2VPblVubG9hZCA9PT0gdHJ1ZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIGxvZ2dlclRvVXNlLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgXCJEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zXCIsXG4gICAgICBcImNsb3NlT25VbmxvYWQgd2FzIHRydWUgYW5kIGEgc2Vzc2lvbiByZWNvdmVyeSBmdW5jdGlvbiB3YXMgc2V0IC0gdGhlc2UgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSwgc28gdW5zZXR0aW5nIHRoZSBsYXR0ZXJcIlxuICAgICk7XG4gICAgb3B0aW9ucy5yZWNvdmVyID0gdm9pZCAwO1xuICB9XG4gIGlmICghKFwiY2xvc2VPblVubG9hZFwiIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5jbG9zZU9uVW5sb2FkID0gIW9wdGlvbnMucmVjb3ZlcjtcbiAgfVxuICBpZiAoIShcInF1ZXVlTWVzc2FnZXNcIiBpbiBvcHRpb25zKSlcbiAgICBvcHRpb25zLnF1ZXVlTWVzc2FnZXMgPSB0cnVlO1xuICBjb25zdCBlbnZpcm9ubWVudCA9IG9wdGlvbnMuZW52aXJvbm1lbnQgJiYgU3RyaW5nKG9wdGlvbnMuZW52aXJvbm1lbnQpLnRvTG93ZXJDYXNlKCkgfHwgRGVmYXVsdHMuRU5WSVJPTk1FTlQ7XG4gIGNvbnN0IHByb2R1Y3Rpb24gPSAhZW52aXJvbm1lbnQgfHwgZW52aXJvbm1lbnQgPT09IFwicHJvZHVjdGlvblwiO1xuICBpZiAoIW9wdGlvbnMuZmFsbGJhY2tIb3N0cyAmJiAhb3B0aW9ucy5yZXN0SG9zdCAmJiAhb3B0aW9ucy5yZWFsdGltZUhvc3QgJiYgIW9wdGlvbnMucG9ydCAmJiAhb3B0aW9ucy50bHNQb3J0KSB7XG4gICAgb3B0aW9ucy5mYWxsYmFja0hvc3RzID0gcHJvZHVjdGlvbiA/IERlZmF1bHRzLkZBTExCQUNLX0hPU1RTIDogZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzKGVudmlyb25tZW50KTtcbiAgfVxuICBjb25zdCByZXN0SG9zdCA9IG9wdGlvbnMucmVzdEhvc3QgfHwgKHByb2R1Y3Rpb24gPyBEZWZhdWx0cy5SRVNUX0hPU1QgOiBlbnZpcm9ubWVudCArIFwiLVwiICsgRGVmYXVsdHMuUkVTVF9IT1NUKTtcbiAgY29uc3QgcmVhbHRpbWVIb3N0ID0gZ2V0UmVhbHRpbWVIb3N0KG9wdGlvbnMsIHByb2R1Y3Rpb24sIGVudmlyb25tZW50LCBsb2dnZXJUb1VzZSk7XG4gIChvcHRpb25zLmZhbGxiYWNrSG9zdHMgfHwgW10pLmNvbmNhdChyZXN0SG9zdCwgcmVhbHRpbWVIb3N0KS5mb3JFYWNoKGNoZWNrSG9zdCk7XG4gIG9wdGlvbnMucG9ydCA9IG9wdGlvbnMucG9ydCB8fCBEZWZhdWx0cy5QT1JUO1xuICBvcHRpb25zLnRsc1BvcnQgPSBvcHRpb25zLnRsc1BvcnQgfHwgRGVmYXVsdHMuVExTX1BPUlQ7XG4gIGlmICghKFwidGxzXCIgaW4gb3B0aW9ucykpXG4gICAgb3B0aW9ucy50bHMgPSB0cnVlO1xuICBjb25zdCB0aW1lb3V0cyA9IGdldFRpbWVvdXRzKG9wdGlvbnMpO1xuICBpZiAoTXNnUGFjaykge1xuICAgIGlmIChcInVzZUJpbmFyeVByb3RvY29sXCIgaW4gb3B0aW9ucykge1xuICAgICAgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IFBsYXRmb3JtLkNvbmZpZy5zdXBwb3J0c0JpbmFyeSAmJiBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID0gUGxhdGZvcm0uQ29uZmlnLnByZWZlckJpbmFyeTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKG9wdGlvbnMuY2xpZW50SWQpIHtcbiAgICBoZWFkZXJzW1wiWC1BYmx5LUNsaWVudElkXCJdID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUob3B0aW9ucy5jbGllbnRJZCkpO1xuICB9XG4gIGlmICghKFwiaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nXCIgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyA9IHRydWU7XG4gIH1cbiAgbGV0IGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zID0gbnVsbDtcbiAgbGV0IGNvbm5lY3Rpdml0eUNoZWNrVXJsID0gb3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybDtcbiAgaWYgKG9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwpIHtcbiAgICBsZXQgW3VyaSwgcXNdID0gb3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybC5zcGxpdChcIj9cIik7XG4gICAgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMgPSBxcyA/IHBhcnNlUXVlcnlTdHJpbmcocXMpIDoge307XG4gICAgaWYgKHVyaS5pbmRleE9mKFwiOi8vXCIpID09PSAtMSkge1xuICAgICAgdXJpID0gXCJodHRwczovL1wiICsgdXJpO1xuICAgIH1cbiAgICBjb25uZWN0aXZpdHlDaGVja1VybCA9IHVyaTtcbiAgfVxuICBsZXQgd3NDb25uZWN0aXZpdHlDaGVja1VybCA9IG9wdGlvbnMud3NDb25uZWN0aXZpdHlDaGVja1VybDtcbiAgaWYgKHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwgJiYgd3NDb25uZWN0aXZpdHlDaGVja1VybC5pbmRleE9mKFwiOi8vXCIpID09PSAtMSkge1xuICAgIHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwgPSBcIndzczovL1wiICsgd3NDb25uZWN0aXZpdHlDaGVja1VybDtcbiAgfVxuICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICByZWFsdGltZUhvc3QsXG4gICAgcmVzdEhvc3QsXG4gICAgbWF4TWVzc2FnZVNpemU6IG9wdGlvbnMubWF4TWVzc2FnZVNpemUgfHwgRGVmYXVsdHMubWF4TWVzc2FnZVNpemUsXG4gICAgdGltZW91dHMsXG4gICAgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMsXG4gICAgY29ubmVjdGl2aXR5Q2hlY2tVcmwsXG4gICAgd3NDb25uZWN0aXZpdHlDaGVja1VybCxcbiAgICBoZWFkZXJzXG4gIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoQ3J5cHRvMiwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoYW5uZWxPcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKGNoYW5uZWxPcHRpb25zLmNpcGhlcikge1xuICAgIGlmICghQ3J5cHRvMilcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiQ3J5cHRvXCIpO1xuICAgIGNvbnN0IGNpcGhlciA9IENyeXB0bzIuZ2V0Q2lwaGVyKGNoYW5uZWxPcHRpb25zLmNpcGhlciwgbG9nZ2VyKTtcbiAgICBjaGFubmVsT3B0aW9ucy5jaXBoZXIgPSBjaXBoZXIuY2lwaGVyUGFyYW1zO1xuICAgIGNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXIgPSBjaXBoZXIuY2lwaGVyO1xuICB9IGVsc2UgaWYgKFwiY2lwaGVyXCIgaW4gY2hhbm5lbE9wdGlvbnMpIHtcbiAgICBjaGFubmVsT3B0aW9ucy5jaXBoZXIgPSB2b2lkIDA7XG4gICAgY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlciA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIGNoYW5uZWxPcHRpb25zO1xufVxudmFyIGNvbnRlbnRUeXBlcyA9IHtcbiAganNvbjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gIHhtbDogXCJhcHBsaWNhdGlvbi94bWxcIixcbiAgaHRtbDogXCJ0ZXh0L2h0bWxcIixcbiAgbXNncGFjazogXCJhcHBsaWNhdGlvbi94LW1zZ3BhY2tcIixcbiAgdGV4dDogXCJ0ZXh0L3BsYWluXCJcbn07XG52YXIgZGVmYXVsdEhlYWRlcnNPcHRpb25zID0ge1xuICBmb3JtYXQ6IFwianNvblwiIC8qIGpzb24gKi8sXG4gIHByb3RvY29sVmVyc2lvbjogRGVmYXVsdHMucHJvdG9jb2xWZXJzaW9uXG59O1xuZnVuY3Rpb24gZGVmYXVsdEdldEhlYWRlcnMob3B0aW9ucywge1xuICBmb3JtYXQgPSBkZWZhdWx0SGVhZGVyc09wdGlvbnMuZm9ybWF0LFxuICBwcm90b2NvbFZlcnNpb24gPSBkZWZhdWx0SGVhZGVyc09wdGlvbnMucHJvdG9jb2xWZXJzaW9uXG59ID0ge30pIHtcbiAgY29uc3QgYWNjZXB0ID0gY29udGVudFR5cGVzW2Zvcm1hdF07XG4gIHJldHVybiB7XG4gICAgYWNjZXB0LFxuICAgIFwiWC1BYmx5LVZlcnNpb25cIjogcHJvdG9jb2xWZXJzaW9uLnRvU3RyaW5nKCksXG4gICAgXCJBYmx5LUFnZW50XCI6IGdldEFnZW50U3RyaW5nKG9wdGlvbnMpXG4gIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0UG9zdEhlYWRlcnMob3B0aW9ucywge1xuICBmb3JtYXQgPSBkZWZhdWx0SGVhZGVyc09wdGlvbnMuZm9ybWF0LFxuICBwcm90b2NvbFZlcnNpb24gPSBkZWZhdWx0SGVhZGVyc09wdGlvbnMucHJvdG9jb2xWZXJzaW9uXG59ID0ge30pIHtcbiAgbGV0IGNvbnRlbnRUeXBlO1xuICBjb25zdCBhY2NlcHQgPSBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlc1tmb3JtYXRdO1xuICByZXR1cm4ge1xuICAgIGFjY2VwdCxcbiAgICBcImNvbnRlbnQtdHlwZVwiOiBjb250ZW50VHlwZSxcbiAgICBcIlgtQWJseS1WZXJzaW9uXCI6IHByb3RvY29sVmVyc2lvbi50b1N0cmluZygpLFxuICAgIFwiQWJseS1BZ2VudFwiOiBnZXRBZ2VudFN0cmluZyhvcHRpb25zKVxuICB9O1xufVxudmFyIGRlZmF1bHRzX2RlZmF1bHQgPSBEZWZhdWx0cztcbmZ1bmN0aW9uIGdldERlZmF1bHRzKHBsYXRmb3JtRGVmYXVsdHMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oRGVmYXVsdHMsIHBsYXRmb3JtRGVmYXVsdHMpO1xufVxuXG4vLyBzcmMvY29tbW9uL2xpYi91dGlsL211bHRpY2FzdGVyLnRzXG52YXIgTXVsdGljYXN0ZXIgPSBjbGFzcyBfTXVsdGljYXN0ZXIge1xuICAvLyBQcml2YXRlIGNvbnN0cnVjdG9yOyB1c2Ugc3RhdGljIE11bHRpY2FzdGVyLmNyZWF0ZSBpbnN0ZWFkXG4gIGNvbnN0cnVjdG9yKGxvZ2dlciwgbWVtYmVycykge1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMubWVtYmVycyA9IG1lbWJlcnMgfHwgW107XG4gIH1cbiAgY2FsbChlcnIsIHJlc3VsdCkge1xuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHRoaXMubWVtYmVycykge1xuICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1lbWJlcihlcnIsIHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgIFwiTXVsdGljYXN0ZXIgbXVsdGlwbGUgY2FsbGJhY2sgaGFuZGxlclwiLFxuICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbjogXCIgKyBlICsgXCI7IHN0YWNrID0gXCIgKyBlLnN0YWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBwdXNoKC4uLmFyZ3MpIHtcbiAgICB0aGlzLm1lbWJlcnMucHVzaCguLi5hcmdzKTtcbiAgfVxuICBjcmVhdGVQcm9taXNlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnB1c2goKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmVzb2x2ZUFsbChyZXN1bHQpIHtcbiAgICB0aGlzLmNhbGwobnVsbCwgcmVzdWx0KTtcbiAgfVxuICByZWplY3RBbGwoZXJyKSB7XG4gICAgdGhpcy5jYWxsKGVycik7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShsb2dnZXIsIG1lbWJlcnMpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBfTXVsdGljYXN0ZXIobG9nZ2VyLCBtZW1iZXJzKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbigoZXJyLCByZXN1bHQpID0+IGluc3RhbmNlLmNhbGwoZXJyLCByZXN1bHQpLCB7XG4gICAgICBwdXNoOiAoZm4pID0+IGluc3RhbmNlLnB1c2goZm4pLFxuICAgICAgY3JlYXRlUHJvbWlzZTogKCkgPT4gaW5zdGFuY2UuY3JlYXRlUHJvbWlzZSgpLFxuICAgICAgcmVzb2x2ZUFsbDogKHJlc3VsdCkgPT4gaW5zdGFuY2UucmVzb2x2ZUFsbChyZXN1bHQpLFxuICAgICAgcmVqZWN0QWxsOiAoZXJyKSA9PiBpbnN0YW5jZS5yZWplY3RBbGwoZXJyKVxuICAgIH0pO1xuICB9XG59O1xudmFyIG11bHRpY2FzdGVyX2RlZmF1bHQgPSBNdWx0aWNhc3RlcjtcblxuLy8gc3JjL2NvbW1vbi9jb25zdGFudHMvSHR0cE1ldGhvZHMudHNcbnZhciBIdHRwTWV0aG9kcyA9IC8qIEBfX1BVUkVfXyAqLyAoKEh0dHBNZXRob2RzMikgPT4ge1xuICBIdHRwTWV0aG9kczJbXCJHZXRcIl0gPSBcImdldFwiO1xuICBIdHRwTWV0aG9kczJbXCJEZWxldGVcIl0gPSBcImRlbGV0ZVwiO1xuICBIdHRwTWV0aG9kczJbXCJQb3N0XCJdID0gXCJwb3N0XCI7XG4gIEh0dHBNZXRob2RzMltcIlB1dFwiXSA9IFwicHV0XCI7XG4gIEh0dHBNZXRob2RzMltcIlBhdGNoXCJdID0gXCJwYXRjaFwiO1xuICByZXR1cm4gSHR0cE1ldGhvZHMyO1xufSkoSHR0cE1ldGhvZHMgfHwge30pO1xudmFyIEh0dHBNZXRob2RzX2RlZmF1bHQgPSBIdHRwTWV0aG9kcztcblxuLy8gc3JjL2NvbW1vbi9jb25zdGFudHMvSHR0cFN0YXR1c0NvZGVzLnRzXG52YXIgSHR0cFN0YXR1c0NvZGVzID0gLyogQF9fUFVSRV9fICovICgoSHR0cFN0YXR1c0NvZGVzMikgPT4ge1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJTdWNjZXNzXCJdID0gMjAwXSA9IFwiU3VjY2Vzc1wiO1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJOb0NvbnRlbnRcIl0gPSAyMDRdID0gXCJOb0NvbnRlbnRcIjtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiQmFkUmVxdWVzdFwiXSA9IDQwMF0gPSBcIkJhZFJlcXVlc3RcIjtcbiAgSHR0cFN0YXR1c0NvZGVzMltIdHRwU3RhdHVzQ29kZXMyW1wiVW5hdXRob3JpemVkXCJdID0gNDAxXSA9IFwiVW5hdXRob3JpemVkXCI7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIkZvcmJpZGRlblwiXSA9IDQwM10gPSBcIkZvcmJpZGRlblwiO1xuICBIdHRwU3RhdHVzQ29kZXMyW0h0dHBTdGF0dXNDb2RlczJbXCJSZXF1ZXN0VGltZW91dFwiXSA9IDQwOF0gPSBcIlJlcXVlc3RUaW1lb3V0XCI7XG4gIEh0dHBTdGF0dXNDb2RlczJbSHR0cFN0YXR1c0NvZGVzMltcIkludGVybmFsU2VydmVyRXJyb3JcIl0gPSA1MDBdID0gXCJJbnRlcm5hbFNlcnZlckVycm9yXCI7XG4gIHJldHVybiBIdHRwU3RhdHVzQ29kZXMyO1xufSkoSHR0cFN0YXR1c0NvZGVzIHx8IHt9KTtcbmZ1bmN0aW9uIGlzU3VjY2Vzc0NvZGUoc3RhdHVzQ29kZSkge1xuICByZXR1cm4gc3RhdHVzQ29kZSA+PSAyMDAgLyogU3VjY2VzcyAqLyAmJiBzdGF0dXNDb2RlIDwgNDAwIC8qIEJhZFJlcXVlc3QgKi87XG59XG52YXIgSHR0cFN0YXR1c0NvZGVzX2RlZmF1bHQgPSBIdHRwU3RhdHVzQ29kZXM7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9hdXRoLnRzXG52YXIgTUFYX1RPS0VOX0xFTkdUSCA9IE1hdGgucG93KDIsIDE3KTtcbmZ1bmN0aW9uIHJhbmRvbSgpIHtcbiAgcmV0dXJuIChcIjAwMDAwMFwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWUxNikpLnNsaWNlKC0xNik7XG59XG5mdW5jdGlvbiBpc1JlYWx0aW1lKGNsaWVudCkge1xuICByZXR1cm4gISFjbGllbnQuY29ubmVjdGlvbjtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZUF1dGhjYWxsYmFja0Vycm9yKGVycikge1xuICBpZiAoIWlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvKGVycikpIHtcbiAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhpbnNwZWN0RXJyb3IoZXJyKSwgZXJyLmNvZGUgfHwgNDAxNzAsIGVyci5zdGF0dXNDb2RlIHx8IDQwMSk7XG4gIH1cbiAgaWYgKCFlcnIuY29kZSkge1xuICAgIGlmIChlcnIuc3RhdHVzQ29kZSA9PT0gNDAzKSB7XG4gICAgICBlcnIuY29kZSA9IDQwMzAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnIuY29kZSA9IDQwMTcwO1xuICAgICAgZXJyLnN0YXR1c0NvZGUgPSA0MDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBlcnI7XG59XG52YXIgaG1hYyA9ICh0ZXh0LCBrZXkpID0+IHtcbiAgY29uc3QgYnVmZmVyVXRpbHMgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscztcbiAgY29uc3QgdGV4dEJ1ZmZlciA9IGJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUodGV4dCk7XG4gIGNvbnN0IGtleUJ1ZmZlciA9IGJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUoa2V5KTtcbiAgY29uc3QgZGlnZXN0ID0gYnVmZmVyVXRpbHMuaG1hY1NoYTI1Nih0ZXh0QnVmZmVyLCBrZXlCdWZmZXIpO1xuICByZXR1cm4gYnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKGRpZ2VzdCk7XG59O1xuZnVuY3Rpb24gYzE0bihjYXBhYmlsaXR5KSB7XG4gIGlmICghY2FwYWJpbGl0eSlcbiAgICByZXR1cm4gXCJcIjtcbiAgaWYgKHR5cGVvZiBjYXBhYmlsaXR5ID09IFwic3RyaW5nXCIpXG4gICAgY2FwYWJpbGl0eSA9IEpTT04ucGFyc2UoY2FwYWJpbGl0eSk7XG4gIGNvbnN0IGMxNG5DYXBhYmlsaXR5ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IGtleXMgPSBrZXlzQXJyYXkoY2FwYWJpbGl0eSwgdHJ1ZSk7XG4gIGlmICgha2V5cylcbiAgICByZXR1cm4gXCJcIjtcbiAga2V5cy5zb3J0KCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGMxNG5DYXBhYmlsaXR5W2tleXNbaV1dID0gY2FwYWJpbGl0eVtrZXlzW2ldXS5zb3J0KCk7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGMxNG5DYXBhYmlsaXR5KTtcbn1cbmZ1bmN0aW9uIGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKGF1dGhPcHRpb25zLCBsb2dnZXIpIHtcbiAgaWYgKGF1dGhPcHRpb25zLmF1dGhDYWxsYmFjaykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoKClcIiwgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aENhbGxiYWNrXCIpO1xuICB9IGVsc2UgaWYgKGF1dGhPcHRpb25zLmF1dGhVcmwpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aCgpXCIsIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhVcmxcIik7XG4gIH0gZWxzZSBpZiAoYXV0aE9wdGlvbnMua2V5KSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgoKVwiLCBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBjbGllbnQtc2lkZSBzaWduaW5nXCIpO1xuICB9IGVsc2UgaWYgKGF1dGhPcHRpb25zLnRva2VuRGV0YWlscykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoKClcIiwgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggc3VwcGxpZWQgdG9rZW4gb25seVwiKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtc2cgPSBcImF1dGhPcHRpb25zIG11c3QgaW5jbHVkZSB2YWxpZCBhdXRoZW50aWNhdGlvbiBwYXJhbWV0ZXJzXCI7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKGxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGgoKVwiLCBtc2cpO1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBiYXNpY0F1dGhGb3JjZWQob3B0aW9ucykge1xuICByZXR1cm4gXCJ1c2VUb2tlbkF1dGhcIiBpbiBvcHRpb25zICYmICFvcHRpb25zLnVzZVRva2VuQXV0aDtcbn1cbmZ1bmN0aW9uIHVzZVRva2VuQXV0aChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnVzZVRva2VuQXV0aCB8fCAhYmFzaWNBdXRoRm9yY2VkKG9wdGlvbnMpICYmIChvcHRpb25zLmF1dGhDYWxsYmFjayB8fCBvcHRpb25zLmF1dGhVcmwgfHwgb3B0aW9ucy50b2tlbiB8fCBvcHRpb25zLnRva2VuRGV0YWlscyk7XG59XG5mdW5jdGlvbiBub1dheVRvUmVuZXcob3B0aW9ucykge1xuICByZXR1cm4gIW9wdGlvbnMua2V5ICYmICFvcHRpb25zLmF1dGhDYWxsYmFjayAmJiAhb3B0aW9ucy5hdXRoVXJsO1xufVxudmFyIHRySWQgPSAwO1xuZnVuY3Rpb24gZ2V0VG9rZW5SZXF1ZXN0SWQoKSB7XG4gIHJldHVybiB0cklkKys7XG59XG52YXIgQXV0aCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBvcHRpb25zKSB7XG4gICAgLy8gVGhpcyBpbml0aWFsaXphdGlvbiBpcyBhbHdheXMgb3ZlcndyaXR0ZW4gYW5kIG9ubHkgdXNlZCB0byBwcmV2ZW50IGEgVHlwZVNjcmlwdCBjb21waWxlciBlcnJvclxuICAgIHRoaXMuYXV0aE9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLnRva2VuUGFyYW1zID0gb3B0aW9ucy5kZWZhdWx0VG9rZW5QYXJhbXMgfHwge307XG4gICAgdGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPSBudWxsO1xuICAgIHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKHVzZVRva2VuQXV0aChvcHRpb25zKSkge1xuICAgICAgaWYgKG5vV2F5VG9SZW5ldyhvcHRpb25zKSkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgIFwiQXV0aCgpXCIsXG4gICAgICAgICAgXCJXYXJuaW5nOiBsaWJyYXJ5IGluaXRpYWxpemVkIHdpdGggYSB0b2tlbiBsaXRlcmFsIHdpdGhvdXQgYW55IHdheSB0byByZW5ldyB0aGUgdG9rZW4gd2hlbiBpdCBleHBpcmVzIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSkuIFNlZSBodHRwczovL2hlbHAuYWJseS5pby9lcnJvci80MDE3MSBmb3IgaGVscFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zYXZlVG9rZW5PcHRpb25zKG9wdGlvbnMuZGVmYXVsdFRva2VuUGFyYW1zLCBvcHRpb25zKTtcbiAgICAgIGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKHRoaXMuYXV0aE9wdGlvbnMsIHRoaXMubG9nZ2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFvcHRpb25zLmtleSkge1xuICAgICAgICBjb25zdCBtc2cgPSBcIk5vIGF1dGhlbnRpY2F0aW9uIG9wdGlvbnMgcHJvdmlkZWQ7IG5lZWQgb25lIG9mOiBrZXksIGF1dGhVcmwsIG9yIGF1dGhDYWxsYmFjayAob3IgZm9yIHRlc3Rpbmcgb25seSwgdG9rZW4gb3IgdG9rZW5EZXRhaWxzKVwiO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJBdXRoKClcIiwgbXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhtc2csIDQwMTYwLCA0MDEpO1xuICAgICAgfVxuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aCgpXCIsIFwiYW5vbnltb3VzLCB1c2luZyBiYXNpYyBhdXRoXCIpO1xuICAgICAgdGhpcy5fc2F2ZUJhc2ljT3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGxvZ2dlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQubG9nZ2VyO1xuICB9XG4gIGFzeW5jIGF1dGhvcml6ZSh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcbiAgICBpZiAoYXV0aE9wdGlvbnMgJiYgYXV0aE9wdGlvbnMua2V5ICYmIHRoaXMuYXV0aE9wdGlvbnMua2V5ICE9PSBhdXRoT3B0aW9ucy5rZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gdXBkYXRlIGF1dGggb3B0aW9ucyB3aXRoIGluY29tcGF0aWJsZSBrZXlcIiwgNDAxMDIsIDQwMSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgdG9rZW5EZXRhaWxzID0gYXdhaXQgdGhpcy5fZm9yY2VOZXdUb2tlbih0b2tlblBhcmFtcyAhPSBudWxsID8gdG9rZW5QYXJhbXMgOiBudWxsLCBhdXRoT3B0aW9ucyAhPSBudWxsID8gYXV0aE9wdGlvbnMgOiBudWxsKTtcbiAgICAgIGlmIChpc1JlYWx0aW1lKHRoaXMuY2xpZW50KSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHRoaXMuY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZChcbiAgICAgICAgICAgIHRva2VuRGV0YWlscyxcbiAgICAgICAgICAgIChlcnIsIHRva2VuRGV0YWlsczIpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSh0b2tlbkRldGFpbHMyKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRva2VuRGV0YWlscztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0aGlzLmNsaWVudC5jb25uZWN0aW9uICYmIGVyci5zdGF0dXNDb2RlID09PSBIdHRwU3RhdHVzQ29kZXNfZGVmYXVsdC5Gb3JiaWRkZW4pIHtcbiAgICAgICAgdGhpcy5jbGllbnQuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICAvKiBGb3IgaW50ZXJuYWwgdXNlLCBlZyBieSBjb25uZWN0aW9uTWFuYWdlciAtIHVzZWZ1bCB3aGVuIHdhbnQgdG8gY2FsbCBiYWNrXG4gICAqIGFzIHNvb24gYXMgd2UgaGF2ZSB0aGUgbmV3IHRva2VuLCByYXRoZXIgdGhhbiB3YWl0aW5nIGZvciBpdCB0byB0YWtlXG4gICAqIGVmZmVjdCBvbiB0aGUgY29ubmVjdGlvbiBhcyAjYXV0aG9yaXplIGRvZXMgKi9cbiAgYXN5bmMgX2ZvcmNlTmV3VG9rZW4odG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKSB7XG4gICAgdGhpcy50b2tlbkRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMuX3NhdmVUb2tlbk9wdGlvbnModG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKTtcbiAgICBsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZCh0aGlzLmF1dGhPcHRpb25zLCB0aGlzLmxvZ2dlcik7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyh0cnVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGVsZXRlIHRoaXMudG9rZW5QYXJhbXMudGltZXN0YW1wO1xuICAgICAgZGVsZXRlIHRoaXMuYXV0aE9wdGlvbnMucXVlcnlUaW1lO1xuICAgIH1cbiAgfVxuICBhc3luYyByZXF1ZXN0VG9rZW4odG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRBdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHRoaXMuYXV0aE9wdGlvbnM7XG4gICAgY29uc3QgcmVzb2x2ZWRUb2tlblBhcmFtcyA9IHRva2VuUGFyYW1zIHx8IGNvcHkodGhpcy50b2tlblBhcmFtcyk7XG4gICAgbGV0IHRva2VuUmVxdWVzdENhbGxiYWNrLCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBpZiAocmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2spIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGgucmVxdWVzdFRva2VuKClcIiwgXCJ1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aENhbGxiYWNrXCIpO1xuICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2sgPSByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhDYWxsYmFjaztcbiAgICB9IGVsc2UgaWYgKHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLCBcInVzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoVXJsXCIpO1xuICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2sgPSAocGFyYW1zLCBjYikgPT4ge1xuICAgICAgICBjb25zdCBhdXRoSGVhZGVycyA9IG1peGluKFxuICAgICAgICAgIHsgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW5cIiB9LFxuICAgICAgICAgIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aEhlYWRlcnNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdXNlUG9zdCA9IHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aE1ldGhvZCAmJiByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhNZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJwb3N0XCI7XG4gICAgICAgIGxldCBwcm92aWRlZFFzUGFyYW1zO1xuICAgICAgICBjb25zdCBxdWVyeUlkeCA9IHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybC5pbmRleE9mKFwiP1wiKTtcbiAgICAgICAgaWYgKHF1ZXJ5SWR4ID4gLTEpIHtcbiAgICAgICAgICBwcm92aWRlZFFzUGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhyZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwuc2xpY2UocXVlcnlJZHgpKTtcbiAgICAgICAgICByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwgPSByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhVcmwuc2xpY2UoMCwgcXVlcnlJZHgpO1xuICAgICAgICAgIGlmICghdXNlUG9zdCkge1xuICAgICAgICAgICAgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoUGFyYW1zID0gbWl4aW4oXG4gICAgICAgICAgICAgIHByb3ZpZGVkUXNQYXJhbXMsXG4gICAgICAgICAgICAgIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFBhcmFtc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXV0aFBhcmFtcyA9IG1peGluKHt9LCByZXNvbHZlZEF1dGhPcHRpb25zLmF1dGhQYXJhbXMgfHwge30sIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2sgPSAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICAgICAgbGV0IGJvZHkgPSAoX2EyID0gcmVzdWx0LmJvZHkpICE9IG51bGwgPyBfYTIgOiBudWxsO1xuICAgICAgICAgIGxldCBjb250ZW50VHlwZSA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2tcIixcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBFcnJvcjogXCIgKyBpbnNwZWN0RXJyb3IocmVzdWx0LmVycm9yKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGVIZWFkZXJPckhlYWRlcnMgPSAoX2IgPSByZXN1bHQuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSkgIT0gbnVsbCA/IF9iIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnRUeXBlSGVhZGVyT3JIZWFkZXJzKSkge1xuICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlSGVhZGVyT3JIZWFkZXJzLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGVIZWFkZXJPckhlYWRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgICAgIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFja1wiLFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkOyBjb250ZW50LXR5cGU6IFwiICsgY29udGVudFR5cGUgKyBcIjsgYm9keTogXCIgKyBpbnNwZWN0Qm9keShib2R5KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgY2IocmVzdWx0LmVycm9yLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdC51bnBhY2tlZCkge1xuICAgICAgICAgICAgY2IobnVsbCwgYm9keSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihib2R5KSlcbiAgICAgICAgICAgIGJvZHkgPSBib2R5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgaWYgKCFjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgY2IobmV3IEVycm9ySW5mbyhcImF1dGhVcmwgcmVzcG9uc2UgaXMgbWlzc2luZyBhIGNvbnRlbnQtdHlwZSBoZWFkZXJcIiwgNDAxNzAsIDQwMSksIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBqc29uID0gY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikgPiAtMSwgdGV4dCA9IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJ0ZXh0L3BsYWluXCIpID4gLTEgfHwgY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2p3dFwiKSA+IC0xO1xuICAgICAgICAgIGlmICghanNvbiAmJiAhdGV4dCkge1xuICAgICAgICAgICAgY2IoXG4gICAgICAgICAgICAgIG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgXCJhdXRoVXJsIHJlc3BvbmRlZCB3aXRoIHVuYWNjZXB0YWJsZSBjb250ZW50LXR5cGUgXCIgKyBjb250ZW50VHlwZSArIFwiLCBzaG91bGQgYmUgZWl0aGVyIHRleHQvcGxhaW4sIGFwcGxpY2F0aW9uL2p3dCBvciBhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgNDAxNzAsXG4gICAgICAgICAgICAgICAgNDAxXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICBpZiAoYm9keS5sZW5ndGggPiBNQVhfVE9LRU5fTEVOR1RIKSB7XG4gICAgICAgICAgICAgIGNiKG5ldyBFcnJvckluZm8oXCJhdXRoVXJsIHJlc3BvbnNlIGV4Y2VlZGVkIG1heCBwZXJtaXR0ZWQgbGVuZ3RoXCIsIDQwMTcwLCA0MDEpLCBudWxsKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNiKFxuICAgICAgICAgICAgICAgIG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgZXJyb3IgcHJvY2Vzc2luZyBhdXRoVVJMIHJlc3BvbnNlOyBlcnIgPSBcIiArIGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIDQwMTcwLFxuICAgICAgICAgICAgICAgICAgNDAxXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2IobnVsbCwgYm9keSwgY29udGVudFR5cGUpO1xuICAgICAgICB9O1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICAgIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFja1wiLFxuICAgICAgICAgIFwiUmVxdWVzdGluZyB0b2tlbiBmcm9tIFwiICsgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsICsgXCI7IFBhcmFtczogXCIgKyBKU09OLnN0cmluZ2lmeShhdXRoUGFyYW1zKSArIFwiOyBtZXRob2Q6IFwiICsgKHVzZVBvc3QgPyBcIlBPU1RcIiA6IFwiR0VUXCIpXG4gICAgICAgICk7XG4gICAgICAgIGlmICh1c2VQb3N0KSB7XG4gICAgICAgICAgY29uc3QgaGVhZGVycyA9IGF1dGhIZWFkZXJzIHx8IHt9O1xuICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiO1xuICAgICAgICAgIGNvbnN0IGJvZHkgPSB0b1F1ZXJ5U3RyaW5nKGF1dGhQYXJhbXMpLnNsaWNlKDEpO1xuICAgICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhcbiAgICAgICAgICAgIHRoaXMuY2xpZW50Lmh0dHAuZG9VcmkoXG4gICAgICAgICAgICAgIEh0dHBNZXRob2RzX2RlZmF1bHQuUG9zdCxcbiAgICAgICAgICAgICAgcmVzb2x2ZWRBdXRoT3B0aW9ucy5hdXRoVXJsLFxuICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICBwcm92aWRlZFFzUGFyYW1zXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGVyciwgcmVzdWx0KSA9PiBlcnIgPyBhdXRoVXJsUmVxdWVzdENhbGxiYWNrKGVycikgOiBhdXRoVXJsUmVxdWVzdENhbGxiYWNrKHJlc3VsdClcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhcbiAgICAgICAgICAgIHRoaXMuY2xpZW50Lmh0dHAuZG9VcmkoSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsIHJlc29sdmVkQXV0aE9wdGlvbnMuYXV0aFVybCwgYXV0aEhlYWRlcnMgfHwge30sIG51bGwsIGF1dGhQYXJhbXMpLFxuICAgICAgICAgICAgKGVyciwgcmVzdWx0KSA9PiBlcnIgPyBhdXRoVXJsUmVxdWVzdENhbGxiYWNrKGVycikgOiBhdXRoVXJsUmVxdWVzdENhbGxiYWNrKHJlc3VsdClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZWRBdXRoT3B0aW9ucy5rZXkpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsXG4gICAgICAgIFwidXNpbmcgdG9rZW4gYXV0aCB3aXRoIGNsaWVudC1zaWRlIHNpZ25pbmdcIlxuICAgICAgKTtcbiAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrID0gKHBhcmFtcywgY2IpID0+IHtcbiAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKFxuICAgICAgICAgIHRoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0KHBhcmFtcywgcmVzb2x2ZWRBdXRoT3B0aW9ucyksXG4gICAgICAgICAgKGVyciwgcmVzdWx0KSA9PiBjYihlcnIsIHJlc3VsdCAhPSBudWxsID8gcmVzdWx0IDogbnVsbClcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiTmVlZCBhIG5ldyB0b2tlbiwgYnV0IGF1dGhPcHRpb25zIGRvZXMgbm90IGluY2x1ZGUgYW55IHdheSB0byByZXF1ZXN0IG9uZSAobm8gYXV0aFVybCwgYXV0aENhbGxiYWNrLCBvciBrZXkpXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQXV0aCgpXCIsXG4gICAgICAgIFwibGlicmFyeSBpbml0aWFsaXplZCB3aXRoIGEgdG9rZW4gbGl0ZXJhbCB3aXRob3V0IGFueSB3YXkgdG8gcmVuZXcgdGhlIHRva2VuIHdoZW4gaXQgZXhwaXJlcyAobm8gYXV0aFVybCwgYXV0aENhbGxiYWNrLCBvciBrZXkpLiBTZWUgaHR0cHM6Ly9oZWxwLmFibHkuaW8vZXJyb3IvNDAxNzEgZm9yIGhlbHBcIlxuICAgICAgKTtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8obXNnLCA0MDE3MSwgNDAzKTtcbiAgICB9XG4gICAgaWYgKFwiY2FwYWJpbGl0eVwiIGluIHJlc29sdmVkVG9rZW5QYXJhbXMpXG4gICAgICByZXNvbHZlZFRva2VuUGFyYW1zLmNhcGFiaWxpdHkgPSBjMTRuKFxuICAgICAgICByZXNvbHZlZFRva2VuUGFyYW1zLmNhcGFiaWxpdHlcbiAgICAgICk7XG4gICAgY29uc3QgdG9rZW5SZXF1ZXN0ID0gKHNpZ25lZFRva2VuUGFyYW1zLCB0b2tlbkNiKSA9PiB7XG4gICAgICBjb25zdCBrZXlOYW1lID0gc2lnbmVkVG9rZW5QYXJhbXMua2V5TmFtZSwgcGF0aCA9IFwiL2tleXMvXCIgKyBrZXlOYW1lICsgXCIvcmVxdWVzdFRva2VuXCIsIHRva2VuVXJpID0gZnVuY3Rpb24oaG9zdCkge1xuICAgICAgICByZXR1cm4gY2xpZW50LmJhc2VVcmkoaG9zdCkgKyBwYXRoO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucyk7XG4gICAgICBpZiAocmVzb2x2ZWRBdXRoT3B0aW9ucy5yZXF1ZXN0SGVhZGVycylcbiAgICAgICAgbWl4aW4ocmVxdWVzdEhlYWRlcnMsIHJlc29sdmVkQXV0aE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkF1dGgucmVxdWVzdFRva2VuKCkucmVxdWVzdFRva2VuXCIsXG4gICAgICAgIFwiU2VuZGluZyBQT1NUIHRvIFwiICsgcGF0aCArIFwiOyBUb2tlbiBwYXJhbXM6IFwiICsgSlNPTi5zdHJpbmdpZnkoc2lnbmVkVG9rZW5QYXJhbXMpXG4gICAgICApO1xuICAgICAgd2hlblByb21pc2VTZXR0bGVzKFxuICAgICAgICB0aGlzLmNsaWVudC5odHRwLmRvKEh0dHBNZXRob2RzX2RlZmF1bHQuUG9zdCwgdG9rZW5VcmksIHJlcXVlc3RIZWFkZXJzLCBKU09OLnN0cmluZ2lmeShzaWduZWRUb2tlblBhcmFtcyksIG51bGwpLFxuICAgICAgICAoZXJyLCByZXN1bHQpID0+IGVyciA/IHRva2VuQ2IoZXJyKSA6IHRva2VuQ2IocmVzdWx0LmVycm9yLCByZXN1bHQuYm9keSwgcmVzdWx0LnVucGFja2VkKVxuICAgICAgKTtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgdG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0RXhwaXJlZCA9IGZhbHNlLCB0aW1lb3V0TGVuZ3RoID0gdGhpcy5jbGllbnQub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0LCB0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0RXhwaXJlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IG1zZyA9IFwiVG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0aW1lZCBvdXQgYWZ0ZXIgXCIgKyB0aW1lb3V0TGVuZ3RoIC8gMWUzICsgXCIgc2Vjb25kc1wiO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsIG1zZyk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKG1zZywgNDAxNzAsIDQwMSkpO1xuICAgICAgfSwgdGltZW91dExlbmd0aCk7XG4gICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayhyZXNvbHZlZFRva2VuUGFyYW1zLCAoZXJyLCB0b2tlblJlcXVlc3RPckRldGFpbHMsIGNvbnRlbnRUeXBlKSA9PiB7XG4gICAgICAgIGlmICh0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dCk7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLFxuICAgICAgICAgICAgXCJ0b2tlbiByZXF1ZXN0IHNpZ25pbmcgY2FsbCByZXR1cm5lZCBlcnJvcjsgZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVqZWN0KG5vcm1hbGlzZUF1dGhjYWxsYmFja0Vycm9yKGVycikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmICh0b2tlblJlcXVlc3RPckRldGFpbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIlRva2VuIHN0cmluZyBpcyBlbXB0eVwiLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlblJlcXVlc3RPckRldGFpbHMubGVuZ3RoID4gTUFYX1RPS0VOX0xFTkdUSCkge1xuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgICAgIFwiVG9rZW4gc3RyaW5nIGV4Y2VlZGVkIG1heCBwZXJtaXR0ZWQgbGVuZ3RoICh3YXMgXCIgKyB0b2tlblJlcXVlc3RPckRldGFpbHMubGVuZ3RoICsgXCIgYnl0ZXMpXCIsXG4gICAgICAgICAgICAgICAgNDAxNzAsXG4gICAgICAgICAgICAgICAgNDAxXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlblJlcXVlc3RPckRldGFpbHMgPT09IFwidW5kZWZpbmVkXCIgfHwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSBcIm51bGxcIikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJUb2tlbiBzdHJpbmcgd2FzIGxpdGVyYWwgbnVsbC91bmRlZmluZWRcIiwgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5SZXF1ZXN0T3JEZXRhaWxzWzBdID09PSBcIntcIiAmJiAhKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qd3RcIikgPiAtMSkpIHtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgICBcIlRva2VuIHdhcyBkb3VibGUtZW5jb2RlZDsgbWFrZSBzdXJlIHlvdSdyZSBub3QgSlNPTi1lbmNvZGluZyBhbiBhbHJlYWR5IGVuY29kZWQgdG9rZW4gcmVxdWVzdCBvciBkZXRhaWxzXCIsXG4gICAgICAgICAgICAgICAgNDAxNzAsXG4gICAgICAgICAgICAgICAgNDAxXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoeyB0b2tlbjogdG9rZW5SZXF1ZXN0T3JEZXRhaWxzIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlblJlcXVlc3RPckRldGFpbHMgIT09IFwib2JqZWN0XCIgfHwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gXCJFeHBlY3RlZCB0b2tlbiByZXF1ZXN0IGNhbGxiYWNrIHRvIGNhbGwgYmFjayB3aXRoIGEgdG9rZW4gc3RyaW5nIG9yIHRva2VuIHJlcXVlc3QvZGV0YWlscyBvYmplY3QsIGJ1dCBnb3QgYSBcIiArIHR5cGVvZiB0b2tlblJlcXVlc3RPckRldGFpbHM7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLCBtc2cpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKG1zZywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYmplY3RTaXplID0gSlNPTi5zdHJpbmdpZnkodG9rZW5SZXF1ZXN0T3JEZXRhaWxzKS5sZW5ndGg7XG4gICAgICAgIGlmIChvYmplY3RTaXplID4gTUFYX1RPS0VOX0xFTkdUSCAmJiAhcmVzb2x2ZWRBdXRoT3B0aW9ucy5zdXBwcmVzc01heExlbmd0aENoZWNrKSB7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgICAgXCJUb2tlbiByZXF1ZXN0L2RldGFpbHMgb2JqZWN0IGV4Y2VlZGVkIG1heCBwZXJtaXR0ZWQgc3RyaW5naWZpZWQgc2l6ZSAod2FzIFwiICsgb2JqZWN0U2l6ZSArIFwiIGJ5dGVzKVwiLFxuICAgICAgICAgICAgICA0MDE3MCxcbiAgICAgICAgICAgICAgNDAxXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiaXNzdWVkXCIgaW4gdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0b2tlblJlcXVlc3RPckRldGFpbHMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShcImtleU5hbWVcIiBpbiB0b2tlblJlcXVlc3RPckRldGFpbHMpKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gXCJFeHBlY3RlZCB0b2tlbiByZXF1ZXN0IGNhbGxiYWNrIHRvIGNhbGwgYmFjayB3aXRoIGEgdG9rZW4gc3RyaW5nLCB0b2tlbiByZXF1ZXN0IG9iamVjdCwgb3IgdG9rZW4gZGV0YWlscyBvYmplY3RcIjtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJBdXRoLnJlcXVlc3RUb2tlbigpXCIsIG1zZyk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8obXNnLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuUmVxdWVzdCh0b2tlblJlcXVlc3RPckRldGFpbHMsIChlcnIyLCB0b2tlblJlc3BvbnNlLCB1bnBhY2tlZCkgPT4ge1xuICAgICAgICAgIGlmIChlcnIyKSB7XG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICAgIFwiQXV0aC5yZXF1ZXN0VG9rZW4oKVwiLFxuICAgICAgICAgICAgICBcInRva2VuIHJlcXVlc3QgQVBJIGNhbGwgcmV0dXJuZWQgZXJyb3I7IGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycjIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVqZWN0KG5vcm1hbGlzZUF1dGhjYWxsYmFja0Vycm9yKGVycjIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF1bnBhY2tlZClcbiAgICAgICAgICAgIHRva2VuUmVzcG9uc2UgPSBKU09OLnBhcnNlKHRva2VuUmVzcG9uc2UpO1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkF1dGguZ2V0VG9rZW4oKVwiLCBcInRva2VuIHJlY2VpdmVkXCIpO1xuICAgICAgICAgIHJlc29sdmUodG9rZW5SZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgc2lnbiBhIHRva2VuIHJlcXVlc3QgYmFzZWQgb24gdGhlIGdpdmVuIG9wdGlvbnMuXG4gICAqIE5PVEUgdGhpcyBjYW4gb25seSBiZSB1c2VkIHdoZW4gdGhlIGtleSB2YWx1ZSBpcyBhdmFpbGFibGUgbG9jYWxseS5cbiAgICogT3RoZXJ3aXNlLCBzaWduZWQgdG9rZW4gcmVxdWVzdHMgbXVzdCBiZSBvYnRhaW5lZCBmcm9tIHRoZSBrZXlcbiAgICogb3duZXIgKGVpdGhlciB1c2luZyB0aGUgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayBvciB1cmwpLlxuICAgKlxuICAgKiBAcGFyYW0gYXV0aE9wdGlvbnNcbiAgICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3Qgb3B0aW9uczpcbiAgICogLSBrZXk6ICAgICAgICAgICB0aGUga2V5IHRvIHVzZS4gSWYgbm90IHNwZWNpZmllZCwgYSBrZXkgcGFzc2VkIGluIGNvbnN0cnVjdGluZ1xuICAgKiAgICAgICAgICAgICAgICAgIHRoZSBSZXN0IGludGVyZmFjZSB3aWxsIGJlIHVzZWRcbiAgICpcbiAgICogLSBxdWVyeVRpbWUgICAgICAob3B0aW9uYWwpIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBhYmx5IHN5c3RlbSBzaG91bGQgYmVcbiAgICogICAgICAgICAgICAgICAgICBxdWVyaWVkIGZvciB0aGUgY3VycmVudCB0aW1lIHdoZW4gbm9uZSBpcyBzcGVjaWZpZWQgZXhwbGljaXRseVxuICAgKlxuICAgKiAtIHJlcXVlc3RIZWFkZXJzIChvcHRpb25hbCwgdW5zdXBwb3J0ZWQsIGZvciB0ZXN0aW5nIG9ubHkpIGV4dHJhIGhlYWRlcnMgdG8gYWRkIHRvIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbiByZXF1ZXN0XG4gICAqXG4gICAqIEBwYXJhbSB0b2tlblBhcmFtc1xuICAgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3RlZCB0b2tlbjpcbiAgICogLSB0dGw6ICAgICAgIChvcHRpb25hbCkgdGhlIHJlcXVlc3RlZCBsaWZlIG9mIHRoZSB0b2tlbiBpbiBtcy4gSWYgbm9uZSBpcyBzcGVjaWZpZWRcbiAgICogICAgICAgICAgICAgICAgICBhIGRlZmF1bHQgb2YgMSBob3VyIGlzIHByb3ZpZGVkLiBUaGUgbWF4aW11bSBsaWZldGltZSBpcyAyNGhvdXJzOyBhbnkgcmVxdWVzdFxuICAgKiAgICAgICAgICAgICAgICAgIGV4Y2VlZGluZyB0aGF0IGxpZmV0aW1lIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvci5cbiAgICpcbiAgICogLSBjYXBhYmlsaXR5OiAgICAob3B0aW9uYWwpIHRoZSBjYXBhYmlsaXR5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAqICAgICAgICAgICAgICAgICAgSWYgbm9uZSBpcyBzcGVjaWZpZWQsIGEgdG9rZW4gd2lsbCBiZSByZXF1ZXN0ZWQgd2l0aCBhbGwgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzIG9mIHRoZSBzcGVjaWZpZWQga2V5LlxuICAgKlxuICAgKiAtIGNsaWVudElkOiAgICAgIChvcHRpb25hbCkgYSBjbGllbnQgSUQgdG8gYXNzb2NpYXRlIHdpdGggdGhlIHRva2VuOyBpZiBub3RcbiAgICogICAgICAgICAgICAgICAgICBzcGVjaWZpZWQsIGEgY2xpZW50SWQgcGFzc2VkIGluIGNvbnN0cnVjdGluZyB0aGUgUmVzdCBpbnRlcmZhY2Ugd2lsbCBiZSB1c2VkXG4gICAqXG4gICAqIC0gdGltZXN0YW1wOiAgICAgKG9wdGlvbmFsKSB0aGUgdGltZSBpbiBtcyBzaW5jZSB0aGUgZXBvY2guIElmIG5vbmUgaXMgc3BlY2lmaWVkLFxuICAgKiAgICAgICAgICAgICAgICAgIHRoZSBzeXN0ZW0gd2lsbCBiZSBxdWVyaWVkIGZvciBhIHRpbWUgdmFsdWUgdG8gdXNlLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlVG9rZW5SZXF1ZXN0KHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgIGF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwgdGhpcy5hdXRoT3B0aW9ucztcbiAgICB0b2tlblBhcmFtcyA9IHRva2VuUGFyYW1zIHx8IGNvcHkodGhpcy50b2tlblBhcmFtcyk7XG4gICAgY29uc3Qga2V5ID0gYXV0aE9wdGlvbnMua2V5O1xuICAgIGlmICgha2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiTm8ga2V5IHNwZWNpZmllZFwiLCA0MDEwMSwgNDAzKTtcbiAgICB9XG4gICAgY29uc3Qga2V5UGFydHMgPSBrZXkuc3BsaXQoXCI6XCIpLCBrZXlOYW1lID0ga2V5UGFydHNbMF0sIGtleVNlY3JldCA9IGtleVBhcnRzWzFdO1xuICAgIGlmICgha2V5U2VjcmV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiSW52YWxpZCBrZXkgc3BlY2lmaWVkXCIsIDQwMTAxLCA0MDMpO1xuICAgIH1cbiAgICBpZiAodG9rZW5QYXJhbXMuY2xpZW50SWQgPT09IFwiXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJjbGllbnRJZCBjYW5cXHUyMDE5dCBiZSBhbiBlbXB0eSBzdHJpbmdcIiwgNDAwMTIsIDQwMCk7XG4gICAgfVxuICAgIGlmIChcImNhcGFiaWxpdHlcIiBpbiB0b2tlblBhcmFtcykge1xuICAgICAgdG9rZW5QYXJhbXMuY2FwYWJpbGl0eSA9IGMxNG4odG9rZW5QYXJhbXMuY2FwYWJpbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3QgPSBtaXhpbih7IGtleU5hbWUgfSwgdG9rZW5QYXJhbXMpLCBjbGllbnRJZCA9IHRva2VuUGFyYW1zLmNsaWVudElkIHx8IFwiXCIsIHR0bCA9IHRva2VuUGFyYW1zLnR0bCB8fCBcIlwiLCBjYXBhYmlsaXR5ID0gdG9rZW5QYXJhbXMuY2FwYWJpbGl0eSB8fCBcIlwiO1xuICAgIGlmICghcmVxdWVzdC50aW1lc3RhbXApIHtcbiAgICAgIHJlcXVlc3QudGltZXN0YW1wID0gYXdhaXQgdGhpcy5nZXRUaW1lc3RhbXAoYXV0aE9wdGlvbnMgJiYgYXV0aE9wdGlvbnMucXVlcnlUaW1lKTtcbiAgICB9XG4gICAgY29uc3Qgbm9uY2UgPSByZXF1ZXN0Lm5vbmNlIHx8IChyZXF1ZXN0Lm5vbmNlID0gcmFuZG9tKCkpLCB0aW1lc3RhbXAgPSByZXF1ZXN0LnRpbWVzdGFtcDtcbiAgICBjb25zdCBzaWduVGV4dCA9IHJlcXVlc3Qua2V5TmFtZSArIFwiXFxuXCIgKyB0dGwgKyBcIlxcblwiICsgY2FwYWJpbGl0eSArIFwiXFxuXCIgKyBjbGllbnRJZCArIFwiXFxuXCIgKyB0aW1lc3RhbXAgKyBcIlxcblwiICsgbm9uY2UgKyBcIlxcblwiO1xuICAgIHJlcXVlc3QubWFjID0gcmVxdWVzdC5tYWMgfHwgaG1hYyhzaWduVGV4dCwga2V5U2VjcmV0KTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJBdXRoLmdldFRva2VuUmVxdWVzdCgpXCIsIFwiZ2VuZXJhdGVkIHNpZ25lZCByZXF1ZXN0XCIpO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGF1dGggcXVlcnkgcGFyYW1zIHRvIHVzZSBmb3IgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbixcbiAgICogYmFzZWQgb24gdGhlIGN1cnJlbnQgYXV0aCBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRBdXRoUGFyYW1zKCkge1xuICAgIGlmICh0aGlzLm1ldGhvZCA9PSBcImJhc2ljXCIpXG4gICAgICByZXR1cm4geyBrZXk6IHRoaXMua2V5IH07XG4gICAgZWxzZSB7XG4gICAgICBsZXQgdG9rZW5EZXRhaWxzID0gYXdhaXQgdGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UpO1xuICAgICAgaWYgKCF0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aC5nZXRBdXRoUGFyYW1zKCk6IF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyByZXR1cm5lZCBubyBlcnJvciBvciB0b2tlbkRldGFpbHNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBhY2Nlc3NfdG9rZW46IHRva2VuRGV0YWlscy50b2tlbiB9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhdXRob3JpemF0aW9uIGhlYWRlciB0byB1c2UgZm9yIGEgUkVTVCBvciBjb21ldCByZXF1ZXN0LFxuICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBhdXRoIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEF1dGhIZWFkZXJzKCkge1xuICAgIGlmICh0aGlzLm1ldGhvZCA9PSBcImJhc2ljXCIpIHtcbiAgICAgIHJldHVybiB7IGF1dGhvcml6YXRpb246IFwiQmFzaWMgXCIgKyB0aGlzLmJhc2ljS2V5IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRva2VuRGV0YWlscyA9IGF3YWl0IHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZhbHNlKTtcbiAgICAgIGlmICghdG9rZW5EZXRhaWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGguZ2V0QXV0aFBhcmFtcygpOiBfZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMgcmV0dXJuZWQgbm8gZXJyb3Igb3IgdG9rZW5EZXRhaWxzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgYXV0aG9yaXphdGlvbjogXCJCZWFyZXIgXCIgKyB0b0Jhc2U2NCh0b2tlbkRldGFpbHMudG9rZW4pIH07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdGltZSBiYXNlZCBvbiB0aGUgbG9jYWwgY2xvY2ssXG4gICAqIG9yIGlmIHRoZSBvcHRpb24gcXVlcnlUaW1lIGlzIHRydWUsIHJldHVybiB0aGUgc2VydmVyIHRpbWUuXG4gICAqIFRoZSBzZXJ2ZXIgdGltZSBvZmZzZXQgZnJvbSB0aGUgbG9jYWwgdGltZSBpcyBzdG9yZWQgc28gdGhhdFxuICAgKiBvbmx5IG9uZSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdG8gZ2V0IHRoZSB0aW1lIGlzIGV2ZXIgbmVlZGVkXG4gICAqL1xuICBhc3luYyBnZXRUaW1lc3RhbXAocXVlcnlUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVGltZU9mZnNldFNldCgpICYmIChxdWVyeVRpbWUgfHwgdGhpcy5hdXRoT3B0aW9ucy5xdWVyeVRpbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGllbnQudGltZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCgpO1xuICAgIH1cbiAgfVxuICBnZXRUaW1lc3RhbXBVc2luZ09mZnNldCgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKSArICh0aGlzLmNsaWVudC5zZXJ2ZXJUaW1lT2Zmc2V0IHx8IDApO1xuICB9XG4gIGlzVGltZU9mZnNldFNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuc2VydmVyVGltZU9mZnNldCAhPT0gbnVsbDtcbiAgfVxuICBfc2F2ZUJhc2ljT3B0aW9ucyhhdXRoT3B0aW9ucykge1xuICAgIHRoaXMubWV0aG9kID0gXCJiYXNpY1wiO1xuICAgIHRoaXMua2V5ID0gYXV0aE9wdGlvbnMua2V5O1xuICAgIHRoaXMuYmFzaWNLZXkgPSB0b0Jhc2U2NChhdXRoT3B0aW9ucy5rZXkpO1xuICAgIHRoaXMuYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoXCJjbGllbnRJZFwiIGluIGF1dGhPcHRpb25zKSB7XG4gICAgICB0aGlzLl91c2VyU2V0Q2xpZW50SWQoYXV0aE9wdGlvbnMuY2xpZW50SWQpO1xuICAgIH1cbiAgfVxuICBfc2F2ZVRva2VuT3B0aW9ucyh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcbiAgICB0aGlzLm1ldGhvZCA9IFwidG9rZW5cIjtcbiAgICBpZiAodG9rZW5QYXJhbXMpIHtcbiAgICAgIHRoaXMudG9rZW5QYXJhbXMgPSB0b2tlblBhcmFtcztcbiAgICB9XG4gICAgaWYgKGF1dGhPcHRpb25zKSB7XG4gICAgICBpZiAoYXV0aE9wdGlvbnMudG9rZW4pIHtcbiAgICAgICAgYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzID0gdHlwZW9mIGF1dGhPcHRpb25zLnRva2VuID09PSBcInN0cmluZ1wiID8geyB0b2tlbjogYXV0aE9wdGlvbnMudG9rZW4gfSA6IGF1dGhPcHRpb25zLnRva2VuO1xuICAgICAgfVxuICAgICAgaWYgKGF1dGhPcHRpb25zLnRva2VuRGV0YWlscykge1xuICAgICAgICB0aGlzLnRva2VuRGV0YWlscyA9IGF1dGhPcHRpb25zLnRva2VuRGV0YWlscztcbiAgICAgIH1cbiAgICAgIGlmIChcImNsaWVudElkXCIgaW4gYXV0aE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fdXNlclNldENsaWVudElkKGF1dGhPcHRpb25zLmNsaWVudElkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucztcbiAgICB9XG4gIH1cbiAgLyogQHBhcmFtIGZvcmNlU3VwZXJzZWRlOiBmb3JjZSBhIG5ldyB0b2tlbiByZXF1ZXN0IGV2ZW4gaWYgdGhlcmUncyBvbmUgaW5cbiAgICogcHJvZ3Jlc3MsIG1ha2luZyBhbGwgcGVuZGluZyBjYWxsYmFja3Mgd2FpdCBmb3IgdGhlIG5ldyBvbmUgKi9cbiAgYXN5bmMgX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZvcmNlU3VwZXJzZWRlKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLnRva2VuRGV0YWlscztcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGlmICh0aGlzLl90b2tlbkNsaWVudElkTWlzbWF0Y2godG9rZW4uY2xpZW50SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgXCJNaXNtYXRjaCBiZXR3ZWVuIGNsaWVudElkIGluIHRva2VuIChcIiArIHRva2VuLmNsaWVudElkICsgXCIpIGFuZCBjdXJyZW50IGNsaWVudElkIChcIiArIHRoaXMuY2xpZW50SWQgKyBcIilcIixcbiAgICAgICAgICA0MDEwMixcbiAgICAgICAgICA0MDNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5pc1RpbWVPZmZzZXRTZXQoKSB8fCAhdG9rZW4uZXhwaXJlcyB8fCB0b2tlbi5leHBpcmVzID49IHRoaXMuZ2V0VGltZXN0YW1wVXNpbmdPZmZzZXQoKSkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiQXV0aC5nZXRUb2tlbigpXCIsXG4gICAgICAgICAgXCJ1c2luZyBjYWNoZWQgdG9rZW47IGV4cGlyZXMgPSBcIiArIHRva2VuLmV4cGlyZXNcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQXV0aC5nZXRUb2tlbigpXCIsIFwiZGVsZXRpbmcgZXhwaXJlZCB0b2tlblwiKTtcbiAgICAgIHRoaXMudG9rZW5EZXRhaWxzID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9ICh0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgfHwgKHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCA9IG11bHRpY2FzdGVyX2RlZmF1bHQuY3JlYXRlKHRoaXMubG9nZ2VyKSkpLmNyZWF0ZVByb21pc2UoKTtcbiAgICBpZiAodGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgIT09IG51bGwgJiYgIWZvcmNlU3VwZXJzZWRlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5SZXF1ZXN0SWQgPSB0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IGdldFRva2VuUmVxdWVzdElkKCk7XG4gICAgbGV0IHRva2VuUmVzcG9uc2UsIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgdG9rZW5SZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdFRva2VuKHRoaXMudG9rZW5QYXJhbXMsIHRoaXMuYXV0aE9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2F1Z2h0RXJyb3IgPSBlcnI7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA+IHRva2VuUmVxdWVzdElkKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQXV0aC5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoKVwiLFxuICAgICAgICBcIkRpc2NhcmRpbmcgdG9rZW4gcmVxdWVzdCByZXNwb25zZTsgb3ZlcnRha2VuIGJ5IG5ld2VyIG9uZVwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID0gbnVsbDtcbiAgICBjb25zdCBtdWx0aWNhc3RlciA9IHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdDtcbiAgICB0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChjYXVnaHRFcnJvcikge1xuICAgICAgbXVsdGljYXN0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG11bHRpY2FzdGVyLnJlamVjdEFsbChjYXVnaHRFcnJvcik7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgbXVsdGljYXN0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG11bHRpY2FzdGVyLnJlc29sdmVBbGwodGhpcy50b2tlbkRldGFpbHMgPSB0b2tlblJlc3BvbnNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKiBVc2VyLXNldDogY2hlY2sgdHlwZXMsICcqJyBpcyBkaXNhbGxvd2VkLCB0aHJvdyBhbnkgZXJyb3JzICovXG4gIF91c2VyU2V0Q2xpZW50SWQoY2xpZW50SWQpIHtcbiAgICBpZiAoISh0eXBlb2YgY2xpZW50SWQgPT09IFwic3RyaW5nXCIgfHwgY2xpZW50SWQgPT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVsbFwiLCA0MDAxMiwgNDAwKTtcbiAgICB9IGVsc2UgaWYgKGNsaWVudElkID09PSBcIipcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgJ0NhblxcdTIwMTl0IHVzZSBcIipcIiBhcyBhIGNsaWVudElkIGFzIHRoYXQgc3RyaW5nIGlzIHJlc2VydmVkLiAoVG8gY2hhbmdlIHRoZSBkZWZhdWx0IHRva2VuIHJlcXVlc3QgYmVoYXZpb3VyIHRvIHVzZSBhIHdpbGRjYXJkIGNsaWVudElkLCBpbnN0YW50aWF0ZSB0aGUgbGlicmFyeSB3aXRoIHtkZWZhdWx0VG9rZW5QYXJhbXM6IHtjbGllbnRJZDogXCIqXCJ9fSksIG9yIGlmIGNhbGxpbmcgYXV0aG9yaXplKCksIHBhc3MgaXQgaW4gYXMgYSB0b2tlblBhcmFtOiBhdXRob3JpemUoe2NsaWVudElkOiBcIipcIn0sIGF1dGhPcHRpb25zKScsXG4gICAgICAgIDQwMDEyLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMuX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKTtcbiAgICAgIGlmIChlcnIpXG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgLyogQWJseS1zZXQ6IG5vIHR5cGVjaGVja2luZywgJyonIGlzIGFsbG93ZWQgYnV0IG5vdCBzZXQgb24gdGhpcy5jbGllbnRJZCksIHJldHVybiBlcnJvcnMgdG8gdGhlIGNhbGxlciAqL1xuICBfdW5jaGVja2VkU2V0Q2xpZW50SWQoY2xpZW50SWQpIHtcbiAgICBpZiAodGhpcy5fdG9rZW5DbGllbnRJZE1pc21hdGNoKGNsaWVudElkKSkge1xuICAgICAgY29uc3QgbXNnID0gXCJVbmV4cGVjdGVkIGNsaWVudElkIG1pc21hdGNoOiBjbGllbnQgaGFzIFwiICsgdGhpcy5jbGllbnRJZCArIFwiLCByZXF1ZXN0ZWQgXCIgKyBjbGllbnRJZDtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvckluZm8obXNnLCA0MDEwMiwgNDAxKTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkF1dGguX3VuY2hlY2tlZFNldENsaWVudElkKClcIiwgbXNnKTtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xpZW50SWQgPSB0aGlzLnRva2VuUGFyYW1zLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgX3Rva2VuQ2xpZW50SWRNaXNtYXRjaCh0b2tlbkNsaWVudElkKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuY2xpZW50SWQgJiYgdGhpcy5jbGllbnRJZCAhPT0gXCIqXCIgJiYgdG9rZW5DbGllbnRJZCAmJiB0b2tlbkNsaWVudElkICE9PSBcIipcIiAmJiB0aGlzLmNsaWVudElkICE9PSB0b2tlbkNsaWVudElkKTtcbiAgfVxuICBzdGF0aWMgaXNUb2tlbkVycihlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5jb2RlICYmIGVycm9yLmNvZGUgPj0gNDAxNDAgJiYgZXJyb3IuY29kZSA8IDQwMTUwO1xuICB9XG4gIHJldm9rZVRva2VucyhzcGVjaWZpZXJzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QucmV2b2tlVG9rZW5zKHNwZWNpZmllcnMsIG9wdGlvbnMpO1xuICB9XG59O1xudmFyIGF1dGhfZGVmYXVsdCA9IEF1dGg7XG5cbi8vIHNyYy9jb21tb24vdHlwZXMvaHR0cC50c1xuZnVuY3Rpb24gcGFyYW1TdHJpbmcocGFyYW1zKSB7XG4gIGNvbnN0IHBhcmFtUGFpcnMgPSBbXTtcbiAgaWYgKHBhcmFtcykge1xuICAgIGZvciAoY29uc3QgbmVlZGxlIGluIHBhcmFtcykge1xuICAgICAgcGFyYW1QYWlycy5wdXNoKG5lZWRsZSArIFwiPVwiICsgcGFyYW1zW25lZWRsZV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyYW1QYWlycy5qb2luKFwiJlwiKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZGluZ1BhcmFtcyh1cmksIHBhcmFtcykge1xuICByZXR1cm4gdXJpICsgKHBhcmFtcyA/IFwiP1wiIDogXCJcIikgKyBwYXJhbVN0cmluZyhwYXJhbXMpO1xufVxuZnVuY3Rpb24gbG9nUmVzdWx0KHJlc3VsdCwgbWV0aG9kLCB1cmksIHBhcmFtcywgbG9nZ2VyKSB7XG4gIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb25Ob1N0cmlwKFxuICAgICAgbG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJIdHRwLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgXCJSZWNlaXZlZCBFcnJvcjsgXCIgKyBhcHBlbmRpbmdQYXJhbXModXJpLCBwYXJhbXMpICsgXCI7IEVycm9yOiBcIiArIGluc3BlY3RFcnJvcihyZXN1bHQuZXJyb3IpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb25Ob1N0cmlwKFxuICAgICAgbG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJIdHRwLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgXCJSZWNlaXZlZDsgXCIgKyBhcHBlbmRpbmdQYXJhbXModXJpLCBwYXJhbXMpICsgXCI7IEhlYWRlcnM6IFwiICsgcGFyYW1TdHJpbmcocmVzdWx0LmhlYWRlcnMpICsgXCI7IFN0YXR1c0NvZGU6IFwiICsgcmVzdWx0LnN0YXR1c0NvZGUgKyBcIjsgQm9keVwiICsgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKHJlc3VsdC5ib2R5KSA/IFwiIChCYXNlNjQpOiBcIiArIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShyZXN1bHQuYm9keSkgOiBcIjogXCIgKyByZXN1bHQuYm9keSlcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBsb2dSZXF1ZXN0KG1ldGhvZCwgdXJpLCBib2R5LCBwYXJhbXMsIGxvZ2dlcikge1xuICBpZiAobG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uTm9TdHJpcChcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiSHR0cC5cIiArIG1ldGhvZCArIFwiKClcIixcbiAgICAgIFwiU2VuZGluZzsgXCIgKyBhcHBlbmRpbmdQYXJhbXModXJpLCBwYXJhbXMpICsgXCI7IEJvZHlcIiArIChQbGF0Zm9ybS5CdWZmZXJVdGlscy5pc0J1ZmZlcihib2R5KSA/IFwiIChCYXNlNjQpOiBcIiArIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShib2R5KSA6IFwiOiBcIiArIGJvZHkpXG4gICAgKTtcbiAgfVxufVxudmFyIEh0dHAgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMucGxhdGZvcm1IdHRwID0gbmV3IFBsYXRmb3JtLkh0dHAoY2xpZW50KTtcbiAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gdGhpcy5wbGF0Zm9ybUh0dHAuY2hlY2tDb25uZWN0aXZpdHkgPyAoKSA9PiB0aGlzLnBsYXRmb3JtSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpIDogdm9pZCAwO1xuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYTIgPSB0aGlzLmNsaWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5sb2dnZXIpICE9IG51bGwgPyBfYiA6IGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXI7XG4gIH1cbiAgZ2V0IHN1cHBvcnRzQXV0aEhlYWRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxhdGZvcm1IdHRwLnN1cHBvcnRzQXV0aEhlYWRlcnM7XG4gIH1cbiAgZ2V0IHN1cHBvcnRzTGlua0hlYWRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxhdGZvcm1IdHRwLnN1cHBvcnRzTGlua0hlYWRlcnM7XG4gIH1cbiAgX2dldEhvc3RzKGNsaWVudCkge1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBjbGllbnQuY29ubmVjdGlvbiwgY29ubmVjdGlvbkhvc3QgPSBjb25uZWN0aW9uICYmIGNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIuaG9zdDtcbiAgICBpZiAoY29ubmVjdGlvbkhvc3QpIHtcbiAgICAgIHJldHVybiBbY29ubmVjdGlvbkhvc3RdLmNvbmNhdChkZWZhdWx0c19kZWZhdWx0LmdldEZhbGxiYWNrSG9zdHMoY2xpZW50Lm9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRzX2RlZmF1bHQuZ2V0SG9zdHMoY2xpZW50Lm9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIG5vdCB0aHJvdyBhbnkgZXJyb3JzOyByYXRoZXIsIGl0IHdpbGwgY29tbXVuaWNhdGUgYW55IGVycm9yIGJ5IHBvcHVsYXRpbmcgdGhlIHtAbGluayBSZXF1ZXN0UmVzdWx0LmVycm9yfSBwcm9wZXJ0eSBvZiB0aGUgcmV0dXJuZWQge0BsaW5rIFJlcXVlc3RSZXN1bHR9LlxuICAgKi9cbiAgYXN5bmMgZG8obWV0aG9kLCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogbmV3IEVycm9ySW5mbyhcImh0dHAuZG8gY2FsbGVkIHdpdGhvdXQgY2xpZW50XCIsIDVlNCwgNTAwKSB9O1xuICAgICAgfVxuICAgICAgY29uc3QgdXJpRnJvbUhvc3QgPSB0eXBlb2YgcGF0aCA9PT0gXCJmdW5jdGlvblwiID8gcGF0aCA6IGZ1bmN0aW9uKGhvc3QpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5iYXNlVXJpKGhvc3QpICsgcGF0aDtcbiAgICAgIH07XG4gICAgICBjb25zdCBjdXJyZW50RmFsbGJhY2sgPSBjbGllbnQuX2N1cnJlbnRGYWxsYmFjaztcbiAgICAgIGlmIChjdXJyZW50RmFsbGJhY2spIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGYWxsYmFjay52YWxpZFVudGlsID4gRGF0ZS5ub3coKSkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZG9VcmkobWV0aG9kLCB1cmlGcm9tSG9zdChjdXJyZW50RmFsbGJhY2suaG9zdCksIGhlYWRlcnMsIGJvZHksIHBhcmFtcyk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5lcnJvciAmJiB0aGlzLnBsYXRmb3JtSHR0cC5zaG91bGRGYWxsYmFjayhyZXN1bHQuZXJyb3IpKSB7XG4gICAgICAgICAgICBjbGllbnQuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kbyhtZXRob2QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xpZW50Ll9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBob3N0cyA9IHRoaXMuX2dldEhvc3RzKGNsaWVudCk7XG4gICAgICBpZiAoaG9zdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvVXJpKG1ldGhvZCwgdXJpRnJvbUhvc3QoaG9zdHNbMF0pLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMpO1xuICAgICAgfVxuICAgICAgbGV0IHRyeUFIb3N0U3RhcnRlZEF0ID0gbnVsbDtcbiAgICAgIGNvbnN0IHRyeUFIb3N0ID0gYXN5bmMgKGNhbmRpZGF0ZUhvc3RzLCBwZXJzaXN0T25TdWNjZXNzKSA9PiB7XG4gICAgICAgIGNvbnN0IGhvc3QgPSBjYW5kaWRhdGVIb3N0cy5zaGlmdCgpO1xuICAgICAgICB0cnlBSG9zdFN0YXJ0ZWRBdCA9IHRyeUFIb3N0U3RhcnRlZEF0ICE9IG51bGwgPyB0cnlBSG9zdFN0YXJ0ZWRBdCA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRvVXJpKG1ldGhvZCwgdXJpRnJvbUhvc3QoaG9zdCksIGhlYWRlcnMsIGJvZHksIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IgJiYgdGhpcy5wbGF0Zm9ybUh0dHAuc2hvdWxkRmFsbGJhY2socmVzdWx0LmVycm9yKSAmJiBjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBlbGFwc2VkVGltZSA9IERhdGUubm93KCkgLSB0cnlBSG9zdFN0YXJ0ZWRBdC5nZXRUaW1lKCk7XG4gICAgICAgICAgaWYgKGVsYXBzZWRUaW1lID4gY2xpZW50Lm9wdGlvbnMudGltZW91dHMuaHR0cE1heFJldHJ5RHVyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICAgICAgIGBUaW1lb3V0IGZvciB0cnlpbmcgZmFsbGJhY2sgaG9zdHMgcmV0cmllcy4gVG90YWwgZWxhcHNlZCB0aW1lIGV4Y2VlZGVkIHRoZSAke2NsaWVudC5vcHRpb25zLnRpbWVvdXRzLmh0dHBNYXhSZXRyeUR1cmF0aW9ufW1zIGxpbWl0YCxcbiAgICAgICAgICAgICAgICA1MDAwMyxcbiAgICAgICAgICAgICAgICA1MDBcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRyeUFIb3N0KGNhbmRpZGF0ZUhvc3RzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVyc2lzdE9uU3VjY2Vzcykge1xuICAgICAgICAgIGNsaWVudC5fY3VycmVudEZhbGxiYWNrID0ge1xuICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgIHZhbGlkVW50aWw6IERhdGUubm93KCkgKyBjbGllbnQub3B0aW9ucy50aW1lb3V0cy5mYWxsYmFja1JldHJ5VGltZW91dFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gdHJ5QUhvc3QoaG9zdHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IG5ldyBFcnJvckluZm8oYFVuZXhwZWN0ZWQgZXJyb3IgaW4gSHR0cC5kbzogJHtpbnNwZWN0RXJyb3IoZXJyKX1gLCA1MDAsIDVlNCkgfTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgbm90IHRocm93IGFueSBlcnJvcnM7IHJhdGhlciwgaXQgd2lsbCBjb21tdW5pY2F0ZSBhbnkgZXJyb3IgYnkgcG9wdWxhdGluZyB0aGUge0BsaW5rIFJlcXVlc3RSZXN1bHQuZXJyb3J9IHByb3BlcnR5IG9mIHRoZSByZXR1cm5lZCB7QGxpbmsgUmVxdWVzdFJlc3VsdH0uXG4gICAqL1xuICBhc3luYyBkb1VyaShtZXRob2QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ1JlcXVlc3QobWV0aG9kLCB1cmksIGJvZHksIHBhcmFtcywgdGhpcy5sb2dnZXIpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wbGF0Zm9ybUh0dHAuZG9VcmkobWV0aG9kLCB1cmksIGhlYWRlcnMsIGJvZHksIHBhcmFtcyk7XG4gICAgICBpZiAodGhpcy5sb2dnZXIuc2hvdWxkTG9nKGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgICAgbG9nUmVzdWx0KHJlc3VsdCwgbWV0aG9kLCB1cmksIHBhcmFtcywgdGhpcy5sb2dnZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IGVycm9yOiBuZXcgRXJyb3JJbmZvKGBVbmV4cGVjdGVkIGVycm9yIGluIEh0dHAuZG9Vcmk6ICR7aW5zcGVjdEVycm9yKGVycil9YCwgNTAwLCA1ZTQpIH07XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvYmFzZWNsaWVudC50c1xudmFyIEJhc2VDbGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBUaGVzZSBleHBvcnRzIGFyZSBmb3IgdXNlIGJ5IFVNRCBwbHVnaW5zOyByZWFzb24gYmVpbmcgc28gdGhhdCBjb25zdHJ1Y3RvcnMgYW5kIHN0YXRpYyBtZXRob2RzIGNhbiBiZSBhY2Nlc3NlZCBieSB0aGVzZSBwbHVnaW5zIHdpdGhvdXQgbmVlZGluZyB0byBpbXBvcnQgdGhlIGNsYXNzZXMgZGlyZWN0bHkgYW5kIHJlc3VsdCBpbiB0aGUgY2xhc3MgZXhpc3RpbmcgaW4gYm90aCB0aGUgcGx1Z2luIGFuZCB0aGUgY29yZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIHRoaXMuUGxhdGZvcm0gPSBQbGF0Zm9ybTtcbiAgICB0aGlzLkVycm9ySW5mbyA9IEVycm9ySW5mbztcbiAgICB0aGlzLkxvZ2dlciA9IGxvZ2dlcl9kZWZhdWx0O1xuICAgIHRoaXMuRGVmYXVsdHMgPSBkZWZhdWx0c19kZWZhdWx0O1xuICAgIHRoaXMuVXRpbHMgPSB1dGlsc19leHBvcnRzO1xuICAgIHZhciBfYTIsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2o7XG4gICAgdGhpcy5fYWRkaXRpb25hbEhUVFBSZXF1ZXN0SW1wbGVtZW50YXRpb25zID0gKF9hMiA9IG9wdGlvbnMucGx1Z2lucykgIT0gbnVsbCA/IF9hMiA6IG51bGw7XG4gICAgdGhpcy5sb2dnZXIgPSBuZXcgbG9nZ2VyX2RlZmF1bHQoKTtcbiAgICB0aGlzLmxvZ2dlci5zZXRMb2cob3B0aW9ucy5sb2dMZXZlbCwgb3B0aW9ucy5sb2dIYW5kbGVyKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiQmFzZUNsaWVudCgpXCIsXG4gICAgICBcImluaXRpYWxpemVkIHdpdGggY2xpZW50T3B0aW9ucyBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KG9wdGlvbnMpXG4gICAgKTtcbiAgICB0aGlzLl9Nc2dQYWNrID0gKF9jID0gKF9iID0gb3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2IuTXNnUGFjaykgIT0gbnVsbCA/IF9jIDogbnVsbDtcbiAgICBjb25zdCBub3JtYWxPcHRpb25zID0gdGhpcy5vcHRpb25zID0gZGVmYXVsdHNfZGVmYXVsdC5ub3JtYWxpc2VPcHRpb25zKG9wdGlvbnMsIHRoaXMuX01zZ1BhY2ssIHRoaXMubG9nZ2VyKTtcbiAgICBpZiAobm9ybWFsT3B0aW9ucy5rZXkpIHtcbiAgICAgIGNvbnN0IGtleU1hdGNoID0gbm9ybWFsT3B0aW9ucy5rZXkubWF0Y2goL14oW146XFxzXSspOihbXjouXFxzXSspJC8pO1xuICAgICAgaWYgKCFrZXlNYXRjaCkge1xuICAgICAgICBjb25zdCBtc2cgPSBcImludmFsaWQga2V5IHBhcmFtZXRlclwiO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJCYXNlQ2xpZW50KClcIiwgbXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhtc2csIDQwNDAwLCA0MDQpO1xuICAgICAgfVxuICAgICAgbm9ybWFsT3B0aW9ucy5rZXlOYW1lID0ga2V5TWF0Y2hbMV07XG4gICAgICBub3JtYWxPcHRpb25zLmtleVNlY3JldCA9IGtleU1hdGNoWzJdO1xuICAgIH1cbiAgICBpZiAoXCJjbGllbnRJZFwiIGluIG5vcm1hbE9wdGlvbnMpIHtcbiAgICAgIGlmICghKHR5cGVvZiBub3JtYWxPcHRpb25zLmNsaWVudElkID09PSBcInN0cmluZ1wiIHx8IG5vcm1hbE9wdGlvbnMuY2xpZW50SWQgPT09IG51bGwpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVsbFwiLCA0MDAxMiwgNDAwKTtcbiAgICAgIGVsc2UgaWYgKG5vcm1hbE9wdGlvbnMuY2xpZW50SWQgPT09IFwiKlwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICAgICdDYW5cXHUyMDE5dCB1c2UgXCIqXCIgYXMgYSBjbGllbnRJZCBhcyB0aGF0IHN0cmluZyBpcyByZXNlcnZlZC4gKFRvIGNoYW5nZSB0aGUgZGVmYXVsdCB0b2tlbiByZXF1ZXN0IGJlaGF2aW91ciB0byB1c2UgYSB3aWxkY2FyZCBjbGllbnRJZCwgdXNlIHtkZWZhdWx0VG9rZW5QYXJhbXM6IHtjbGllbnRJZDogXCIqXCJ9fSknLFxuICAgICAgICAgIDQwMDEyLFxuICAgICAgICAgIDQwMFxuICAgICAgICApO1xuICAgIH1cbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJCYXNlQ2xpZW50KClcIiwgXCJzdGFydGVkOyB2ZXJzaW9uID0gXCIgKyBkZWZhdWx0c19kZWZhdWx0LnZlcnNpb24pO1xuICAgIHRoaXMuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLmh0dHAgPSBuZXcgSHR0cCh0aGlzKTtcbiAgICB0aGlzLmF1dGggPSBuZXcgYXV0aF9kZWZhdWx0KHRoaXMsIG5vcm1hbE9wdGlvbnMpO1xuICAgIHRoaXMuX3Jlc3QgPSAoKF9kID0gb3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2QuUmVzdCkgPyBuZXcgb3B0aW9ucy5wbHVnaW5zLlJlc3QodGhpcykgOiBudWxsO1xuICAgIHRoaXMuX0NyeXB0byA9IChfZiA9IChfZSA9IG9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLkNyeXB0bykgIT0gbnVsbCA/IF9mIDogbnVsbDtcbiAgICB0aGlzLl9fRmlsdGVyZWRTdWJzY3JpcHRpb25zID0gKF9oID0gKF9nID0gb3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2cuTWVzc2FnZUludGVyYWN0aW9ucykgIT0gbnVsbCA/IF9oIDogbnVsbDtcbiAgICB0aGlzLl9Bbm5vdGF0aW9ucyA9IChfaiA9IChfaSA9IG9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9pLkFubm90YXRpb25zKSAhPSBudWxsID8gX2ogOiBudWxsO1xuICB9XG4gIGdldCByZXN0KCkge1xuICAgIGlmICghdGhpcy5fcmVzdCkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJSZXN0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVzdDtcbiAgfVxuICBnZXQgX0ZpbHRlcmVkU3Vic2NyaXB0aW9ucygpIHtcbiAgICBpZiAoIXRoaXMuX19GaWx0ZXJlZFN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiTWVzc2FnZUludGVyYWN0aW9uc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19GaWx0ZXJlZFN1YnNjcmlwdGlvbnM7XG4gIH1cbiAgZ2V0IGNoYW5uZWxzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3QuY2hhbm5lbHM7XG4gIH1cbiAgZ2V0IHB1c2goKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5wdXNoO1xuICB9XG4gIGdldCBkZXZpY2UoKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoISgoX2EyID0gdGhpcy5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuUHVzaCkgfHwgIXRoaXMucHVzaC5Mb2NhbERldmljZSkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJQdXNoXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2RldmljZSkge1xuICAgICAgdGhpcy5fZGV2aWNlID0gdGhpcy5wdXNoLkxvY2FsRGV2aWNlLmxvYWQodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9kZXZpY2U7XG4gIH1cbiAgYmFzZVVyaShob3N0KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzX2RlZmF1bHQuZ2V0SHR0cFNjaGVtZSh0aGlzLm9wdGlvbnMpICsgaG9zdCArIFwiOlwiICsgZGVmYXVsdHNfZGVmYXVsdC5nZXRQb3J0KHRoaXMub3B0aW9ucywgZmFsc2UpO1xuICB9XG4gIGFzeW5jIHN0YXRzKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnJlc3Quc3RhdHMocGFyYW1zKTtcbiAgfVxuICBhc3luYyB0aW1lKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnJlc3QudGltZShwYXJhbXMpO1xuICB9XG4gIGFzeW5jIHJlcXVlc3QobWV0aG9kLCBwYXRoLCB2ZXJzaW9uMiwgcGFyYW1zLCBib2R5LCBjdXN0b21IZWFkZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5yZXF1ZXN0KG1ldGhvZCwgcGF0aCwgdmVyc2lvbjIsIHBhcmFtcywgYm9keSwgY3VzdG9tSGVhZGVycyk7XG4gIH1cbiAgYmF0Y2hQdWJsaXNoKHNwZWNPclNwZWNzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5iYXRjaFB1Ymxpc2goc3BlY09yU3BlY3MpO1xuICB9XG4gIGJhdGNoUHJlc2VuY2UoY2hhbm5lbHMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN0LmJhdGNoUHJlc2VuY2UoY2hhbm5lbHMpO1xuICB9XG4gIHNldExvZyhsb2dPcHRpb25zKSB7XG4gICAgdGhpcy5sb2dnZXIuc2V0TG9nKGxvZ09wdGlvbnMubGV2ZWwsIGxvZ09wdGlvbnMuaGFuZGxlcik7XG4gIH1cbn07XG5CYXNlQ2xpZW50LlBsYXRmb3JtID0gUGxhdGZvcm07XG52YXIgYmFzZWNsaWVudF9kZWZhdWx0ID0gQmFzZUNsaWVudDtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvZGV2aWNlZGV0YWlscy50c1xudmFyIERldmljZURldGFpbHMgPSBjbGFzcyBfRGV2aWNlRGV0YWlscyB7XG4gIHRvSlNPTigpIHtcbiAgICB2YXIgX2EyLCBfYiwgX2M7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgZGV2aWNlU2VjcmV0OiB0aGlzLmRldmljZVNlY3JldCxcbiAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgZm9ybUZhY3RvcjogdGhpcy5mb3JtRmFjdG9yLFxuICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICBtZXRhZGF0YTogdGhpcy5tZXRhZGF0YSxcbiAgICAgIGRldmljZUlkZW50aXR5VG9rZW46IHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbixcbiAgICAgIHB1c2g6IHtcbiAgICAgICAgcmVjaXBpZW50OiAoX2EyID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJlY2lwaWVudCxcbiAgICAgICAgc3RhdGU6IChfYiA9IHRoaXMucHVzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN0YXRlLFxuICAgICAgICBlcnJvcjogKF9jID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2MuZXJyb3JcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHZhciBfYTIsIF9iLCBfYywgX2Q7XG4gICAgbGV0IHJlc3VsdCA9IFwiW0RldmljZURldGFpbHNcIjtcbiAgICBpZiAodGhpcy5pZClcbiAgICAgIHJlc3VsdCArPSBcIjsgaWQ9XCIgKyB0aGlzLmlkO1xuICAgIGlmICh0aGlzLnBsYXRmb3JtKVxuICAgICAgcmVzdWx0ICs9IFwiOyBwbGF0Zm9ybT1cIiArIHRoaXMucGxhdGZvcm07XG4gICAgaWYgKHRoaXMuZm9ybUZhY3RvcilcbiAgICAgIHJlc3VsdCArPSBcIjsgZm9ybUZhY3Rvcj1cIiArIHRoaXMuZm9ybUZhY3RvcjtcbiAgICBpZiAodGhpcy5jbGllbnRJZClcbiAgICAgIHJlc3VsdCArPSBcIjsgY2xpZW50SWQ9XCIgKyB0aGlzLmNsaWVudElkO1xuICAgIGlmICh0aGlzLm1ldGFkYXRhKVxuICAgICAgcmVzdWx0ICs9IFwiOyBtZXRhZGF0YT1cIiArIHRoaXMubWV0YWRhdGE7XG4gICAgaWYgKHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbilcbiAgICAgIHJlc3VsdCArPSBcIjsgZGV2aWNlSWRlbnRpdHlUb2tlbj1cIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbik7XG4gICAgaWYgKChfYTIgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucmVjaXBpZW50KVxuICAgICAgcmVzdWx0ICs9IFwiOyBwdXNoLnJlY2lwaWVudD1cIiArIEpTT04uc3RyaW5naWZ5KHRoaXMucHVzaC5yZWNpcGllbnQpO1xuICAgIGlmICgoX2IgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zdGF0ZSlcbiAgICAgIHJlc3VsdCArPSBcIjsgcHVzaC5zdGF0ZT1cIiArIHRoaXMucHVzaC5zdGF0ZTtcbiAgICBpZiAoKF9jID0gdGhpcy5wdXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2MuZXJyb3IpXG4gICAgICByZXN1bHQgKz0gXCI7IHB1c2guZXJyb3I9XCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnB1c2guZXJyb3IpO1xuICAgIGlmICgoX2QgPSB0aGlzLnB1c2gpID09IG51bGwgPyB2b2lkIDAgOiBfZC5tZXRhZGF0YSlcbiAgICAgIHJlc3VsdCArPSBcIjsgcHVzaC5tZXRhZGF0YT1cIiArIHRoaXMucHVzaC5tZXRhZGF0YTtcbiAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgdG9SZXF1ZXN0Qm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZW5jb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpO1xuICB9XG4gIHN0YXRpYyBmcm9tUmVzcG9uc2VCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgIGJvZHkgPSBkZWNvZGVCb2R5KGJvZHksIE1zZ1BhY2ssIGZvcm1hdCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGJvZHkpKSB7XG4gICAgICByZXR1cm4gX0RldmljZURldGFpbHMuZnJvbVZhbHVlc0FycmF5KGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX0RldmljZURldGFpbHMuZnJvbVZhbHVlcyhib2R5KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgdmFsdWVzLmVycm9yID0gdmFsdWVzLmVycm9yICYmIEVycm9ySW5mby5mcm9tVmFsdWVzKHZhbHVlcy5lcnJvcik7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9EZXZpY2VEZXRhaWxzKCksIHZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGZyb21Mb2NhbERldmljZShkZXZpY2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX0RldmljZURldGFpbHMoKSwgZGV2aWNlKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHZhbHVlcykge1xuICAgIGNvbnN0IGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspXG4gICAgICByZXN1bHRbaV0gPSBfRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzKHZhbHVlc1tpXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbnZhciBkZXZpY2VkZXRhaWxzX2RlZmF1bHQgPSBEZXZpY2VEZXRhaWxzO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzb3VyY2UudHNcbmFzeW5jIGZ1bmN0aW9uIHdpdGhBdXRoRGV0YWlscyhjbGllbnQsIGhlYWRlcnMsIHBhcmFtcywgb3BDYWxsYmFjaykge1xuICBpZiAoY2xpZW50Lmh0dHAuc3VwcG9ydHNBdXRoSGVhZGVycykge1xuICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gYXdhaXQgY2xpZW50LmF1dGguZ2V0QXV0aEhlYWRlcnMoKTtcbiAgICByZXR1cm4gb3BDYWxsYmFjayhtaXhpbihhdXRoSGVhZGVycywgaGVhZGVycyksIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYXV0aFBhcmFtcyA9IGF3YWl0IGNsaWVudC5hdXRoLmdldEF1dGhQYXJhbXMoKTtcbiAgICByZXR1cm4gb3BDYWxsYmFjayhoZWFkZXJzLCBtaXhpbihhdXRoUGFyYW1zLCBwYXJhbXMpKTtcbiAgfVxufVxuZnVuY3Rpb24gdW5lbnZlbG9wZShyZXN1bHQsIE1zZ1BhY2ssIGZvcm1hdCkge1xuICBpZiAocmVzdWx0LmVyciAmJiAhcmVzdWx0LmJvZHkpIHtcbiAgICByZXR1cm4geyBlcnI6IHJlc3VsdC5lcnIgfTtcbiAgfVxuICBpZiAocmVzdWx0LnN0YXR1c0NvZGUgPT09IEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0Lk5vQ29udGVudCkge1xuICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCByZXN1bHQpLCB7IGJvZHk6IFtdLCB1bnBhY2tlZDogdHJ1ZSB9KTtcbiAgfVxuICBsZXQgYm9keSA9IHJlc3VsdC5ib2R5O1xuICBpZiAoIXJlc3VsdC51bnBhY2tlZCkge1xuICAgIHRyeSB7XG4gICAgICBib2R5ID0gZGVjb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyhlKSkge1xuICAgICAgICByZXR1cm4geyBlcnI6IGUgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IGVycjogbmV3IFBhcnRpYWxFcnJvckluZm8oaW5zcGVjdEVycm9yKGUpLCBudWxsKSB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWJvZHkpIHtcbiAgICByZXR1cm4geyBlcnI6IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwidW5lbnZlbG9wZSgpOiBSZXNwb25zZSBib2R5IGlzIG1pc3NpbmdcIiwgbnVsbCkgfTtcbiAgfVxuICBjb25zdCB7IHN0YXR1c0NvZGU6IHdyYXBwZWRTdGF0dXNDb2RlLCByZXNwb25zZSwgaGVhZGVyczogd3JhcHBlZEhlYWRlcnMgfSA9IGJvZHk7XG4gIGlmICh3cmFwcGVkU3RhdHVzQ29kZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJlc3VsdCksIHsgYm9keSwgdW5wYWNrZWQ6IHRydWUgfSk7XG4gIH1cbiAgaWYgKHdyYXBwZWRTdGF0dXNDb2RlIDwgMjAwIHx8IHdyYXBwZWRTdGF0dXNDb2RlID49IDMwMCkge1xuICAgIGxldCB3cmFwcGVkRXJyID0gcmVzcG9uc2UgJiYgcmVzcG9uc2UuZXJyb3IgfHwgcmVzdWx0LmVycjtcbiAgICBpZiAoIXdyYXBwZWRFcnIpIHtcbiAgICAgIHdyYXBwZWRFcnIgPSBuZXcgRXJyb3IoXCJFcnJvciBpbiB1bmVudmVsb3BpbmcgXCIgKyBib2R5KTtcbiAgICAgIHdyYXBwZWRFcnIuc3RhdHVzQ29kZSA9IHdyYXBwZWRTdGF0dXNDb2RlO1xuICAgIH1cbiAgICByZXR1cm4geyBlcnI6IHdyYXBwZWRFcnIsIGJvZHk6IHJlc3BvbnNlLCBoZWFkZXJzOiB3cmFwcGVkSGVhZGVycywgdW5wYWNrZWQ6IHRydWUsIHN0YXR1c0NvZGU6IHdyYXBwZWRTdGF0dXNDb2RlIH07XG4gIH1cbiAgcmV0dXJuIHsgZXJyOiByZXN1bHQuZXJyLCBib2R5OiByZXNwb25zZSwgaGVhZGVyczogd3JhcHBlZEhlYWRlcnMsIHVucGFja2VkOiB0cnVlLCBzdGF0dXNDb2RlOiB3cmFwcGVkU3RhdHVzQ29kZSB9O1xufVxuZnVuY3Rpb24gbG9nUmVzdWx0MihyZXN1bHQsIG1ldGhvZCwgcGF0aCwgcGFyYW1zLCBsb2dnZXIpIHtcbiAgaWYgKHJlc3VsdC5lcnIpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICBsb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlc291cmNlLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgXCJSZWNlaXZlZCBFcnJvcjsgXCIgKyBhcHBlbmRpbmdQYXJhbXMocGF0aCwgcGFyYW1zKSArIFwiOyBFcnJvcjogXCIgKyBpbnNwZWN0RXJyb3IocmVzdWx0LmVycilcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIGxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVzb3VyY2UuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICBcIlJlY2VpdmVkOyBcIiArIGFwcGVuZGluZ1BhcmFtcyhwYXRoLCBwYXJhbXMpICsgXCI7IEhlYWRlcnM6IFwiICsgcGFyYW1TdHJpbmcocmVzdWx0LmhlYWRlcnMpICsgXCI7IFN0YXR1c0NvZGU6IFwiICsgcmVzdWx0LnN0YXR1c0NvZGUgKyBcIjsgQm9keTogXCIgKyAoUGxhdGZvcm0uQnVmZmVyVXRpbHMuaXNCdWZmZXIocmVzdWx0LmJvZHkpID8gXCIgKEJhc2U2NCk6IFwiICsgUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHJlc3VsdC5ib2R5KSA6IFwiOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KHJlc3VsdC5ib2R5KSlcbiAgICApO1xuICB9XG59XG52YXIgUmVzb3VyY2UgPSBjbGFzcyBfUmVzb3VyY2Uge1xuICBzdGF0aWMgYXN5bmMgZ2V0KGNsaWVudCwgcGF0aCwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcikge1xuICAgIHJldHVybiBfUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsIGNsaWVudCwgcGF0aCwgbnVsbCwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvciAhPSBudWxsID8gdGhyb3dFcnJvciA6IGZhbHNlKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVsZXRlKGNsaWVudCwgcGF0aCwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcikge1xuICAgIHJldHVybiBfUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfZGVmYXVsdC5EZWxldGUsIGNsaWVudCwgcGF0aCwgbnVsbCwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHBvc3QoY2xpZW50LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKSB7XG4gICAgcmV0dXJuIF9SZXNvdXJjZS5kbyhIdHRwTWV0aG9kc19kZWZhdWx0LlBvc3QsIGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHBhdGNoKGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcikge1xuICAgIHJldHVybiBfUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfZGVmYXVsdC5QYXRjaCwgY2xpZW50LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgcHV0KGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcikge1xuICAgIHJldHVybiBfUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfZGVmYXVsdC5QdXQsIGNsaWVudCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgdGhyb3dFcnJvcik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRvKG1ldGhvZCwgY2xpZW50LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCB0aHJvd0Vycm9yKSB7XG4gICAgaWYgKGVudmVsb3BlKSB7XG4gICAgICAocGFyYW1zID0gcGFyYW1zIHx8IHt9KVtcImVudmVsb3BlXCJdID0gZW52ZWxvcGU7XG4gICAgfVxuICAgIGNvbnN0IGxvZ2dlciA9IGNsaWVudC5sb2dnZXI7XG4gICAgYXN5bmMgZnVuY3Rpb24gZG9SZXF1ZXN0KGhlYWRlcnMyLCBwYXJhbXMyKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKGxvZ2dlci5zaG91bGRMb2cobG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgICBsZXQgZGVjb2RlZEJvZHkgPSBib2R5O1xuICAgICAgICBpZiAoKChfYTIgPSBoZWFkZXJzMltcImNvbnRlbnQtdHlwZVwiXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5pbmRleE9mKFwibXNncGFja1wiKSkgPiAwKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghY2xpZW50Ll9Nc2dQYWNrKSB7XG4gICAgICAgICAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiTXNnUGFja1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRCb2R5ID0gY2xpZW50Ll9Nc2dQYWNrLmRlY29kZShib2R5KTtcbiAgICAgICAgICB9IGNhdGNoIChkZWNvZGVFcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgbG9nZ2VyLFxuICAgICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgICAgIFwiUmVzb3VyY2UuXCIgKyBtZXRob2QgKyBcIigpXCIsXG4gICAgICAgICAgICAgIFwiU2VuZGluZyBNc2dQYWNrIERlY29kaW5nIEVycm9yOiBcIiArIGluc3BlY3RFcnJvcihkZWNvZGVFcnIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgbG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIlJlc291cmNlLlwiICsgbWV0aG9kICsgXCIoKVwiLFxuICAgICAgICAgIFwiU2VuZGluZzsgXCIgKyBhcHBlbmRpbmdQYXJhbXMocGF0aCwgcGFyYW1zMikgKyBcIjsgQm9keTogXCIgKyBkZWNvZGVkQm9keVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgaHR0cFJlc3VsdCA9IGF3YWl0IGNsaWVudC5odHRwLmRvKG1ldGhvZCwgcGF0aCwgaGVhZGVyczIsIGJvZHksIHBhcmFtczIpO1xuICAgICAgaWYgKGh0dHBSZXN1bHQuZXJyb3IgJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIoaHR0cFJlc3VsdC5lcnJvcikpIHtcbiAgICAgICAgYXdhaXQgY2xpZW50LmF1dGguYXV0aG9yaXplKG51bGwsIG51bGwpO1xuICAgICAgICByZXR1cm4gd2l0aEF1dGhEZXRhaWxzKGNsaWVudCwgaGVhZGVyczIsIHBhcmFtczIsIGRvUmVxdWVzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnI6IGh0dHBSZXN1bHQuZXJyb3IsXG4gICAgICAgIGJvZHk6IGh0dHBSZXN1bHQuYm9keSxcbiAgICAgICAgaGVhZGVyczogaHR0cFJlc3VsdC5oZWFkZXJzLFxuICAgICAgICB1bnBhY2tlZDogaHR0cFJlc3VsdC51bnBhY2tlZCxcbiAgICAgICAgc3RhdHVzQ29kZTogaHR0cFJlc3VsdC5zdGF0dXNDb2RlXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgd2l0aEF1dGhEZXRhaWxzKGNsaWVudCwgaGVhZGVycywgcGFyYW1zLCBkb1JlcXVlc3QpO1xuICAgIGlmIChlbnZlbG9wZSkge1xuICAgICAgcmVzdWx0ID0gdW5lbnZlbG9wZShyZXN1bHQsIGNsaWVudC5fTXNnUGFjaywgZW52ZWxvcGUpO1xuICAgIH1cbiAgICBpZiAobG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICBsb2dSZXN1bHQyKHJlc3VsdCwgbWV0aG9kLCBwYXRoLCBwYXJhbXMsIGxvZ2dlcik7XG4gICAgfVxuICAgIGlmICh0aHJvd0Vycm9yKSB7XG4gICAgICBpZiAocmVzdWx0LmVycikge1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBfX3NwcmVhZFZhbHVlcyh7fSwgcmVzdWx0KTtcbiAgICAgICAgZGVsZXRlIHJlc3BvbnNlLmVycjtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xudmFyIHJlc291cmNlX2RlZmF1bHQgPSBSZXNvdXJjZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3BhZ2luYXRlZHJlc291cmNlLnRzXG5mdW5jdGlvbiBnZXRSZWxQYXJhbXMobGlua1VybCkge1xuICBjb25zdCB1cmxNYXRjaCA9IGxpbmtVcmwubWF0Y2goL15cXC5cXC8oXFx3KylcXD8oLiopJC8pO1xuICByZXR1cm4gdXJsTWF0Y2ggJiYgdXJsTWF0Y2hbMl0gJiYgcGFyc2VRdWVyeVN0cmluZyh1cmxNYXRjaFsyXSk7XG59XG5mdW5jdGlvbiBwYXJzZVJlbExpbmtzKGxpbmtIZWFkZXIpIHtcbiAgaWYgKHR5cGVvZiBsaW5rSGVhZGVyID09IFwic3RyaW5nXCIpXG4gICAgbGlua0hlYWRlciA9IGxpbmtIZWFkZXIuc3BsaXQoXCIsXCIpO1xuICBjb25zdCByZWxQYXJhbXMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5rSGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGlua01hdGNoID0gbGlua0hlYWRlcltpXS5tYXRjaCgvXlxccyo8KC4rKT47XFxzKnJlbD1cIihcXHcrKVwiJC8pO1xuICAgIGlmIChsaW5rTWF0Y2gpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IGdldFJlbFBhcmFtcyhsaW5rTWF0Y2hbMV0pO1xuICAgICAgaWYgKHBhcmFtcylcbiAgICAgICAgcmVsUGFyYW1zW2xpbmtNYXRjaFsyXV0gPSBwYXJhbXM7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWxQYXJhbXM7XG59XG5mdW5jdGlvbiByZXR1cm5FcnJPbmx5KGVyciwgYm9keSwgdXNlSFBSKSB7XG4gIHJldHVybiAhKHVzZUhQUiAmJiAoYm9keSB8fCB0eXBlb2YgZXJyLmNvZGUgPT09IFwibnVtYmVyXCIpKTtcbn1cbnZhciBQYWdpbmF0ZWRSZXNvdXJjZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBwYXRoLCBoZWFkZXJzLCBlbnZlbG9wZSwgYm9keUhhbmRsZXIsIHVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLmVudmVsb3BlID0gZW52ZWxvcGUgIT0gbnVsbCA/IGVudmVsb3BlIDogbnVsbDtcbiAgICB0aGlzLmJvZHlIYW5kbGVyID0gYm9keUhhbmRsZXI7XG4gICAgdGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UgPSB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UgfHwgZmFsc2U7XG4gIH1cbiAgZ2V0IGxvZ2dlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQubG9nZ2VyO1xuICB9XG4gIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldCh0aGlzLmNsaWVudCwgdGhpcy5wYXRoLCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVBhZ2UocmVzdWx0KTtcbiAgfVxuICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5kZWxldGUodGhpcy5jbGllbnQsIHRoaXMucGF0aCwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVQYWdlKHJlc3VsdCk7XG4gIH1cbiAgYXN5bmMgcG9zdChwYXJhbXMsIGJvZHkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QodGhpcy5jbGllbnQsIHRoaXMucGF0aCwgYm9keSwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVQYWdlKHJlc3VsdCk7XG4gIH1cbiAgYXN5bmMgcHV0KHBhcmFtcywgYm9keSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucHV0KHRoaXMuY2xpZW50LCB0aGlzLnBhdGgsIGJvZHksIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUGFnZShyZXN1bHQpO1xuICB9XG4gIGFzeW5jIHBhdGNoKHBhcmFtcywgYm9keSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucGF0Y2godGhpcy5jbGllbnQsIHRoaXMucGF0aCwgYm9keSwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVQYWdlKHJlc3VsdCk7XG4gIH1cbiAgYXN5bmMgaGFuZGxlUGFnZShyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LmVyciAmJiByZXR1cm5FcnJPbmx5KHJlc3VsdC5lcnIsIHJlc3VsdC5ib2R5LCB0aGlzLnVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSkpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgXCJQYWdpbmF0ZWRSZXNvdXJjZS5oYW5kbGVQYWdlKClcIixcbiAgICAgICAgXCJVbmV4cGVjdGVkIGVycm9yIGdldHRpbmcgcmVzb3VyY2U6IGVyciA9IFwiICsgaW5zcGVjdEVycm9yKHJlc3VsdC5lcnIpXG4gICAgICApO1xuICAgICAgdGhyb3cgcmVzdWx0LmVycjtcbiAgICB9XG4gICAgbGV0IGl0ZW1zLCBsaW5rSGVhZGVyLCByZWxQYXJhbXM7XG4gICAgdHJ5IHtcbiAgICAgIGl0ZW1zID0gcmVzdWx0LnN0YXR1c0NvZGUgPT0gSHR0cFN0YXR1c0NvZGVzX2RlZmF1bHQuTm9Db250ZW50ID8gW10gOiBhd2FpdCB0aGlzLmJvZHlIYW5kbGVyKHJlc3VsdC5ib2R5LCByZXN1bHQuaGVhZGVycyB8fCB7fSwgcmVzdWx0LnVucGFja2VkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyByZXN1bHQuZXJyIHx8IGU7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuaGVhZGVycyAmJiAobGlua0hlYWRlciA9IHJlc3VsdC5oZWFkZXJzW1wiTGlua1wiXSB8fCByZXN1bHQuaGVhZGVyc1tcImxpbmtcIl0pKSB7XG4gICAgICByZWxQYXJhbXMgPSBwYXJzZVJlbExpbmtzKGxpbmtIZWFkZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBuZXcgSHR0cFBhZ2luYXRlZFJlc3BvbnNlKFxuICAgICAgICB0aGlzLFxuICAgICAgICBpdGVtcyxcbiAgICAgICAgcmVzdWx0LmhlYWRlcnMgfHwge30sXG4gICAgICAgIHJlc3VsdC5zdGF0dXNDb2RlLFxuICAgICAgICByZWxQYXJhbXMsXG4gICAgICAgIHJlc3VsdC5lcnJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUGFnaW5hdGVkUmVzdWx0KHRoaXMsIGl0ZW1zLCByZWxQYXJhbXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBQYWdpbmF0ZWRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlc291cmNlLCBpdGVtcywgcmVsUGFyYW1zKSB7XG4gICAgdGhpcy5yZXNvdXJjZSA9IHJlc291cmNlO1xuICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICBjb25zdCBzZWxmMiA9IHRoaXM7XG4gICAgaWYgKHJlbFBhcmFtcykge1xuICAgICAgaWYgKFwiZmlyc3RcIiBpbiByZWxQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5maXJzdCA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmMi5nZXQocmVsUGFyYW1zLmZpcnN0KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChcImN1cnJlbnRcIiBpbiByZWxQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYyLmdldChyZWxQYXJhbXMuY3VycmVudCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLm5leHQgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKFwibmV4dFwiIGluIHJlbFBhcmFtcykge1xuICAgICAgICAgIHJldHVybiBzZWxmMi5nZXQocmVsUGFyYW1zLm5leHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5oYXNOZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIm5leHRcIiBpbiByZWxQYXJhbXM7XG4gICAgICB9O1xuICAgICAgdGhpcy5pc0xhc3QgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAhKChfYTIgPSB0aGlzLmhhc05leHQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbCh0aGlzKSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiBXZSBhc3N1bWUgdGhhdCBvbmx5IHRoZSBpbml0aWFsIHJlcXVlc3QgY2FuIGJlIGEgUE9TVCwgYW5kIHRoYXQgYWNjZXNzaW5nXG4gICAqIHRoZSByZXN0IG9mIGEgbXVsdGlwYWdlIHNldCBvZiByZXN1bHRzIGNhbiBhbHdheXMgYmUgZG9uZSB3aXRoIEdFVCAqL1xuICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgY29uc3QgcmVzID0gdGhpcy5yZXNvdXJjZTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldChyZXMuY2xpZW50LCByZXMucGF0aCwgcmVzLmhlYWRlcnMsIHBhcmFtcywgcmVzLmVudmVsb3BlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHJlcy5oYW5kbGVQYWdlKHJlc3VsdCk7XG4gIH1cbn07XG52YXIgSHR0cFBhZ2luYXRlZFJlc3BvbnNlID0gY2xhc3MgZXh0ZW5kcyBQYWdpbmF0ZWRSZXN1bHQge1xuICBjb25zdHJ1Y3RvcihyZXNvdXJjZSwgaXRlbXMsIGhlYWRlcnMsIHN0YXR1c0NvZGUsIHJlbFBhcmFtcywgZXJyKSB7XG4gICAgc3VwZXIocmVzb3VyY2UsIGl0ZW1zLCByZWxQYXJhbXMpO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5zdWNjZXNzID0gc3RhdHVzQ29kZSA8IDMwMCAmJiBzdGF0dXNDb2RlID49IDIwMDtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMuZXJyb3JDb2RlID0gZXJyICYmIGVyci5jb2RlO1xuICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gZXJyICYmIGVyci5tZXNzYWdlO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICBzdGF0dXNDb2RlOiB0aGlzLnN0YXR1c0NvZGUsXG4gICAgICBzdWNjZXNzOiB0aGlzLnN1Y2Nlc3MsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBlcnJvckNvZGU6IHRoaXMuZXJyb3JDb2RlLFxuICAgICAgZXJyb3JNZXNzYWdlOiB0aGlzLmVycm9yTWVzc2FnZVxuICAgIH07XG4gIH1cbn07XG52YXIgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdCA9IFBhZ2luYXRlZFJlc291cmNlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9wdXNoY2hhbm5lbHN1YnNjcmlwdGlvbi50c1xudmFyIF9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbiA9IGNsYXNzIF9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbiB7XG4gIC8qKlxuICAgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFubmVsOiB0aGlzLmNoYW5uZWwsXG4gICAgICBkZXZpY2VJZDogdGhpcy5kZXZpY2VJZCxcbiAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkXG4gICAgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJbUHVzaENoYW5uZWxTdWJzY3JpcHRpb25cIjtcbiAgICBpZiAodGhpcy5jaGFubmVsKVxuICAgICAgcmVzdWx0ICs9IFwiOyBjaGFubmVsPVwiICsgdGhpcy5jaGFubmVsO1xuICAgIGlmICh0aGlzLmRldmljZUlkKVxuICAgICAgcmVzdWx0ICs9IFwiOyBkZXZpY2VJZD1cIiArIHRoaXMuZGV2aWNlSWQ7XG4gICAgaWYgKHRoaXMuY2xpZW50SWQpXG4gICAgICByZXN1bHQgKz0gXCI7IGNsaWVudElkPVwiICsgdGhpcy5jbGllbnRJZDtcbiAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgZnJvbVJlc3BvbnNlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICBib2R5ID0gZGVjb2RlQm9keShib2R5LCBNc2dQYWNrLCBmb3JtYXQpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShib2R5KSkge1xuICAgICAgcmV0dXJuIF9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzQXJyYXkoYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyhib2R5KTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbigpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgY29uc3QgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICAgIHJlc3VsdFtpXSA9IF9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzKHZhbHVlc1tpXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbl9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi50b1JlcXVlc3RCb2R5ID0gZW5jb2RlQm9keTtcbnZhciBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbiA9IF9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbjtcbnZhciBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl9kZWZhdWx0ID0gUHVzaENoYW5uZWxTdWJzY3JpcHRpb247XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9wdXNoLnRzXG52YXIgUHVzaCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdmFyIF9hMjtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLmFkbWluID0gbmV3IEFkbWluKGNsaWVudCk7XG4gICAgaWYgKFBsYXRmb3JtLkNvbmZpZy5wdXNoICYmICgoX2EyID0gY2xpZW50Lm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5QdXNoKSkge1xuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUgPSBuZXcgY2xpZW50Lm9wdGlvbnMucGx1Z2lucy5QdXNoLkFjdGl2YXRpb25TdGF0ZU1hY2hpbmUoY2xpZW50KTtcbiAgICAgIHRoaXMuTG9jYWxEZXZpY2UgPSBjbGllbnQub3B0aW9ucy5wbHVnaW5zLlB1c2gubG9jYWxEZXZpY2VGYWN0b3J5KGRldmljZWRldGFpbHNfZGVmYXVsdCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGFjdGl2YXRlKHJlZ2lzdGVyQ2FsbGJhY2ssIHVwZGF0ZUZhaWxlZENhbGxiYWNrKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmICghKChfYTIgPSB0aGlzLmNsaWVudC5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuUHVzaCkpIHtcbiAgICAgICAgcmVqZWN0KGNyZWF0ZU1pc3NpbmdQbHVnaW5FcnJvcihcIlB1c2hcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhdGVNYWNoaW5lKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3JJbmZvKFwiVGhpcyBwbGF0Zm9ybSBpcyBub3Qgc3VwcG9ydGVkIGFzIGEgdGFyZ2V0IG9mIHB1c2ggbm90aWZpY2F0aW9uc1wiLCA0ZTQsIDQwMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGF0ZU1hY2hpbmUuYWN0aXZhdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJBY3RpdmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiwgNGU0LCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUuYWN0aXZhdGVkQ2FsbGJhY2sgPSAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuc3RhdGVNYWNoaW5lLnVwZGF0ZUZhaWxlZENhbGxiYWNrID0gdXBkYXRlRmFpbGVkQ2FsbGJhY2s7XG4gICAgICB0aGlzLnN0YXRlTWFjaGluZS5oYW5kbGVFdmVudChcbiAgICAgICAgbmV3IHRoaXMuY2xpZW50Lm9wdGlvbnMucGx1Z2lucy5QdXNoLkNhbGxlZEFjdGl2YXRlKHRoaXMuc3RhdGVNYWNoaW5lLCByZWdpc3RlckNhbGxiYWNrKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBkZWFjdGl2YXRlKGRlcmVnaXN0ZXJDYWxsYmFjaykge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAoISgoX2EyID0gdGhpcy5jbGllbnQub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLlB1c2gpKSB7XG4gICAgICAgIHJlamVjdChjcmVhdGVNaXNzaW5nUGx1Z2luRXJyb3IoXCJQdXNoXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YXRlTWFjaGluZSkge1xuICAgICAgICByZWplY3QobmV3IEVycm9ySW5mbyhcIlRoaXMgcGxhdGZvcm0gaXMgbm90IHN1cHBvcnRlZCBhcyBhIHRhcmdldCBvZiBwdXNoIG5vdGlmaWNhdGlvbnNcIiwgNGU0LCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdGVNYWNoaW5lLmRlYWN0aXZhdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJEZWFjdGl2YXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzc1wiLCA0ZTQsIDQwMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlTWFjaGluZS5kZWFjdGl2YXRlZENhbGxiYWNrID0gKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnN0YXRlTWFjaGluZS5oYW5kbGVFdmVudChcbiAgICAgICAgbmV3IHRoaXMuY2xpZW50Lm9wdGlvbnMucGx1Z2lucy5QdXNoLkNhbGxlZERlYWN0aXZhdGUodGhpcy5zdGF0ZU1hY2hpbmUsIGRlcmVnaXN0ZXJDYWxsYmFjaylcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgQWRtaW4gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuZGV2aWNlUmVnaXN0cmF0aW9ucyA9IG5ldyBEZXZpY2VSZWdpc3RyYXRpb25zKGNsaWVudCk7XG4gICAgdGhpcy5jaGFubmVsU3Vic2NyaXB0aW9ucyA9IG5ldyBDaGFubmVsU3Vic2NyaXB0aW9ucyhjbGllbnQpO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2gocmVjaXBpZW50LCBwYXlsb2FkKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgY29uc3QgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KSwgcGFyYW1zID0ge307XG4gICAgY29uc3QgYm9keSA9IG1peGluKHsgcmVjaXBpZW50IH0sIHBheWxvYWQpO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gZW5jb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wb3N0KGNsaWVudCwgXCIvcHVzaC9wdWJsaXNoXCIsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIHRydWUpO1xuICB9XG59O1xudmFyIERldmljZVJlZ2lzdHJhdGlvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIGFzeW5jIHNhdmUoZGV2aWNlKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgY29uc3QgYm9keSA9IGRldmljZWRldGFpbHNfZGVmYXVsdC5mcm9tVmFsdWVzKGRldmljZSk7XG4gICAgY29uc3QgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KSwgcGFyYW1zID0ge307XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucHV0KFxuICAgICAgY2xpZW50LFxuICAgICAgXCIvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZS5pZCksXG4gICAgICByZXF1ZXN0Qm9keSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwYXJhbXMsXG4gICAgICBudWxsLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgcmV0dXJuIGRldmljZWRldGFpbHNfZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KFxuICAgICAgcmVzcG9uc2UuYm9keSxcbiAgICAgIGNsaWVudC5fTXNnUGFjayxcbiAgICAgIHJlc3BvbnNlLnVucGFja2VkID8gdm9pZCAwIDogZm9ybWF0XG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXQoZGV2aWNlSWRPckRldGFpbHMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pLCBkZXZpY2VJZCA9IGRldmljZUlkT3JEZXRhaWxzLmlkIHx8IGRldmljZUlkT3JEZXRhaWxzO1xuICAgIGlmICh0eXBlb2YgZGV2aWNlSWQgIT09IFwic3RyaW5nXCIgfHwgIWRldmljZUlkLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgXCJGaXJzdCBhcmd1bWVudCB0byBEZXZpY2VSZWdpc3RyYXRpb25zI2dldCBtdXN0IGJlIGEgZGV2aWNlSWQgc3RyaW5nIG9yIERldmljZURldGFpbHNcIixcbiAgICAgICAgNGU0LFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5nZXQoXG4gICAgICBjbGllbnQsXG4gICAgICBcIi9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlSWQpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHt9LFxuICAgICAgbnVsbCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiBkZXZpY2VkZXRhaWxzX2RlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShcbiAgICAgIHJlc3BvbnNlLmJvZHksXG4gICAgICBjbGllbnQuX01zZ1BhY2ssXG4gICAgICByZXNwb25zZS51bnBhY2tlZCA/IHZvaWQgMCA6IGZvcm1hdFxuICAgICk7XG4gIH1cbiAgYXN5bmMgbGlzdChwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSB0aGlzLmNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoY2xpZW50LCBcIi9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnNcIiwgaGVhZGVycywgZW52ZWxvcGUsIGFzeW5jIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMyLCB1bnBhY2tlZCkge1xuICAgICAgcmV0dXJuIGRldmljZWRldGFpbHNfZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KFxuICAgICAgICBib2R5LFxuICAgICAgICBjbGllbnQuX01zZ1BhY2ssXG4gICAgICAgIHVucGFja2VkID8gdm9pZCAwIDogZm9ybWF0XG4gICAgICApO1xuICAgIH0pLmdldChwYXJhbXMpO1xuICB9XG4gIGFzeW5jIHJlbW92ZShkZXZpY2VJZE9yRGV0YWlscykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSksIHBhcmFtcyA9IHt9LCBkZXZpY2VJZCA9IGRldmljZUlkT3JEZXRhaWxzLmlkIHx8IGRldmljZUlkT3JEZXRhaWxzO1xuICAgIGlmICh0eXBlb2YgZGV2aWNlSWQgIT09IFwic3RyaW5nXCIgfHwgIWRldmljZUlkLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgXCJGaXJzdCBhcmd1bWVudCB0byBEZXZpY2VSZWdpc3RyYXRpb25zI3JlbW92ZSBtdXN0IGJlIGEgZGV2aWNlSWQgc3RyaW5nIG9yIERldmljZURldGFpbHNcIixcbiAgICAgICAgNGU0LFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIGF3YWl0IHJlc291cmNlX2RlZmF1bHRbXCJkZWxldGVcIl0oXG4gICAgICBjbGllbnQsXG4gICAgICBcIi9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlSWQpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuICBhc3luYyByZW1vdmVXaGVyZShwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICBtaXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6IFwidHJ1ZVwiIH0pO1xuICAgIGF3YWl0IHJlc291cmNlX2RlZmF1bHRbXCJkZWxldGVcIl0oY2xpZW50LCBcIi9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnNcIiwgaGVhZGVycywgcGFyYW1zLCBudWxsLCB0cnVlKTtcbiAgfVxufTtcbnZhciBDaGFubmVsU3Vic2NyaXB0aW9ucyA9IGNsYXNzIF9DaGFubmVsU3Vic2NyaXB0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIC8qIENoYW5uZWxTdWJzY3JpcHRpb25zIGhhdmUgbm8gdW5pcXVlIGlkOyByZW1vdmluZyBvbmUgaXMgZXF1aXZhbGVudCB0byByZW1vdmVXaGVyZSBieSBpdHMgcHJvcGVydGllcyAqL1xuICAgIHRoaXMucmVtb3ZlID0gX0NoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5yZW1vdmVXaGVyZTtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgfVxuICBhc3luYyBzYXZlKHN1YnNjcmlwdGlvbikge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IGJvZHkgPSBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl9kZWZhdWx0LmZyb21WYWx1ZXMoc3Vic2NyaXB0aW9uKTtcbiAgICBjb25zdCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pLCBwYXJhbXMgPSB7fTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoY2xpZW50Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgbWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiBcInRydWVcIiB9KTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzb3VyY2VfZGVmYXVsdC5wb3N0KFxuICAgICAgY2xpZW50LFxuICAgICAgXCIvcHVzaC9jaGFubmVsU3Vic2NyaXB0aW9uc1wiLFxuICAgICAgcmVxdWVzdEJvZHksXG4gICAgICBoZWFkZXJzLFxuICAgICAgcGFyYW1zLFxuICAgICAgbnVsbCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl9kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoXG4gICAgICByZXNwb25zZS5ib2R5LFxuICAgICAgY2xpZW50Ll9Nc2dQYWNrLFxuICAgICAgcmVzcG9uc2UudW5wYWNrZWQgPyB2b2lkIDAgOiBmb3JtYXRcbiAgICApO1xuICB9XG4gIGFzeW5jIGxpc3QocGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KGNsaWVudCwgXCIvcHVzaC9jaGFubmVsU3Vic2NyaXB0aW9uc1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgYXN5bmMgZnVuY3Rpb24oYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICByZXR1cm4gcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KFxuICAgICAgICBib2R5LFxuICAgICAgICBjbGllbnQuX01zZ1BhY2ssXG4gICAgICAgIHVucGFja2VkID8gdm9pZCAwIDogZm9ybWF0XG4gICAgICApO1xuICAgIH0pLmdldChwYXJhbXMpO1xuICB9XG4gIGFzeW5jIHJlbW92ZVdoZXJlKHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgYXdhaXQgcmVzb3VyY2VfZGVmYXVsdFtcImRlbGV0ZVwiXShjbGllbnQsIFwiL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnNcIiwgaGVhZGVycywgcGFyYW1zLCBudWxsLCB0cnVlKTtcbiAgfVxuICBhc3luYyBsaXN0Q2hhbm5lbHMocGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnQsIGZvcm1hdCA9IGNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgIG1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogXCJ0cnVlXCIgfSk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KGNsaWVudCwgXCIvcHVzaC9jaGFubmVsc1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgYXN5bmMgZnVuY3Rpb24oYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICBjb25zdCBwYXJzZWRCb2R5ID0gIXVucGFja2VkICYmIGZvcm1hdCA/IGRlY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpIDogYm9keTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkQm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJzZWRCb2R5W2ldID0gU3RyaW5nKHBhcnNlZEJvZHlbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZEJvZHk7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbn07XG52YXIgcHVzaF9kZWZhdWx0ID0gUHVzaDtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvcHJvdG9jb2xtZXNzYWdlY29tbW9uLnRzXG52YXIgYWN0aW9ucyA9IHtcbiAgSEVBUlRCRUFUOiAwLFxuICBBQ0s6IDEsXG4gIE5BQ0s6IDIsXG4gIENPTk5FQ1Q6IDMsXG4gIENPTk5FQ1RFRDogNCxcbiAgRElTQ09OTkVDVDogNSxcbiAgRElTQ09OTkVDVEVEOiA2LFxuICBDTE9TRTogNyxcbiAgQ0xPU0VEOiA4LFxuICBFUlJPUjogOSxcbiAgQVRUQUNIOiAxMCxcbiAgQVRUQUNIRUQ6IDExLFxuICBERVRBQ0g6IDEyLFxuICBERVRBQ0hFRDogMTMsXG4gIFBSRVNFTkNFOiAxNCxcbiAgTUVTU0FHRTogMTUsXG4gIFNZTkM6IDE2LFxuICBBVVRIOiAxNyxcbiAgQUNUSVZBVEU6IDE4LFxuICBTVEFURTogMTksXG4gIFNUQVRFX1NZTkM6IDIwLFxuICBBTk5PVEFUSU9OOiAyMVxufTtcbnZhciBBY3Rpb25OYW1lID0gW107XG5PYmplY3Qua2V5cyhhY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgQWN0aW9uTmFtZVthY3Rpb25zW25hbWVdXSA9IG5hbWU7XG59KTtcbnZhciBmbGFncyA9IHtcbiAgLyogQ2hhbm5lbCBhdHRhY2ggc3RhdGUgZmxhZ3MgKi9cbiAgSEFTX1BSRVNFTkNFOiAxIDw8IDAsXG4gIEhBU19CQUNLTE9HOiAxIDw8IDEsXG4gIFJFU1VNRUQ6IDEgPDwgMixcbiAgVFJBTlNJRU5UOiAxIDw8IDQsXG4gIEFUVEFDSF9SRVNVTUU6IDEgPDwgNSxcbiAgLyogQ2hhbm5lbCBtb2RlIGZsYWdzICovXG4gIFBSRVNFTkNFOiAxIDw8IDE2LFxuICBQVUJMSVNIOiAxIDw8IDE3LFxuICBTVUJTQ1JJQkU6IDEgPDwgMTgsXG4gIFBSRVNFTkNFX1NVQlNDUklCRTogMSA8PCAxOSxcbiAgQU5OT1RBVElPTl9QVUJMSVNIOiAxIDw8IDIxLFxuICBBTk5PVEFUSU9OX1NVQlNDUklCRTogMSA8PCAyMlxufTtcbnZhciBmbGFnTmFtZXMgPSBPYmplY3Qua2V5cyhmbGFncyk7XG5mbGFncy5NT0RFX0FMTCA9IGZsYWdzLlBSRVNFTkNFIHwgZmxhZ3MuUFVCTElTSCB8IGZsYWdzLlNVQlNDUklCRSB8IGZsYWdzLlBSRVNFTkNFX1NVQlNDUklCRSB8IGZsYWdzLkFOTk9UQVRJT05fUFVCTElTSCB8IGZsYWdzLkFOTk9UQVRJT05fU1VCU0NSSUJFO1xudmFyIGNoYW5uZWxNb2RlcyA9IFtcbiAgXCJQUkVTRU5DRVwiLFxuICBcIlBVQkxJU0hcIixcbiAgXCJTVUJTQ1JJQkVcIixcbiAgXCJQUkVTRU5DRV9TVUJTQ1JJQkVcIixcbiAgXCJBTk5PVEFUSU9OX1BVQkxJU0hcIixcbiAgXCJBTk5PVEFUSU9OX1NVQlNDUklCRVwiXG5dO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9iYXNlbWVzc2FnZS50c1xuZnVuY3Rpb24gbm9ybWFsaXNlQ29udGV4dChjb250ZXh0KSB7XG4gIGlmICghY29udGV4dCB8fCAhY29udGV4dC5jaGFubmVsT3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFubmVsT3B0aW9uczogY29udGV4dCxcbiAgICAgIHBsdWdpbnM6IHt9LFxuICAgICAgYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDaXBoZXJPcHRpb25zKENyeXB0bzIsIGxvZ2dlciwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNpcGhlcikge1xuICAgIGlmICghQ3J5cHRvMilcbiAgICAgIHRocm93TWlzc2luZ1BsdWdpbkVycm9yKFwiQ3J5cHRvXCIpO1xuICAgIGNvbnN0IGNpcGhlciA9IENyeXB0bzIuZ2V0Q2lwaGVyKG9wdGlvbnMuY2lwaGVyLCBsb2dnZXIpO1xuICAgIHJldHVybiB7XG4gICAgICBjaXBoZXI6IGNpcGhlci5jaXBoZXJQYXJhbXMsXG4gICAgICBjaGFubmVsQ2lwaGVyOiBjaXBoZXIuY2lwaGVyXG4gICAgfTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdChtc2csIG9wdGlvbnMpIHtcbiAgbGV0IGRhdGEgPSBtc2cuZGF0YSwgZW5jb2RpbmcgPSBtc2cuZW5jb2RpbmcsIGNpcGhlciA9IG9wdGlvbnMuY2hhbm5lbENpcGhlcjtcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyA/IGVuY29kaW5nICsgXCIvXCIgOiBcIlwiO1xuICBpZiAoIVBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgZGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUoU3RyaW5nKGRhdGEpKTtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nICsgXCJ1dGYtOC9cIjtcbiAgfVxuICBjb25zdCBjaXBoZXJ0ZXh0ID0gYXdhaXQgY2lwaGVyLmVuY3J5cHQoZGF0YSk7XG4gIG1zZy5kYXRhID0gY2lwaGVydGV4dDtcbiAgbXNnLmVuY29kaW5nID0gZW5jb2RpbmcgKyBcImNpcGhlcitcIiArIGNpcGhlci5hbGdvcml0aG07XG4gIHJldHVybiBtc2c7XG59XG5hc3luYyBmdW5jdGlvbiBlbmNvZGUobXNnLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRhdGEgPSBtc2cuZGF0YTtcbiAgY29uc3QgbmF0aXZlRGF0YVR5cGUgPSB0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiIHx8IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwO1xuICBpZiAoIW5hdGl2ZURhdGFUeXBlKSB7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpIHx8IEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIG1zZy5kYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICBtc2cuZW5jb2RpbmcgPSBtc2cuZW5jb2RpbmcgPyBtc2cuZW5jb2RpbmcgKyBcIi9qc29uXCIgOiBcImpzb25cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIkRhdGEgdHlwZSBpcyB1bnN1cHBvcnRlZFwiLCA0MDAxMywgNDAwKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmNpcGhlcikge1xuICAgIHJldHVybiBlbmNyeXB0KG1zZywgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1zZztcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlKG1lc3NhZ2UsIGlucHV0Q29udGV4dCkge1xuICBjb25zdCBjb250ZXh0ID0gbm9ybWFsaXNlQ29udGV4dChpbnB1dENvbnRleHQpO1xuICBsZXQgbGFzdFBheWxvYWQgPSBtZXNzYWdlLmRhdGE7XG4gIGNvbnN0IGVuY29kaW5nID0gbWVzc2FnZS5lbmNvZGluZztcbiAgaWYgKGVuY29kaW5nKSB7XG4gICAgY29uc3QgeGZvcm1zID0gZW5jb2Rpbmcuc3BsaXQoXCIvXCIpO1xuICAgIGxldCBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCwgZW5jb2RpbmdzVG9Qcm9jZXNzID0geGZvcm1zLmxlbmd0aCwgZGF0YSA9IG1lc3NhZ2UuZGF0YTtcbiAgICBsZXQgeGZvcm0gPSBcIlwiO1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAoKGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4ID0gZW5jb2RpbmdzVG9Qcm9jZXNzKSA+IDApIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB4Zm9ybXNbLS1lbmNvZGluZ3NUb1Byb2Nlc3NdLm1hdGNoKC8oWy1cXHddKykoXFwrKFtcXHctXSspKT8vKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgeGZvcm0gPSBtYXRjaFsxXTtcbiAgICAgICAgc3dpdGNoICh4Zm9ybSkge1xuICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgIGRhdGEgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy5iYXNlNjREZWNvZGUoU3RyaW5nKGRhdGEpKTtcbiAgICAgICAgICAgIGlmIChsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA9PSB4Zm9ybXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGxhc3RQYXlsb2FkID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgXCJ1dGYtOFwiOlxuICAgICAgICAgICAgZGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnV0ZjhEZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFwiY2lwaGVyXCI6XG4gICAgICAgICAgICBpZiAoY29udGV4dC5jaGFubmVsT3B0aW9ucyAhPSBudWxsICYmIGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2lwaGVyICYmIGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlcikge1xuICAgICAgICAgICAgICBjb25zdCB4Zm9ybUFsZ29yaXRobSA9IG1hdGNoWzNdLCBjaXBoZXIgPSBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXI7XG4gICAgICAgICAgICAgIGlmICh4Zm9ybUFsZ29yaXRobSAhPSBjaXBoZXIuYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZSB3aXRoIGdpdmVuIGNpcGhlcjsgaW5jb21wYXRpYmxlIGNpcGhlciBwYXJhbXNcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YSA9IGF3YWl0IGNpcGhlci5kZWNyeXB0KGRhdGEpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWNyeXB0IG1lc3NhZ2U7IG5vdCBhbiBlbmNyeXB0ZWQgY2hhbm5lbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidmNkaWZmXCI6XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQucGx1Z2lucyB8fCAhY29udGV4dC5wbHVnaW5zLnZjZGlmZikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiTWlzc2luZyBWY2RpZmYgZGVjb2RlciAoaHR0cHM6Ly9naXRodWIuY29tL2FibHktZm9ya3MvdmNkaWZmLWRlY29kZXIpXCIsIDQwMDE5LCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgICAgICAgICAgXCJEZWx0YSBkZWNvZGluZyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlciAobmVlZCBBcnJheUJ1ZmZlciAmIFVpbnQ4QXJyYXkpXCIsXG4gICAgICAgICAgICAgICAgNDAwMjAsXG4gICAgICAgICAgICAgICAgNDAwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgZGVsdGFCYXNlID0gY29udGV4dC5iYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWx0YUJhc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBkZWx0YUJhc2UgPSBQbGF0Zm9ybS5CdWZmZXJVdGlscy51dGY4RW5jb2RlKGRlbHRhQmFzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZGVsdGFCYXNlQnVmZmVyID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMudG9CdWZmZXIoZGVsdGFCYXNlKTtcbiAgICAgICAgICAgICAgZGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnRvQnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgICBkYXRhID0gUGxhdGZvcm0uQnVmZmVyVXRpbHMuYXJyYXlCdWZmZXJWaWV3VG9CdWZmZXIoY29udGV4dC5wbHVnaW5zLnZjZGlmZi5kZWNvZGUoZGF0YSwgZGVsdGFCYXNlQnVmZmVyKSk7XG4gICAgICAgICAgICAgIGxhc3RQYXlsb2FkID0gZGF0YTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlZjZGlmZiBkZWx0YSBkZWNvZGUgZmFpbGVkIHdpdGggXCIgKyBlLCA0MDAxOCwgNDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVuY29kaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgZXJyID0gZTtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiRXJyb3IgcHJvY2Vzc2luZyB0aGUgXCIgKyB4Zm9ybSArIFwiIGVuY29kaW5nLCBkZWNvZGVyIHJldHVybmVkIFxcdTIwMThcIiArIGVyci5tZXNzYWdlICsgXCJcXHUyMDE5XCIsXG4gICAgICAgIGVyci5jb2RlIHx8IDQwMDEzLFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG1lc3NhZ2UuZW5jb2RpbmcgPSBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA8PSAwID8gbnVsbCA6IHhmb3Jtcy5zbGljZSgwLCBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCkuam9pbihcIi9cIik7XG4gICAgICBtZXNzYWdlLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgfVxuICBjb250ZXh0LmJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkID0gbGFzdFBheWxvYWQ7XG59XG5mdW5jdGlvbiB3aXJlVG9KU09OKC4uLmFyZ3MpIHtcbiAgbGV0IGVuY29kaW5nID0gdGhpcy5lbmNvZGluZztcbiAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gIGlmIChkYXRhICYmIFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyA/IGVuY29kaW5nICsgXCIvYmFzZTY0XCIgOiBcImJhc2U2NFwiO1xuICAgICAgZGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IFBsYXRmb3JtLkJ1ZmZlclV0aWxzLnRvQnVmZmVyKGRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcywgeyBlbmNvZGluZywgZGF0YSB9KTtcbn1cbmZ1bmN0aW9uIHBvcHVsYXRlRmllbGRzRnJvbVBhcmVudChwYXJlbnQpIHtcbiAgY29uc3QgeyBpZCwgY29ubmVjdGlvbklkLCB0aW1lc3RhbXAgfSA9IHBhcmVudDtcbiAgbGV0IG1zZ3M7XG4gIHN3aXRjaCAocGFyZW50LmFjdGlvbikge1xuICAgIGNhc2UgYWN0aW9ucy5NRVNTQUdFOiB7XG4gICAgICBtc2dzID0gcGFyZW50Lm1lc3NhZ2VzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgYWN0aW9ucy5QUkVTRU5DRTpcbiAgICBjYXNlIGFjdGlvbnMuU1lOQzpcbiAgICAgIG1zZ3MgPSBwYXJlbnQucHJlc2VuY2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFjdGlvbnMuQU5OT1RBVElPTjpcbiAgICAgIG1zZ3MgPSBwYXJlbnQuYW5ub3RhdGlvbnM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuZXhwZWN0ZWQgYWN0aW9uIFwiICsgcGFyZW50LmFjdGlvbiwgNGU0LCA0MDApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbXNncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1zZyA9IG1zZ3NbaV07XG4gICAgaWYgKCFtc2cuY29ubmVjdGlvbklkKSB7XG4gICAgICBtc2cuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICAgIH1cbiAgICBpZiAoIW1zZy50aW1lc3RhbXApIHtcbiAgICAgIG1zZy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgfVxuICAgIGlmIChpZCAmJiAhbXNnLmlkKSB7XG4gICAgICBtc2cuaWQgPSBpZCArIFwiOlwiICsgaTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN0ck1zZyhtLCBjbHMpIHtcbiAgbGV0IHJlc3VsdCA9IFwiW1wiICsgY2xzO1xuICBmb3IgKGNvbnN0IGF0dHIgaW4gbSkge1xuICAgIGlmIChhdHRyID09PSBcImRhdGFcIikge1xuICAgICAgaWYgKHR5cGVvZiBtLmRhdGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXN1bHQgKz0gXCI7IGRhdGE9XCIgKyBtLmRhdGE7XG4gICAgICB9IGVsc2UgaWYgKFBsYXRmb3JtLkJ1ZmZlclV0aWxzLmlzQnVmZmVyKG0uZGF0YSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiOyBkYXRhIChidWZmZXIpPVwiICsgUGxhdGZvcm0uQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKG0uZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gXCI7IGRhdGEgKGpzb24pPVwiICsgSlNPTi5zdHJpbmdpZnkobS5kYXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGF0dHIgJiYgKGF0dHIgPT09IFwiZXh0cmFzXCIgfHwgYXR0ciA9PT0gXCJvcGVyYXRpb25cIikpIHtcbiAgICAgIHJlc3VsdCArPSBcIjsgXCIgKyBhdHRyICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeShtW2F0dHJdKTtcbiAgICB9IGVsc2UgaWYgKG1bYXR0cl0gIT09IHZvaWQgMCkge1xuICAgICAgcmVzdWx0ICs9IFwiOyBcIiArIGF0dHIgKyBcIj1cIiArIG1bYXR0cl07XG4gICAgfVxuICB9XG4gIHJlc3VsdCArPSBcIl1cIjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBCYXNlTWVzc2FnZSA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL3ByZXNlbmNlbWVzc2FnZS50c1xudmFyIGFjdGlvbnMyID0gW1wiYWJzZW50XCIsIFwicHJlc2VudFwiLCBcImVudGVyXCIsIFwibGVhdmVcIiwgXCJ1cGRhdGVcIl07XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZChsb2dnZXIsIENyeXB0bzIsIGVuY29kZWQsIGlucHV0T3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gbm9ybWFsaXplQ2lwaGVyT3B0aW9ucyhDcnlwdG8yLCBsb2dnZXIsIGlucHV0T3B0aW9ucyAhPSBudWxsID8gaW5wdXRPcHRpb25zIDogbnVsbCk7XG4gIGNvbnN0IHdwbSA9IFdpcmVQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyhlbmNvZGVkKTtcbiAgcmV0dXJuIHdwbS5kZWNvZGUob3B0aW9ucywgbG9nZ2VyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZyb21FbmNvZGVkQXJyYXkobG9nZ2VyLCBDcnlwdG8yLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIGZyb21FbmNvZGVkKGxvZ2dlciwgQ3J5cHRvMiwgZW5jb2RlZCwgb3B0aW9ucyk7XG4gICAgfSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tRW5jb2RlZChlbmNvZGVkLCBjaGFubmVsKSB7XG4gIHJldHVybiBXaXJlUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCkuZGVjb2RlKGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMsIGNoYW5uZWwubG9nZ2VyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tRW5jb2RlZEFycmF5KGVuY29kZWRBcnJheSwgY2hhbm5lbCkge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICByZXR1cm4gX2Zyb21FbmNvZGVkKGVuY29kZWQsIGNoYW5uZWwpO1xuICAgIH0pXG4gICk7XG59XG52YXIgUHJlc2VuY2VNZXNzYWdlID0gY2xhc3MgX1ByZXNlbmNlTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgLyogUmV0dXJucyB3aGV0aGVyIHRoaXMgcHJlc2VuY2VNZXNzYWdlIGlzIHN5bnRoZXNpemVkLCBpLmUuIHdhcyBub3QgYWN0dWFsbHlcbiAgICogc2VudCBieSB0aGUgY29ubmVjdGlvbiAodXN1YWxseSBtZWFucyBhIGxlYXZlIGV2ZW50IHNlbnQgMTVzIGFmdGVyIGFcbiAgICogZGlzY29ubmVjdGlvbikuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2Ugc3ludGhlc2l6ZWQgbWVzc2FnZXMgY2Fubm90IGJlXG4gICAqIGNvbXBhcmVkIGZvciBuZXduZXNzIGJ5IGlkIGxleGljb2dyYXBoaWNhbGx5IC0gUlRQMmIxXG4gICAqL1xuICBpc1N5bnRoZXNpemVkKCkge1xuICAgIGlmICghdGhpcy5pZCB8fCAhdGhpcy5jb25uZWN0aW9uSWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pZC5zdWJzdHJpbmcodGhpcy5jb25uZWN0aW9uSWQubGVuZ3RoLCAwKSAhPT0gdGhpcy5jb25uZWN0aW9uSWQ7XG4gIH1cbiAgLyogUlRQMmIyICovXG4gIHBhcnNlSWQoKSB7XG4gICAgaWYgKCF0aGlzLmlkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFyc2VJZCgpOiBQcmVzZW5jZSBtZXNzYWdlIGRvZXMgbm90IGNvbnRhaW4gYW4gaWRcIik7XG4gICAgY29uc3QgcGFydHMgPSB0aGlzLmlkLnNwbGl0KFwiOlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29ubmVjdGlvbklkOiBwYXJ0c1swXSxcbiAgICAgIG1zZ1NlcmlhbDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgIGluZGV4OiBwYXJzZUludChwYXJ0c1syXSwgMTApXG4gICAgfTtcbiAgfVxuICBhc3luYyBlbmNvZGUob3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IE9iamVjdC5hc3NpZ24obmV3IFdpcmVQcmVzZW5jZU1lc3NhZ2UoKSwgdGhpcywge1xuICAgICAgYWN0aW9uOiBhY3Rpb25zMi5pbmRleE9mKHRoaXMuYWN0aW9uIHx8IFwicHJlc2VudFwiKVxuICAgIH0pO1xuICAgIHJldHVybiBlbmNvZGUocmVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX1ByZXNlbmNlTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHYpID0+IF9QcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyh2KSk7XG4gIH1cbiAgc3RhdGljIGZyb21EYXRhKGRhdGEpIHtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIF9QcmVzZW5jZU1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gX1ByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKHtcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc3RyTXNnKHRoaXMsIFwiUHJlc2VuY2VNZXNzYWdlXCIpO1xuICB9XG59O1xudmFyIFdpcmVQcmVzZW5jZU1lc3NhZ2UgPSBjbGFzcyBfV2lyZVByZXNlbmNlTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgdG9KU09OKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gd2lyZVRvSlNPTi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfV2lyZVByZXNlbmNlTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHYpID0+IF9XaXJlUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXModikpO1xuICB9XG4gIGFzeW5jIGRlY29kZShjaGFubmVsT3B0aW9ucywgbG9nZ2VyKSB7XG4gICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbihuZXcgUHJlc2VuY2VNZXNzYWdlKCksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMpLCB7XG4gICAgICBhY3Rpb246IGFjdGlvbnMyW3RoaXMuYWN0aW9uXVxuICAgIH0pKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZGVjb2RlKHJlcywgY2hhbm5lbE9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJXaXJlUHJlc2VuY2VNZXNzYWdlLmRlY29kZSgpXCIsIGluc3BlY3RFcnJvcihlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHN0ck1zZyh0aGlzLCBcIldpcmVQcmVzZW5jZU1lc3NhZ2VcIik7XG4gIH1cbn07XG52YXIgcHJlc2VuY2VtZXNzYWdlX2RlZmF1bHQgPSBQcmVzZW5jZU1lc3NhZ2U7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZXN0cHJlc2VuY2UudHNcbnZhciBSZXN0UHJlc2VuY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwpIHtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5sb2dnZXI7XG4gIH1cbiAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RQcmVzZW5jZS5nZXQoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMuY2hhbm5lbC5uYW1lKTtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNoYW5uZWwuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IHRoaXMuY2hhbm5lbC5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0LCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyhjbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgbWl4aW4oaGVhZGVycywgY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KFxuICAgICAgY2xpZW50LFxuICAgICAgdGhpcy5jaGFubmVsLmNsaWVudC5yZXN0LnByZXNlbmNlTWl4aW4uYmFzZVBhdGgodGhpcyksXG4gICAgICBoZWFkZXJzLFxuICAgICAgZW52ZWxvcGUsXG4gICAgICBhc3luYyAoYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSB1bnBhY2tlZCA/IGJvZHkgOiBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZEFycmF5KGRlY29kZWQsIHRoaXMuY2hhbm5lbCk7XG4gICAgICB9XG4gICAgKS5nZXQocGFyYW1zKTtcbiAgfVxuICBhc3luYyBoaXN0b3J5KHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RQcmVzZW5jZS5oaXN0b3J5KClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLmNoYW5uZWwubmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5jbGllbnQucmVzdC5wcmVzZW5jZU1peGluLmhpc3RvcnkodGhpcywgcGFyYW1zKTtcbiAgfVxufTtcbnZhciByZXN0cHJlc2VuY2VfZGVmYXVsdCA9IFJlc3RQcmVzZW5jZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvbWVzc2FnZS50c1xudmFyIGFjdGlvbnMzID0gW1wibWVzc2FnZS5jcmVhdGVcIiwgXCJtZXNzYWdlLnVwZGF0ZVwiLCBcIm1lc3NhZ2UuZGVsZXRlXCIsIFwibWV0YVwiLCBcIm1lc3NhZ2Uuc3VtbWFyeVwiXTtcbmZ1bmN0aW9uIHN0cmluZ2lmeUFjdGlvbihhY3Rpb24pIHtcbiAgcmV0dXJuIGFjdGlvbnMzW2FjdGlvbiB8fCAwXSB8fCBcInVua25vd25cIjtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VTaXplKG1zZykge1xuICBsZXQgc2l6ZSA9IDA7XG4gIGlmIChtc2cubmFtZSkge1xuICAgIHNpemUgKz0gbXNnLm5hbWUubGVuZ3RoO1xuICB9XG4gIGlmIChtc2cuY2xpZW50SWQpIHtcbiAgICBzaXplICs9IG1zZy5jbGllbnRJZC5sZW5ndGg7XG4gIH1cbiAgaWYgKG1zZy5leHRyYXMpIHtcbiAgICBzaXplICs9IEpTT04uc3RyaW5naWZ5KG1zZy5leHRyYXMpLmxlbmd0aDtcbiAgfVxuICBpZiAobXNnLmRhdGEpIHtcbiAgICBzaXplICs9IGRhdGFTaXplQnl0ZXMobXNnLmRhdGEpO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuYXN5bmMgZnVuY3Rpb24gZnJvbUVuY29kZWQyKGxvZ2dlciwgQ3J5cHRvMiwgZW5jb2RlZCwgaW5wdXRPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBub3JtYWxpemVDaXBoZXJPcHRpb25zKENyeXB0bzIsIGxvZ2dlciwgaW5wdXRPcHRpb25zICE9IG51bGwgPyBpbnB1dE9wdGlvbnMgOiBudWxsKTtcbiAgY29uc3Qgd20gPSBXaXJlTWVzc2FnZS5mcm9tVmFsdWVzKGVuY29kZWQpO1xuICByZXR1cm4gd20uZGVjb2RlKG9wdGlvbnMsIGxvZ2dlcik7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZEFycmF5Mihsb2dnZXIsIENyeXB0bzIsIGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICByZXR1cm4gZnJvbUVuY29kZWQyKGxvZ2dlciwgQ3J5cHRvMiwgZW5jb2RlZCwgb3B0aW9ucyk7XG4gICAgfSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tRW5jb2RlZDIoZW5jb2RlZCwgY2hhbm5lbCkge1xuICBjb25zdCB3bSA9IFdpcmVNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCk7XG4gIHJldHVybiB3bS5kZWNvZGUoY2hhbm5lbC5jaGFubmVsT3B0aW9ucywgY2hhbm5lbC5sb2dnZXIpO1xufVxuYXN5bmMgZnVuY3Rpb24gX2Zyb21FbmNvZGVkQXJyYXkyKGVuY29kZWRBcnJheSwgY2hhbm5lbCkge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICByZXR1cm4gX2Zyb21FbmNvZGVkMihlbmNvZGVkLCBjaGFubmVsKTtcbiAgICB9KVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jb2RlQXJyYXkobWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKG1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4gbWVzc2FnZS5lbmNvZGUob3B0aW9ucykpKTtcbn1cbnZhciBzZXJpYWxpemUgPSBlbmNvZGVCb2R5O1xuZnVuY3Rpb24gZ2V0TWVzc2FnZXNTaXplKG1lc3NhZ2VzKSB7XG4gIGxldCBtc2csIHRvdGFsID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgIG1zZyA9IG1lc3NhZ2VzW2ldO1xuICAgIHRvdGFsICs9IG1zZy5zaXplIHx8IChtc2cuc2l6ZSA9IGdldE1lc3NhZ2VTaXplKG1zZykpO1xuICB9XG4gIHJldHVybiB0b3RhbDtcbn1cbnZhciBNZXNzYWdlID0gY2xhc3MgX01lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIC8vIFRPRE8gaW1wcm92ZSB0eXBpbmdzIGFmdGVyIHN1bW1hcnkgc3RydWN0dXJlIGlzIGZpbmFsaXNlZFxuICBleHBhbmRGaWVsZHMoKSB7XG4gICAgaWYgKHRoaXMuYWN0aW9uID09PSBcIm1lc3NhZ2UuY3JlYXRlXCIpIHtcbiAgICAgIGlmICh0aGlzLnZlcnNpb24gJiYgIXRoaXMuc2VyaWFsKSB7XG4gICAgICAgIHRoaXMuc2VyaWFsID0gdGhpcy52ZXJzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGltZXN0YW1wICYmICF0aGlzLmNyZWF0ZWRBdCkge1xuICAgICAgICB0aGlzLmNyZWF0ZWRBdCA9IHRoaXMudGltZXN0YW1wO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBlbmNvZGUob3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IE9iamVjdC5hc3NpZ24obmV3IFdpcmVNZXNzYWdlKCksIHRoaXMsIHtcbiAgICAgIGFjdGlvbjogYWN0aW9uczMuaW5kZXhPZih0aGlzLmFjdGlvbiB8fCBcIm1lc3NhZ2UuY3JlYXRlXCIpXG4gICAgfSk7XG4gICAgcmV0dXJuIGVuY29kZShyZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBfTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHYpID0+IF9NZXNzYWdlLmZyb21WYWx1ZXModikpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBzdHJNc2codGhpcywgXCJNZXNzYWdlXCIpO1xuICB9XG59O1xudmFyIFdpcmVNZXNzYWdlID0gY2xhc3MgX1dpcmVNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAvLyBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuICB0b0pTT04oLi4uYXJncykge1xuICAgIHJldHVybiB3aXJlVG9KU09OLmNhbGwodGhpcywgLi4uYXJncyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9XaXJlTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHYpID0+IF9XaXJlTWVzc2FnZS5mcm9tVmFsdWVzKHYpKTtcbiAgfVxuICAvLyBmb3IgY29udGV4dHMgd2hlcmUgc29tZSBkZWNvZGluZyBlcnJvcnMgbmVlZCB0byBiZSBoYW5kbGVkIHNwZWNpYWxseSBieSB0aGUgY2FsbGVyXG4gIGFzeW5jIGRlY29kZVdpdGhFcnIoaW5wdXRDb250ZXh0LCBsb2dnZXIpIHtcbiAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKG5ldyBNZXNzYWdlKCksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMpLCB7XG4gICAgICBhY3Rpb246IHN0cmluZ2lmeUFjdGlvbih0aGlzLmFjdGlvbilcbiAgICB9KSk7XG4gICAgbGV0IGVycjtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZGVjb2RlKHJlcywgaW5wdXRDb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiV2lyZU1lc3NhZ2UuZGVjb2RlKClcIiwgaW5zcGVjdEVycm9yKGUpKTtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuICAgIHJlcy5leHBhbmRGaWVsZHMoKTtcbiAgICByZXR1cm4geyBkZWNvZGVkOiByZXMsIGVyciB9O1xuICB9XG4gIGFzeW5jIGRlY29kZShpbnB1dENvbnRleHQsIGxvZ2dlcikge1xuICAgIGNvbnN0IHsgZGVjb2RlZCB9ID0gYXdhaXQgdGhpcy5kZWNvZGVXaXRoRXJyKGlucHV0Q29udGV4dCwgbG9nZ2VyKTtcbiAgICByZXR1cm4gZGVjb2RlZDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc3RyTXNnKHRoaXMsIFwiV2lyZU1lc3NhZ2VcIik7XG4gIH1cbn07XG52YXIgbWVzc2FnZV9kZWZhdWx0ID0gTWVzc2FnZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3RjaGFubmVsLnRzXG52YXIgTVNHX0lEX0VOVFJPUFlfQllURVMgPSA5O1xuZnVuY3Rpb24gYWxsRW1wdHlJZHMobWVzc2FnZXMpIHtcbiAgcmV0dXJuIG1lc3NhZ2VzLmV2ZXJ5KGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gIW1lc3NhZ2UuaWQ7XG4gIH0pO1xufVxudmFyIFJlc3RDaGFubmVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBudWxsO1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihjbGllbnQubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVzdENoYW5uZWwoKVwiLCBcInN0YXJ0ZWQ7IG5hbWUgPSBcIiArIG5hbWUpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wcmVzZW5jZSA9IG5ldyByZXN0cHJlc2VuY2VfZGVmYXVsdCh0aGlzKTtcbiAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoKF9hMiA9IGNsaWVudC5fQ3J5cHRvKSAhPSBudWxsID8gX2EyIDogbnVsbCwgdGhpcy5sb2dnZXIsIGNoYW5uZWxPcHRpb25zKTtcbiAgICBpZiAoKF9iID0gY2xpZW50Lm9wdGlvbnMucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLlB1c2gpIHtcbiAgICAgIHRoaXMuX3B1c2ggPSBuZXcgY2xpZW50Lm9wdGlvbnMucGx1Z2lucy5QdXNoLlB1c2hDaGFubmVsKHRoaXMpO1xuICAgIH1cbiAgICBpZiAoY2xpZW50Ll9Bbm5vdGF0aW9ucykge1xuICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBuZXcgY2xpZW50Ll9Bbm5vdGF0aW9ucy5SZXN0QW5ub3RhdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGdldCBhbm5vdGF0aW9ucygpIHtcbiAgICBpZiAoIXRoaXMuX2Fubm90YXRpb25zKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIkFubm90YXRpb25zXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYW5ub3RhdGlvbnM7XG4gIH1cbiAgZ2V0IHB1c2goKSB7XG4gICAgaWYgKCF0aGlzLl9wdXNoKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIlB1c2hcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wdXNoO1xuICB9XG4gIGdldCBsb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlcjtcbiAgfVxuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIHRoaXMuY2hhbm5lbE9wdGlvbnMgPSBub3JtYWxpc2VDaGFubmVsT3B0aW9ucygoX2EyID0gdGhpcy5jbGllbnQuX0NyeXB0bykgIT0gbnVsbCA/IF9hMiA6IG51bGwsIHRoaXMubG9nZ2VyLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBoaXN0b3J5KHBhcmFtcykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlc3RDaGFubmVsLmhpc3RvcnkoKVwiLCBcImNoYW5uZWwgPSBcIiArIHRoaXMubmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLmhpc3RvcnkodGhpcywgcGFyYW1zKTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF0sIHNlY29uZCA9IGFyZ3NbMV07XG4gICAgbGV0IG1lc3NhZ2VzO1xuICAgIGxldCBwYXJhbXM7XG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJzdHJpbmdcIiB8fCBmaXJzdCA9PT0gbnVsbCkge1xuICAgICAgbWVzc2FnZXMgPSBbbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoeyBuYW1lOiBmaXJzdCwgZGF0YTogc2Vjb25kIH0pXTtcbiAgICAgIHBhcmFtcyA9IGFyZ3NbMl07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChmaXJzdCkpIHtcbiAgICAgIG1lc3NhZ2VzID0gW21lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKGZpcnN0KV07XG4gICAgICBwYXJhbXMgPSBhcmdzWzFdO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaXJzdCkpIHtcbiAgICAgIG1lc3NhZ2VzID0gbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXNBcnJheShmaXJzdCk7XG4gICAgICBwYXJhbXMgPSBhcmdzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBcIlRoZSBzaW5nbGUtYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoKCkgZXhwZWN0cyBhIG1lc3NhZ2Ugb2JqZWN0IG9yIGFuIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0c1wiLFxuICAgICAgICA0MDAxMyxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgcGFyYW1zID0ge307XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50LCBvcHRpb25zID0gY2xpZW50Lm9wdGlvbnMsIGZvcm1hdCA9IG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nID0gY2xpZW50Lm9wdGlvbnMuaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyAmJiBhbGxFbXB0eUlkcyhtZXNzYWdlcykpIHtcbiAgICAgIGNvbnN0IG1zZ0lkQmFzZSA9IGF3YWl0IHJhbmRvbVN0cmluZyhNU0dfSURfRU5UUk9QWV9CWVRFUyk7XG4gICAgICBtZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uKG1lc3NhZ2UsIGluZGV4KSB7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSBtc2dJZEJhc2UgKyBcIjpcIiArIGluZGV4LnRvU3RyaW5nKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgd2lyZU1lc3NhZ2VzID0gYXdhaXQgZW5jb2RlQXJyYXkobWVzc2FnZXMsIHRoaXMuY2hhbm5lbE9wdGlvbnMpO1xuICAgIGNvbnN0IHNpemUgPSBnZXRNZXNzYWdlc1NpemUod2lyZU1lc3NhZ2VzKSwgbWF4TWVzc2FnZVNpemUgPSBvcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuICAgIGlmIChzaXplID4gbWF4TWVzc2FnZVNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiTWF4aW11bSBzaXplIG9mIG1lc3NhZ2VzIHRoYXQgY2FuIGJlIHB1Ymxpc2hlZCBhdCBvbmNlIGV4Y2VlZGVkICggd2FzIFwiICsgc2l6ZSArIFwiIGJ5dGVzOyBsaW1pdCBpcyBcIiArIG1heE1lc3NhZ2VTaXplICsgXCIgYnl0ZXMpXCIsXG4gICAgICAgIDQwMDA5LFxuICAgICAgICA0MDBcbiAgICAgICk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuX3B1Ymxpc2goc2VyaWFsaXplKHdpcmVNZXNzYWdlcywgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpLCBoZWFkZXJzLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIF9wdWJsaXNoKHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMpIHtcbiAgICBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QoXG4gICAgICB0aGlzLmNsaWVudCxcbiAgICAgIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLmJhc2VQYXRoKHRoaXMpICsgXCIvbWVzc2FnZXNcIixcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuICBhc3luYyBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLnN0YXR1cyh0aGlzKTtcbiAgfVxufTtcbnZhciByZXN0Y2hhbm5lbF9kZWZhdWx0ID0gUmVzdENoYW5uZWw7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL3N0YXRzLnRzXG52YXIgU3RhdHMgPSBjbGFzcyBfU3RhdHMge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcbiAgICB0aGlzLmVudHJpZXMgPSB2YWx1ZXMgJiYgdmFsdWVzLmVudHJpZXMgfHwgdm9pZCAwO1xuICAgIHRoaXMuc2NoZW1hID0gdmFsdWVzICYmIHZhbHVlcy5zY2hlbWEgfHwgdm9pZCAwO1xuICAgIHRoaXMuYXBwSWQgPSB2YWx1ZXMgJiYgdmFsdWVzLmFwcElkIHx8IHZvaWQgMDtcbiAgICB0aGlzLmluUHJvZ3Jlc3MgPSB2YWx1ZXMgJiYgdmFsdWVzLmluUHJvZ3Jlc3MgfHwgdm9pZCAwO1xuICAgIHRoaXMudW5pdCA9IHZhbHVlcyAmJiB2YWx1ZXMudW5pdCB8fCB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcnZhbElkID0gdmFsdWVzICYmIHZhbHVlcy5pbnRlcnZhbElkIHx8IHZvaWQgMDtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3IF9TdGF0cyh2YWx1ZXMpO1xuICB9XG59O1xudmFyIHN0YXRzX2RlZmF1bHQgPSBTdGF0cztcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3RjaGFubmVsbWl4aW4udHNcbnZhciBSZXN0Q2hhbm5lbE1peGluID0gY2xhc3Mge1xuICBzdGF0aWMgYmFzZVBhdGgoY2hhbm5lbCkge1xuICAgIHJldHVybiBcIi9jaGFubmVscy9cIiArIGVuY29kZVVSSUNvbXBvbmVudChjaGFubmVsLm5hbWUpO1xuICB9XG4gIHN0YXRpYyBoaXN0b3J5KGNoYW5uZWwsIHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IGNoYW5uZWwuY2xpZW50LCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IGNoYW5uZWwuY2xpZW50Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHZvaWQgMCA6IGZvcm1hdCwgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIG1peGluKGhlYWRlcnMsIGNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIHJldHVybiBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfZGVmYXVsdChjbGllbnQsIHRoaXMuYmFzZVBhdGgoY2hhbm5lbCkgKyBcIi9tZXNzYWdlc1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgYXN5bmMgZnVuY3Rpb24oYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICBjb25zdCBkZWNvZGVkID0gdW5wYWNrZWQgPyBib2R5IDogZGVjb2RlQm9keShib2R5LCBjbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgICByZXR1cm4gX2Zyb21FbmNvZGVkQXJyYXkyKGRlY29kZWQsIGNoYW5uZWwpO1xuICAgIH0pLmdldChwYXJhbXMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBzdGF0dXMoY2hhbm5lbCkge1xuICAgIGNvbnN0IGZvcm1hdCA9IGNoYW5uZWwuY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLztcbiAgICBjb25zdCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2hhbm5lbC5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldChcbiAgICAgIGNoYW5uZWwuY2xpZW50LFxuICAgICAgdGhpcy5iYXNlUGF0aChjaGFubmVsKSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICB7fSxcbiAgICAgIGZvcm1hdCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5ib2R5O1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzdHByZXNlbmNlbWl4aW4udHNcbnZhciBSZXN0UHJlc2VuY2VNaXhpbiA9IGNsYXNzIHtcbiAgc3RhdGljIGJhc2VQYXRoKHByZXNlbmNlKSB7XG4gICAgcmV0dXJuIFJlc3RDaGFubmVsTWl4aW4uYmFzZVBhdGgocHJlc2VuY2UuY2hhbm5lbCkgKyBcIi9wcmVzZW5jZVwiO1xuICB9XG4gIHN0YXRpYyBhc3luYyBoaXN0b3J5KHByZXNlbmNlLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSBwcmVzZW5jZS5jaGFubmVsLmNsaWVudCwgZm9ybWF0ID0gY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgZW52ZWxvcGUgPSBwcmVzZW5jZS5jaGFubmVsLmNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoXG4gICAgICBjbGllbnQsXG4gICAgICB0aGlzLmJhc2VQYXRoKHByZXNlbmNlKSArIFwiL2hpc3RvcnlcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBlbnZlbG9wZSxcbiAgICAgIGFzeW5jIChib2R5LCBoZWFkZXJzMiwgdW5wYWNrZWQpID0+IHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IHVucGFja2VkID8gYm9keSA6IGRlY29kZUJvZHkoYm9keSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgICAgICByZXR1cm4gX2Zyb21FbmNvZGVkQXJyYXkoZGVjb2RlZCwgcHJlc2VuY2UuY2hhbm5lbCk7XG4gICAgICB9XG4gICAgKS5nZXQocGFyYW1zKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3Jlc3QudHNcbnZhciBSZXN0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNoYW5uZWxNaXhpbiA9IFJlc3RDaGFubmVsTWl4aW47XG4gICAgdGhpcy5wcmVzZW5jZU1peGluID0gUmVzdFByZXNlbmNlTWl4aW47XG4gICAgLy8gZXhwb3NlZCBmb3IgcGx1Z2lucyBidXQgc2hvdWxkbid0IGJlIGJ1bmRsZWQgd2l0aCBtaW5pbWFsIHJlYWx0aW1lXG4gICAgdGhpcy5SZXNvdXJjZSA9IHJlc291cmNlX2RlZmF1bHQ7XG4gICAgdGhpcy5EZXZpY2VEZXRhaWxzID0gZGV2aWNlZGV0YWlsc19kZWZhdWx0O1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHModGhpcy5jbGllbnQpO1xuICAgIHRoaXMucHVzaCA9IG5ldyBwdXNoX2RlZmF1bHQodGhpcy5jbGllbnQpO1xuICB9XG4gIGFzeW5jIHN0YXRzKHBhcmFtcykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMpLCBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0O1xuICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KHRoaXMuY2xpZW50LCBcIi9zdGF0c1wiLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICBjb25zdCBzdGF0c1ZhbHVlcyA9IHVucGFja2VkID8gYm9keSA6IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRzVmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdGF0c1ZhbHVlc1tpXSA9IHN0YXRzX2RlZmF1bHQuZnJvbVZhbHVlcyhzdGF0c1ZhbHVlc1tpXSk7XG4gICAgICByZXR1cm4gc3RhdHNWYWx1ZXM7XG4gICAgfSkuZ2V0KHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgdGltZShwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0R2V0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zKTtcbiAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgbWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCB0aW1lVXJpID0gKGhvc3QpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudC5iYXNlVXJpKGhvc3QpICsgXCIvdGltZVwiO1xuICAgIH07XG4gICAgbGV0IHsgZXJyb3IsIGJvZHksIHVucGFja2VkIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5odHRwLmRvKFxuICAgICAgSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsXG4gICAgICB0aW1lVXJpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG51bGwsXG4gICAgICBwYXJhbXNcbiAgICApO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmICghdW5wYWNrZWQpXG4gICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICBjb25zdCB0aW1lID0gYm9keVswXTtcbiAgICBpZiAoIXRpbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJJbnRlcm5hbCBlcnJvciAodW5leHBlY3RlZCByZXN1bHQgdHlwZSBmcm9tIEdFVCAvdGltZSlcIiwgNWU0LCA1MDApO1xuICAgIH1cbiAgICB0aGlzLmNsaWVudC5zZXJ2ZXJUaW1lT2Zmc2V0ID0gdGltZSAtIERhdGUubm93KCk7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChtZXRob2QsIHBhdGgsIHZlcnNpb24yLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IFtlbmNvZGVyLCBkZWNvZGVyLCBmb3JtYXRdID0gKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sKSB7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnQuX01zZ1BhY2spIHtcbiAgICAgICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIk1zZ1BhY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0aGlzLmNsaWVudC5fTXNnUGFjay5lbmNvZGUsIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLmRlY29kZSwgXCJtc2dwYWNrXCIgLyogbXNncGFjayAqL107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW0pTT04uc3RyaW5naWZ5LCBKU09OLnBhcnNlLCBcImpzb25cIiAvKiBqc29uICovXTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIGNvbnN0IGVudmVsb3BlID0gdGhpcy5jbGllbnQuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdm9pZCAwIDogZm9ybWF0O1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb25zdCBfbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaGVhZGVycyA9IF9tZXRob2QgPT0gXCJnZXRcIiA/IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdEdldEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQsIHByb3RvY29sVmVyc2lvbjogdmVyc2lvbjIgfSkgOiBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCwgcHJvdG9jb2xWZXJzaW9uOiB2ZXJzaW9uMiB9KTtcbiAgICBpZiAodHlwZW9mIGJvZHkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJvZHkgPSAoX2EyID0gZW5jb2Rlcihib2R5KSkgIT0gbnVsbCA/IF9hMiA6IG51bGw7XG4gICAgfVxuICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGN1c3RvbUhlYWRlcnMpIHtcbiAgICAgIG1peGluKGhlYWRlcnMsIGN1c3RvbUhlYWRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBwYWdpbmF0ZWRSZXNvdXJjZSA9IG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV9kZWZhdWx0KFxuICAgICAgdGhpcy5jbGllbnQsXG4gICAgICBwYXRoLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGVudmVsb3BlLFxuICAgICAgYXN5bmMgZnVuY3Rpb24ocmVzYm9keSwgaGVhZGVyczIsIHVucGFja2VkKSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVBcnJheSh1bnBhY2tlZCA/IHJlc2JvZHkgOiBkZWNvZGVyKHJlc2JvZHkpKTtcbiAgICAgIH0sXG4gICAgICAvKiB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2U6ICovXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBpZiAoIVBsYXRmb3JtLkh0dHAubWV0aG9kcy5pbmNsdWRlcyhfbWV0aG9kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuc3VwcG9ydGVkIG1ldGhvZCBcIiArIF9tZXRob2QsIDQwNTAwLCA0MDUpO1xuICAgIH1cbiAgICBpZiAoUGxhdGZvcm0uSHR0cC5tZXRob2RzV2l0aEJvZHkuaW5jbHVkZXMoX21ldGhvZCkpIHtcbiAgICAgIHJldHVybiBwYWdpbmF0ZWRSZXNvdXJjZVtfbWV0aG9kXShwYXJhbXMsIGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFnaW5hdGVkUmVzb3VyY2VbX21ldGhvZF0ocGFyYW1zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYmF0Y2hQdWJsaXNoKHNwZWNPclNwZWNzKSB7XG4gICAgbGV0IHJlcXVlc3RCb2R5RFRPO1xuICAgIGxldCBzaW5nbGVTcGVjTW9kZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzcGVjT3JTcGVjcykpIHtcbiAgICAgIHJlcXVlc3RCb2R5RFRPID0gc3BlY09yU3BlY3M7XG4gICAgICBzaW5nbGVTcGVjTW9kZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0Qm9keURUTyA9IFtzcGVjT3JTcGVjc107XG4gICAgICBzaW5nbGVTcGVjTW9kZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBcIm1zZ3BhY2tcIiAvKiBtc2dwYWNrICovIDogXCJqc29uXCIgLyoganNvbiAqLywgaGVhZGVycyA9IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pO1xuICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICBtaXhpbihoZWFkZXJzLCB0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gZW5jb2RlQm9keShyZXF1ZXN0Qm9keURUTywgdGhpcy5jbGllbnQuX01zZ1BhY2ssIGZvcm1hdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LnBvc3QodGhpcy5jbGllbnQsIFwiL21lc3NhZ2VzXCIsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCB7fSwgbnVsbCwgdHJ1ZSk7XG4gICAgY29uc3QgYmF0Y2hSZXN1bHRzID0gcmVzcG9uc2UudW5wYWNrZWQgPyByZXNwb25zZS5ib2R5IDogZGVjb2RlQm9keShyZXNwb25zZS5ib2R5LCB0aGlzLmNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBpZiAoc2luZ2xlU3BlY01vZGUpIHtcbiAgICAgIHJldHVybiBiYXRjaFJlc3VsdHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiYXRjaFJlc3VsdHM7XG4gICAgfVxuICB9XG4gIGFzeW5jIGJhdGNoUHJlc2VuY2UoY2hhbm5lbHMpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gXCJtc2dwYWNrXCIgLyogbXNncGFjayAqLyA6IFwianNvblwiIC8qIGpzb24gKi8sIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgbWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCBjaGFubmVsc1BhcmFtID0gY2hhbm5lbHMuam9pbihcIixcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZV9kZWZhdWx0LmdldCh0aGlzLmNsaWVudCwgXCIvcHJlc2VuY2VcIiwgaGVhZGVycywgeyBjaGFubmVsczogY2hhbm5lbHNQYXJhbSB9LCBudWxsLCB0cnVlKTtcbiAgICByZXR1cm4gcmVzcG9uc2UudW5wYWNrZWQgPyByZXNwb25zZS5ib2R5IDogZGVjb2RlQm9keShyZXNwb25zZS5ib2R5LCB0aGlzLmNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgfVxuICBhc3luYyByZXZva2VUb2tlbnMoc3BlY2lmaWVycywgb3B0aW9ucykge1xuICAgIGlmICh1c2VUb2tlbkF1dGgodGhpcy5jbGllbnQub3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJDYW5ub3QgcmV2b2tlIHRva2VucyB3aGVuIHVzaW5nIHRva2VuIGF1dGhcIiwgNDAxNjIsIDQwMSk7XG4gICAgfVxuICAgIGNvbnN0IGtleU5hbWUgPSB0aGlzLmNsaWVudC5vcHRpb25zLmtleU5hbWU7XG4gICAgbGV0IHJlc29sdmVkT3B0aW9ucyA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keURUTyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHRhcmdldHM6IHNwZWNpZmllcnMubWFwKChzcGVjaWZpZXIpID0+IGAke3NwZWNpZmllci50eXBlfToke3NwZWNpZmllci52YWx1ZX1gKVxuICAgIH0sIHJlc29sdmVkT3B0aW9ucyk7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5jbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucywgeyBmb3JtYXQgfSk7XG4gICAgaWYgKHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgIG1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSBlbmNvZGVCb2R5KHJlcXVlc3RCb2R5RFRPLCB0aGlzLmNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdChcbiAgICAgIHRoaXMuY2xpZW50LFxuICAgICAgYC9rZXlzLyR7a2V5TmFtZX0vcmV2b2tlVG9rZW5zYCxcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHt9LFxuICAgICAgbnVsbCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS51bnBhY2tlZCA/IHJlc3BvbnNlLmJvZHkgOiBkZWNvZGVCb2R5KHJlc3BvbnNlLmJvZHksIHRoaXMuY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICB9XG59O1xudmFyIENoYW5uZWxzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLmFsbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGdldChuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgbGV0IGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIHRoaXMuYWxsW25hbWVdID0gY2hhbm5lbCA9IG5ldyByZXN0Y2hhbm5lbF9kZWZhdWx0KHRoaXMuY2xpZW50LCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsT3B0aW9ucykge1xuICAgICAgY2hhbm5lbC5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWw7XG4gIH1cbiAgLyogSW5jbHVkZWQgdG8gc3VwcG9ydCBjZXJ0YWluIG5pY2hlIHVzZS1jYXNlczsgbW9zdCB1c2VycyBzaG91bGQgaWdub3JlIHRoaXMuXG4gICAqIFBsZWFzZSBkbyBub3QgdXNlIHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nICovXG4gIHJlbGVhc2UobmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmFsbFtTdHJpbmcobmFtZSldO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvYmFzZXJlc3QudHNcbnZhciBCYXNlUmVzdCA9IGNsYXNzIGV4dGVuZHMgYmFzZWNsaWVudF9kZWZhdWx0IHtcbiAgLypcbiAgICogVGhlIHB1YmxpYyB0eXBpbmdzIGRlY2xhcmUgdGhhdCB0aGlzIG9ubHkgYWNjZXB0cyBhbiBvYmplY3QsIGJ1dCBzaW5jZSB3ZSB3YW50IHRvIGVtaXQgYSBnb29kIGVycm9yIG1lc3NhZ2UgaW4gdGhlIGNhc2Ugd2hlcmUgYSBub24tVHlwZVNjcmlwdCB1c2VyIGRvZXMgb25lIG9mIHRoZXNlIHRoaW5nczpcbiAgICpcbiAgICogMS4gcGFzc2VzIGEgc3RyaW5nICh3aGljaCBpcyBxdWl0ZSBsaWtlbHkgaWYgdGhleeKAmXJlIGUuZy4gbWlncmF0aW5nIGZyb20gdGhlIGRlZmF1bHQgdmFyaWFudCB0byB0aGUgbW9kdWxhciB2YXJpYW50KVxuICAgKiAyLiBwYXNzZXMgbm8gYXJndW1lbnQgYXQgYWxsXG4gICAqXG4gICAqIHRlbGwgdGhlIGNvbXBpbGVyIHRoYXQgdGhlc2UgY2FzZXMgYXJlIHBvc3NpYmxlIHNvIHRoYXQgaXQgZm9yY2VzIHVzIHRvIGhhbmRsZSB0aGVtLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKGRlZmF1bHRzX2RlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zLCBmYWxzZSwgXCJCYXNlUmVzdFwiLCBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCB7IFJlc3QgfSkpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvbW9kdWxhcnBsdWdpbnMudHNcbnZhciBhbGxDb21tb25Nb2R1bGFyUGx1Z2lucyA9IHsgUmVzdCB9O1xuXG4vLyBzcmMvY29tbW9uL2xpYi90eXBlcy9kZWZhdWx0bWVzc2FnZS50c1xudmFyIERlZmF1bHRNZXNzYWdlID0gY2xhc3MgZXh0ZW5kcyBtZXNzYWdlX2RlZmF1bHQge1xuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWQoZW5jb2RlZCwgaW5wdXRPcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkMihsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBQbGF0Zm9ybS5DcnlwdG8sIGVuY29kZWQsIGlucHV0T3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkQXJyYXkoZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkQXJyYXkyKGxvZ2dlcl9kZWZhdWx0LmRlZmF1bHRMb2dnZXIsIFBsYXRmb3JtLkNyeXB0bywgZW5jb2RlZEFycmF5LCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXModmFsdWVzKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvZGVmYXVsdHByZXNlbmNlbWVzc2FnZS50c1xudmFyIERlZmF1bHRQcmVzZW5jZU1lc3NhZ2UgPSBjbGFzcyBleHRlbmRzIHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0IHtcbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkKGVuY29kZWQsIGlucHV0T3B0aW9ucykge1xuICAgIHJldHVybiBmcm9tRW5jb2RlZChsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBQbGF0Zm9ybS5DcnlwdG8sIGVuY29kZWQsIGlucHV0T3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkQXJyYXkoZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb21FbmNvZGVkQXJyYXkobG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgUGxhdGZvcm0uQ3J5cHRvLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiBwcmVzZW5jZW1lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKHZhbHVlcyk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL2Fubm90YXRpb24udHNcbnZhciBhY3Rpb25zNCA9IFtcImFubm90YXRpb24uY3JlYXRlXCIsIFwiYW5ub3RhdGlvbi5kZWxldGVcIl07XG5hc3luYyBmdW5jdGlvbiBmcm9tRW5jb2RlZDMobG9nZ2VyLCBlbmNvZGVkLCBvcHRpb25zKSB7XG4gIGNvbnN0IHdhID0gV2lyZUFubm90YXRpb24uZnJvbVZhbHVlcyhlbmNvZGVkKTtcbiAgcmV0dXJuIHdhLmRlY29kZShvcHRpb25zIHx8IHt9LCBsb2dnZXIpO1xufVxuYXN5bmMgZnVuY3Rpb24gZnJvbUVuY29kZWRBcnJheTMobG9nZ2VyLCBlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIGZyb21FbmNvZGVkMyhsb2dnZXIsIGVuY29kZWQsIG9wdGlvbnMpO1xuICAgIH0pXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBfZnJvbUVuY29kZWQzKGVuY29kZWQsIGNoYW5uZWwpIHtcbiAgcmV0dXJuIFdpcmVBbm5vdGF0aW9uLmZyb21WYWx1ZXMoZW5jb2RlZCkuZGVjb2RlKGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMsIGNoYW5uZWwubG9nZ2VyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tRW5jb2RlZEFycmF5MyhlbmNvZGVkQXJyYXksIGNoYW5uZWwpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZDMoZW5jb2RlZCwgY2hhbm5lbCk7XG4gICAgfSlcbiAgKTtcbn1cbnZhciBBbm5vdGF0aW9uID0gY2xhc3MgX0Fubm90YXRpb24gZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIGFzeW5jIGVuY29kZSgpIHtcbiAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKG5ldyBXaXJlQW5ub3RhdGlvbigpLCB0aGlzLCB7XG4gICAgICBhY3Rpb246IGFjdGlvbnM0LmluZGV4T2YodGhpcy5hY3Rpb24gfHwgXCJhbm5vdGF0aW9uLmNyZWF0ZVwiKVxuICAgIH0pO1xuICAgIHJldHVybiBlbmNvZGUocmVzLCB7fSk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IF9Bbm5vdGF0aW9uKCksIHZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCgodikgPT4gX0Fubm90YXRpb24uZnJvbVZhbHVlcyh2KSk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHN0ck1zZyh0aGlzLCBcIkFubm90YXRpb25cIik7XG4gIH1cbn07XG52YXIgV2lyZUFubm90YXRpb24gPSBjbGFzcyBfV2lyZUFubm90YXRpb24gZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIHRvSlNPTiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHdpcmVUb0pTT04uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgX1dpcmVBbm5vdGF0aW9uKCksIHZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCgodikgPT4gX1dpcmVBbm5vdGF0aW9uLmZyb21WYWx1ZXModikpO1xuICB9XG4gIGFzeW5jIGRlY29kZShjaGFubmVsT3B0aW9ucywgbG9nZ2VyKSB7XG4gICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbihuZXcgQW5ub3RhdGlvbigpLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzKSwge1xuICAgICAgYWN0aW9uOiBhY3Rpb25zNFt0aGlzLmFjdGlvbl1cbiAgICB9KSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGRlY29kZShyZXMsIGNoYW5uZWxPcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiV2lyZUFubm90YXRpb24uZGVjb2RlKClcIiwgaW5zcGVjdEVycm9yKGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc3RyTXNnKHRoaXMsIFwiV2lyZUFubm90YXRpb25cIik7XG4gIH1cbn07XG52YXIgYW5ub3RhdGlvbl9kZWZhdWx0ID0gQW5ub3RhdGlvbjtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHlwZXMvZGVmYXVsdGFubm90YXRpb24udHNcbnZhciBEZWZhdWx0QW5ub3RhdGlvbiA9IGNsYXNzIGV4dGVuZHMgYW5ub3RhdGlvbl9kZWZhdWx0IHtcbiAgc3RhdGljIGFzeW5jIGZyb21FbmNvZGVkKGVuY29kZWQsIGlucHV0T3B0aW9ucykge1xuICAgIHJldHVybiBmcm9tRW5jb2RlZDMobG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgZW5jb2RlZCwgaW5wdXRPcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUVuY29kZWRBcnJheShlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnJvbUVuY29kZWRBcnJheTMobG9nZ2VyX2RlZmF1bHQuZGVmYXVsdExvZ2dlciwgZW5jb2RlZEFycmF5LCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gYW5ub3RhdGlvbl9kZWZhdWx0LmZyb21WYWx1ZXModmFsdWVzKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdXRpbC9ldmVudGVtaXR0ZXIudHNcbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsb2dnZXIsIGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICBsaXN0ZW5lci5hcHBseShldmVudFRoaXMsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgbG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgXCJFdmVudEVtaXR0ZXIuZW1pdCgpXCIsXG4gICAgICBcIlVuZXhwZWN0ZWQgbGlzdGVuZXIgZXhjZXB0aW9uOiBcIiArIGUgKyBcIjsgc3RhY2sgPSBcIiArIChlICYmIGUuc3RhY2spXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodGFyZ2V0TGlzdGVuZXJzLCBsaXN0ZW5lciwgZXZlbnRGaWx0ZXIpIHtcbiAgbGV0IGxpc3RlbmVycztcbiAgbGV0IGluZGV4O1xuICBsZXQgZXZlbnROYW1lO1xuICBmb3IgKGxldCB0YXJnZXRMaXN0ZW5lcnNJbmRleCA9IDA7IHRhcmdldExpc3RlbmVyc0luZGV4IDwgdGFyZ2V0TGlzdGVuZXJzLmxlbmd0aDsgdGFyZ2V0TGlzdGVuZXJzSW5kZXgrKykge1xuICAgIGxpc3RlbmVycyA9IHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF07XG4gICAgaWYgKGV2ZW50RmlsdGVyKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbZXZlbnRGaWx0ZXJdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShsaXN0ZW5lcnMpKSB7XG4gICAgICB3aGlsZSAoKGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpKSAhPT0gLTEpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnRGaWx0ZXIgJiYgbGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGFyZ2V0TGlzdGVuZXJzW3RhcmdldExpc3RlbmVyc0luZGV4XVtldmVudEZpbHRlcl07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0ZW5lcnMpKSB7XG4gICAgICBmb3IgKGV2ZW50TmFtZSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsaXN0ZW5lcnMsIGV2ZW50TmFtZSkgJiYgQXJyYXkuaXNBcnJheShsaXN0ZW5lcnNbZXZlbnROYW1lXSkpIHtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcihbbGlzdGVuZXJzXSwgbGlzdGVuZXIsIGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnZhciBFdmVudEVtaXR0ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuYW55ID0gW107XG4gICAgdGhpcy5ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFueU9uY2UgPSBbXTtcbiAgICB0aGlzLmV2ZW50c09uY2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBvbiguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGFyZ3NbMF07XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5hbnkucHVzaChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudExpc3RlbmVyLm9uKCk6IEludmFsaWQgYXJndW1lbnRzOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBbZXZlbnQsIGxpc3RlbmVyXSA9IGFyZ3M7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRMaXN0ZW5lci5vbigpOiBJbnZhbGlkIGFyZ3VtZW50czogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOaWwoZXZlbnQpKSB7XG4gICAgICAgIHRoaXMuYW55LnB1c2gobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBldmVudC5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICB0aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudExpc3RlbmVyLm9uKCk6IEludmFsaWQgYXJndW1lbnRzOiBcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c1tldmVudF0gfHwgKHRoaXMuZXZlbnRzW2V2ZW50XSA9IFtdKTtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvZmYoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PSAwIHx8IGlzTmlsKGFyZ3NbMF0pICYmIGlzTmlsKGFyZ3NbMV0pKSB7XG4gICAgICB0aGlzLmFueSA9IFtdO1xuICAgICAgdGhpcy5ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuYW55T25jZSA9IFtdO1xuICAgICAgdGhpcy5ldmVudHNPbmNlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtmaXJzdEFyZywgc2Vjb25kQXJnXSA9IGFyZ3M7XG4gICAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgICBsZXQgZXZlbnQgPSBudWxsO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSB8fCAhc2Vjb25kQXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGZpcnN0QXJnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbGlzdGVuZXIgPSBmaXJzdEFyZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50ID0gZmlyc3RBcmc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kQXJnICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9mZigpOiBpbnZhbGlkIGFyZ3VtZW50czpcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICAgIFtldmVudCwgbGlzdGVuZXJdID0gW2ZpcnN0QXJnLCBzZWNvbmRBcmddO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXIgJiYgaXNOaWwoZXZlbnQpKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihbdGhpcy5hbnksIHRoaXMuZXZlbnRzLCB0aGlzLmFueU9uY2UsIHRoaXMuZXZlbnRzT25jZV0sIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBldmVudC5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBldmVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9mZigpOiBpbnZhbGlkIGFyZ3VtZW50czpcIiArIFBsYXRmb3JtLkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihbdGhpcy5ldmVudHMsIHRoaXMuZXZlbnRzT25jZV0sIGxpc3RlbmVyLCBldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tldmVudF07XG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciBhIGdpdmVuIGV2ZW50OyBleGNsdWRlcyBvbmNlIGV2ZW50c1xuICAgKiBAcGFyYW0gZXZlbnQgKG9wdGlvbmFsKSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQsIG9yIG5vbmUgZm9yICdhbnknXG4gICAqIEByZXR1cm4gYXJyYXkgb2YgZXZlbnRzLCBvciBudWxsIGlmIG5vbmVcbiAgICovXG4gIGxpc3RlbmVycyhldmVudCkge1xuICAgIGlmIChldmVudCkge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgaWYgKHRoaXMuZXZlbnRzT25jZVtldmVudF0pXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5ldmVudHNPbmNlW2V2ZW50XSk7XG4gICAgICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aCA/IGxpc3RlbmVycyA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFueS5sZW5ndGggPyB0aGlzLmFueSA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEVtaXQgYW4gZXZlbnRcbiAgICogQHBhcmFtIGV2ZW50IHRoZSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBhcmdzIHRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcbiAgICovXG4gIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBldmVudFRoaXMgPSB7IGV2ZW50IH07XG4gICAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gICAgaWYgKHRoaXMuYW55T25jZS5sZW5ndGgpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5hbnlPbmNlKTtcbiAgICAgIHRoaXMuYW55T25jZSA9IFtdO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbnkubGVuZ3RoKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuYW55KTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRzT25jZUxpc3RlbmVycyA9IHRoaXMuZXZlbnRzT25jZVtldmVudF07XG4gICAgaWYgKGV2ZW50c09uY2VMaXN0ZW5lcnMpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzT25jZUxpc3RlbmVycyk7XG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRzTGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdO1xuICAgIGlmIChldmVudHNMaXN0ZW5lcnMpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzTGlzdGVuZXJzKTtcbiAgICB9XG4gICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICBjYWxsTGlzdGVuZXIodGhpcy5sb2dnZXIsIGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG4gIG9uY2UoLi4uYXJncykge1xuICAgIGNvbnN0IGFyZ0NvdW50ID0gYXJncy5sZW5ndGg7XG4gICAgaWYgKGFyZ0NvdW50ID09PSAwIHx8IGFyZ0NvdW50ID09PSAxICYmIHR5cGVvZiBhcmdzWzBdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gYXJnc1swXTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzLm9uY2UoZXZlbnQsIHJlc29sdmUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IFtmaXJzdEFyZywgc2Vjb25kQXJnXSA9IGFyZ3M7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLmFueU9uY2UucHVzaChmaXJzdEFyZyk7XG4gICAgfSBlbHNlIGlmIChpc05pbChmaXJzdEFyZykpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kQXJnICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFueU9uY2UucHVzaChzZWNvbmRBcmcpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaXJzdEFyZykpIHtcbiAgICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICAgIGNvbnN0IGxpc3RlbmVyV3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBpbm5lckFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBmaXJzdEFyZy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgIHNlbGYyLm9mZihldmVudE5hbWUsIGxpc3RlbmVyV3JhcHBlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vjb25kQXJnLmFwcGx5KHRoaXMsIGlubmVyQXJncyk7XG4gICAgICB9O1xuICAgICAgZmlyc3RBcmcuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgc2VsZjIub24oZXZlbnROYW1lLCBsaXN0ZW5lcldyYXBwZXIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgZmlyc3RBcmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c09uY2VbZmlyc3RBcmddIHx8ICh0aGlzLmV2ZW50c09uY2VbZmlyc3RBcmddID0gW10pO1xuICAgICAgaWYgKHNlY29uZEFyZykge1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6XCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXJzLnB1c2goc2Vjb25kQXJnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIExpc3RlbiBmb3IgYSBzaW5nbGUgb2NjdXJyZW5jZSBvZiBhIHN0YXRlIGV2ZW50IGFuZCBmaXJlIGltbWVkaWF0ZWx5IGlmIGN1cnJlbnRTdGF0ZSBtYXRjaGVzIHRhcmdldFN0YXRlXG4gICAqIEBwYXJhbSB0YXJnZXRTdGF0ZSB0aGUgbmFtZSBvZiB0aGUgc3RhdGUgZXZlbnQgdG8gbGlzdGVuIHRvXG4gICAqIEBwYXJhbSBjdXJyZW50U3RhdGUgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyBvYmplY3RcbiAgICovXG4gIGFzeW5jIHdoZW5TdGF0ZSh0YXJnZXRTdGF0ZSwgY3VycmVudFN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXRTdGF0ZSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgY3VycmVudFN0YXRlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3aGVuU3RhdGUgcmVxdWlyZXMgYSB2YWxpZCBzdGF0ZSBTdHJpbmcgYXJndW1lbnRcIik7XG4gICAgfVxuICAgIGlmICh0YXJnZXRTdGF0ZSA9PT0gY3VycmVudFN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMub25jZSh0YXJnZXRTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xudmFyIGV2ZW50ZW1pdHRlcl9kZWZhdWx0ID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvcmVzdGFubm90YXRpb25zLnRzXG5mdW5jdGlvbiBzZXJpYWxGcm9tTXNnT3JTZXJpYWwobXNnT3JTZXJpYWwpIHtcbiAgbGV0IG1lc3NhZ2VTZXJpYWw7XG4gIHN3aXRjaCAodHlwZW9mIG1zZ09yU2VyaWFsKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgbWVzc2FnZVNlcmlhbCA9IG1zZ09yU2VyaWFsO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgbWVzc2FnZVNlcmlhbCA9IG1zZ09yU2VyaWFsLnNlcmlhbDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGlmICghbWVzc2FnZVNlcmlhbCB8fCB0eXBlb2YgbWVzc2FnZVNlcmlhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICBcIkZpcnN0IGFyZ3VtZW50IG9mIGFubm90YXRpb25zLnB1Ymxpc2goKSBtdXN0IGJlIGVpdGhlciBhIE1lc3NhZ2UgKG9yIGF0IGxlYXN0IGFuIG9iamVjdCB3aXRoIGEgc3RyaW5nIGBzZXJpYWxgIHByb3BlcnR5KSBvciBhIG1lc3NhZ2Ugc2VyaWFsIChzdHJpbmcpXCIsXG4gICAgICA0MDAwMyxcbiAgICAgIDQwMFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2VTZXJpYWw7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RWYWxpZGF0ZUFubm90YXRpb24obXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpIHtcbiAgY29uc3QgbWVzc2FnZVNlcmlhbCA9IHNlcmlhbEZyb21Nc2dPclNlcmlhbChtc2dPclNlcmlhbCk7XG4gIGlmICghYW5ub3RhdGlvblZhbHVlcyB8fCB0eXBlb2YgYW5ub3RhdGlvblZhbHVlcyAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICBcIlNlY29uZCBhcmd1bWVudCBvZiBhbm5vdGF0aW9ucy5wdWJsaXNoKCkgbXVzdCBiZSBhbiBvYmplY3QgKHRoZSBpbnRlbmRlZCBhbm5vdGF0aW9uIHRvIHB1Ymxpc2gpXCIsXG4gICAgICA0MDAwMyxcbiAgICAgIDQwMFxuICAgICk7XG4gIH1cbiAgY29uc3QgYW5ub3RhdGlvbiA9IGFubm90YXRpb25fZGVmYXVsdC5mcm9tVmFsdWVzKGFubm90YXRpb25WYWx1ZXMpO1xuICBhbm5vdGF0aW9uLm1lc3NhZ2VTZXJpYWwgPSBtZXNzYWdlU2VyaWFsO1xuICBpZiAoIWFubm90YXRpb24uYWN0aW9uKSB7XG4gICAgYW5ub3RhdGlvbi5hY3Rpb24gPSBcImFubm90YXRpb24uY3JlYXRlXCI7XG4gIH1cbiAgcmV0dXJuIGFubm90YXRpb247XG59XG5mdW5jdGlvbiBiYXNlUGF0aEZvclNlcmlhbChjaGFubmVsLCBzZXJpYWwpIHtcbiAgcmV0dXJuIGNoYW5uZWwuY2xpZW50LnJlc3QuY2hhbm5lbE1peGluLmJhc2VQYXRoKGNoYW5uZWwpICsgXCIvbWVzc2FnZXMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoc2VyaWFsKSArIFwiL2Fubm90YXRpb25zXCI7XG59XG52YXIgUmVzdEFubm90YXRpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsKSB7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgfVxuICBhc3luYyBwdWJsaXNoKG1zZ09yU2VyaWFsLCBhbm5vdGF0aW9uVmFsdWVzKSB7XG4gICAgY29uc3QgYW5ub3RhdGlvbiA9IGNvbnN0cnVjdFZhbGlkYXRlQW5ub3RhdGlvbihtc2dPclNlcmlhbCwgYW5ub3RhdGlvblZhbHVlcyk7XG4gICAgY29uc3Qgd2lyZUFubm90YXRpb24gPSBhd2FpdCBhbm5vdGF0aW9uLmVuY29kZSgpO1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2hhbm5lbC5jbGllbnQsIG9wdGlvbnMgPSBjbGllbnQub3B0aW9ucywgZm9ybWF0ID0gb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBoZWFkZXJzID0gZGVmYXVsdHNfZGVmYXVsdC5kZWZhdWx0UG9zdEhlYWRlcnMoY2xpZW50Lm9wdGlvbnMsIHsgZm9ybWF0IH0pLCBwYXJhbXMgPSB7fTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGVuY29kZUJvZHkoW3dpcmVBbm5vdGF0aW9uXSwgY2xpZW50Ll9Nc2dQYWNrLCBmb3JtYXQpO1xuICAgIGF3YWl0IHJlc291cmNlX2RlZmF1bHQucG9zdChcbiAgICAgIGNsaWVudCxcbiAgICAgIGJhc2VQYXRoRm9yU2VyaWFsKHRoaXMuY2hhbm5lbCwgYW5ub3RhdGlvbi5tZXNzYWdlU2VyaWFsKSxcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuICBhc3luYyBkZWxldGUobXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpIHtcbiAgICBhbm5vdGF0aW9uVmFsdWVzLmFjdGlvbiA9IFwiYW5ub3RhdGlvbi5kZWxldGVcIjtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKG1zZ09yU2VyaWFsLCBhbm5vdGF0aW9uVmFsdWVzKTtcbiAgfVxuICBhc3luYyBnZXQobXNnT3JTZXJpYWwsIHBhcmFtcykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2hhbm5lbC5jbGllbnQsIG1lc3NhZ2VTZXJpYWwgPSBzZXJpYWxGcm9tTXNnT3JTZXJpYWwobXNnT3JTZXJpYWwpLCBmb3JtYXQgPSBjbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovLCBlbnZlbG9wZSA9IGNsaWVudC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB2b2lkIDAgOiBmb3JtYXQsIGhlYWRlcnMgPSBkZWZhdWx0c19kZWZhdWx0LmRlZmF1bHRHZXRIZWFkZXJzKGNsaWVudC5vcHRpb25zLCB7IGZvcm1hdCB9KTtcbiAgICBtaXhpbihoZWFkZXJzLCBjbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICByZXR1cm4gbmV3IHBhZ2luYXRlZHJlc291cmNlX2RlZmF1bHQoXG4gICAgICBjbGllbnQsXG4gICAgICBiYXNlUGF0aEZvclNlcmlhbCh0aGlzLmNoYW5uZWwsIG1lc3NhZ2VTZXJpYWwpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGVudmVsb3BlLFxuICAgICAgYXN5bmMgKGJvZHksIF8sIHVucGFja2VkKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSB1bnBhY2tlZCA/IGJvZHkgOiBkZWNvZGVCb2R5KGJvZHksIGNsaWVudC5fTXNnUGFjaywgZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIF9mcm9tRW5jb2RlZEFycmF5MyhkZWNvZGVkLCB0aGlzLmNoYW5uZWwpO1xuICAgICAgfVxuICAgICkuZ2V0KHBhcmFtcyk7XG4gIH1cbn07XG52YXIgcmVzdGFubm90YXRpb25zX2RlZmF1bHQgPSBSZXN0QW5ub3RhdGlvbnM7XG5cbi8vIHNyYy9jb21tb24vbGliL3R5cGVzL3Byb3RvY29sbWVzc2FnZS50c1xudmFyIHNlcmlhbGl6ZTIgPSBlbmNvZGVCb2R5O1xuZnVuY3Rpb24gdG9TdHJpbmdBcnJheShhcnJheSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKGFycmF5KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0udG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIlsgXCIgKyByZXN1bHQuam9pbihcIiwgXCIpICsgXCIgXVwiO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCwgTXNnUGFjaywgcHJlc2VuY2VNZXNzYWdlUGx1Z2luLCBhbm5vdGF0aW9uc1BsdWdpbiwgZm9ybWF0KSB7XG4gIGNvbnN0IGRlc2VyaWFsaXplZCA9IGRlY29kZUJvZHkoc2VyaWFsaXplZCwgTXNnUGFjaywgZm9ybWF0KTtcbiAgcmV0dXJuIGZyb21EZXNlcmlhbGl6ZWQoZGVzZXJpYWxpemVkLCBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4sIGFubm90YXRpb25zUGx1Z2luKTtcbn1cbmZ1bmN0aW9uIGZyb21EZXNlcmlhbGl6ZWQoZGVzZXJpYWxpemVkLCBwcmVzZW5jZU1lc3NhZ2VQbHVnaW4sIGFubm90YXRpb25zUGx1Z2luKSB7XG4gIGxldCBlcnJvcjtcbiAgaWYgKGRlc2VyaWFsaXplZC5lcnJvcikge1xuICAgIGVycm9yID0gRXJyb3JJbmZvLmZyb21WYWx1ZXMoZGVzZXJpYWxpemVkLmVycm9yKTtcbiAgfVxuICBsZXQgbWVzc2FnZXM7XG4gIGlmIChkZXNlcmlhbGl6ZWQubWVzc2FnZXMpIHtcbiAgICBtZXNzYWdlcyA9IFdpcmVNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShkZXNlcmlhbGl6ZWQubWVzc2FnZXMpO1xuICB9XG4gIGxldCBwcmVzZW5jZTtcbiAgaWYgKHByZXNlbmNlTWVzc2FnZVBsdWdpbiAmJiBkZXNlcmlhbGl6ZWQucHJlc2VuY2UpIHtcbiAgICBwcmVzZW5jZSA9IHByZXNlbmNlTWVzc2FnZVBsdWdpbi5XaXJlUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShcbiAgICAgIGRlc2VyaWFsaXplZC5wcmVzZW5jZVxuICAgICk7XG4gIH1cbiAgbGV0IGFubm90YXRpb25zO1xuICBpZiAoYW5ub3RhdGlvbnNQbHVnaW4gJiYgZGVzZXJpYWxpemVkLmFubm90YXRpb25zKSB7XG4gICAgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9uc1BsdWdpbi5XaXJlQW5ub3RhdGlvbi5mcm9tVmFsdWVzQXJyYXkoXG4gICAgICBkZXNlcmlhbGl6ZWQuYW5ub3RhdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBQcm90b2NvbE1lc3NhZ2UoKSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVzZXJpYWxpemVkKSwgeyBwcmVzZW5jZSwgbWVzc2FnZXMsIGFubm90YXRpb25zLCBlcnJvciB9KSk7XG59XG5mdW5jdGlvbiBmcm9tRGVzZXJpYWxpemVkSW5jbHVkaW5nRGVwZW5kZW5jaWVzKGRlc2VyaWFsaXplZCkge1xuICByZXR1cm4gZnJvbURlc2VyaWFsaXplZChcbiAgICBkZXNlcmlhbGl6ZWQsXG4gICAgeyBQcmVzZW5jZU1lc3NhZ2U6IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LCBXaXJlUHJlc2VuY2VNZXNzYWdlIH0sXG4gICAgeyBBbm5vdGF0aW9uOiBhbm5vdGF0aW9uX2RlZmF1bHQsIFdpcmVBbm5vdGF0aW9uLCBSZWFsdGltZUFubm90YXRpb25zOiByZWFsdGltZWFubm90YXRpb25zX2RlZmF1bHQsIFJlc3RBbm5vdGF0aW9uczogcmVzdGFubm90YXRpb25zX2RlZmF1bHQgfVxuICApO1xufVxuZnVuY3Rpb24gZnJvbVZhbHVlcyh2YWx1ZXMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFByb3RvY29sTWVzc2FnZSgpLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KG1zZywgcHJlc2VuY2VNZXNzYWdlUGx1Z2luLCBhbm5vdGF0aW9uc1BsdWdpbikge1xuICBsZXQgcmVzdWx0ID0gXCJbUHJvdG9jb2xNZXNzYWdlXCI7XG4gIGlmIChtc2cuYWN0aW9uICE9PSB2b2lkIDApXG4gICAgcmVzdWx0ICs9IFwiOyBhY3Rpb249XCIgKyBBY3Rpb25OYW1lW21zZy5hY3Rpb25dIHx8IG1zZy5hY3Rpb247XG4gIGNvbnN0IHNpbXBsZUF0dHJpYnV0ZXMgPSBbXCJpZFwiLCBcImNoYW5uZWxcIiwgXCJjaGFubmVsU2VyaWFsXCIsIFwiY29ubmVjdGlvbklkXCIsIFwiY291bnRcIiwgXCJtc2dTZXJpYWxcIiwgXCJ0aW1lc3RhbXBcIl07XG4gIGxldCBhdHRyaWJ1dGU7XG4gIGZvciAobGV0IGF0dHJpYkluZGV4ID0gMDsgYXR0cmliSW5kZXggPCBzaW1wbGVBdHRyaWJ1dGVzLmxlbmd0aDsgYXR0cmliSW5kZXgrKykge1xuICAgIGF0dHJpYnV0ZSA9IHNpbXBsZUF0dHJpYnV0ZXNbYXR0cmliSW5kZXhdO1xuICAgIGlmIChtc2dbYXR0cmlidXRlXSAhPT0gdm9pZCAwKVxuICAgICAgcmVzdWx0ICs9IFwiOyBcIiArIGF0dHJpYnV0ZSArIFwiPVwiICsgbXNnW2F0dHJpYnV0ZV07XG4gIH1cbiAgaWYgKG1zZy5tZXNzYWdlcylcbiAgICByZXN1bHQgKz0gXCI7IG1lc3NhZ2VzPVwiICsgdG9TdHJpbmdBcnJheShXaXJlTWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkobXNnLm1lc3NhZ2VzKSk7XG4gIGlmIChtc2cucHJlc2VuY2UgJiYgcHJlc2VuY2VNZXNzYWdlUGx1Z2luKVxuICAgIHJlc3VsdCArPSBcIjsgcHJlc2VuY2U9XCIgKyB0b1N0cmluZ0FycmF5KHByZXNlbmNlTWVzc2FnZVBsdWdpbi5XaXJlUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXNBcnJheShtc2cucHJlc2VuY2UpKTtcbiAgaWYgKG1zZy5hbm5vdGF0aW9ucyAmJiBhbm5vdGF0aW9uc1BsdWdpbikge1xuICAgIHJlc3VsdCArPSBcIjsgYW5ub3RhdGlvbnM9XCIgKyB0b1N0cmluZ0FycmF5KGFubm90YXRpb25zUGx1Z2luLldpcmVBbm5vdGF0aW9uLmZyb21WYWx1ZXNBcnJheShtc2cuYW5ub3RhdGlvbnMpKTtcbiAgfVxuICBpZiAobXNnLmVycm9yKVxuICAgIHJlc3VsdCArPSBcIjsgZXJyb3I9XCIgKyBFcnJvckluZm8uZnJvbVZhbHVlcyhtc2cuZXJyb3IpLnRvU3RyaW5nKCk7XG4gIGlmIChtc2cuYXV0aCAmJiBtc2cuYXV0aC5hY2Nlc3NUb2tlbilcbiAgICByZXN1bHQgKz0gXCI7IHRva2VuPVwiICsgbXNnLmF1dGguYWNjZXNzVG9rZW47XG4gIGlmIChtc2cuZmxhZ3MpXG4gICAgcmVzdWx0ICs9IFwiOyBmbGFncz1cIiArIGZsYWdOYW1lcy5maWx0ZXIobXNnLmhhc0ZsYWcpLmpvaW4oXCIsXCIpO1xuICBpZiAobXNnLnBhcmFtcykge1xuICAgIGxldCBzdHJpbmdpZmllZFBhcmFtcyA9IFwiXCI7XG4gICAgZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyhtc2cucGFyYW1zLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgICBpZiAoc3RyaW5naWZpZWRQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzdHJpbmdpZmllZFBhcmFtcyArPSBcIjsgXCI7XG4gICAgICB9XG4gICAgICBzdHJpbmdpZmllZFBhcmFtcyArPSBwcm9wICsgXCI9XCIgKyBtc2cucGFyYW1zW3Byb3BdO1xuICAgIH0pO1xuICAgIGlmIChzdHJpbmdpZmllZFBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQgKz0gXCI7IHBhcmFtcz1bXCIgKyBzdHJpbmdpZmllZFBhcmFtcyArIFwiXVwiO1xuICAgIH1cbiAgfVxuICByZXN1bHQgKz0gXCJdXCI7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgUHJvdG9jb2xNZXNzYWdlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmhhc0ZsYWcgPSAoZmxhZykgPT4ge1xuICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgZmxhZ3NbZmxhZ10pID4gMDtcbiAgICB9O1xuICB9XG4gIHNldEZsYWcoZmxhZykge1xuICAgIHJldHVybiB0aGlzLmZsYWdzID0gdGhpcy5mbGFncyB8IGZsYWdzW2ZsYWddO1xuICB9XG4gIGdldE1vZGUoKSB7XG4gICAgcmV0dXJuICh0aGlzLmZsYWdzIHx8IDApICYgZmxhZ3MuTU9ERV9BTEw7XG4gIH1cbiAgZW5jb2RlTW9kZXNUb0ZsYWdzKG1vZGVzKSB7XG4gICAgbW9kZXMuZm9yRWFjaCgobW9kZSkgPT4gdGhpcy5zZXRGbGFnKG1vZGUpKTtcbiAgfVxuICBkZWNvZGVNb2Rlc0Zyb21GbGFncygpIHtcbiAgICBjb25zdCBtb2RlcyA9IFtdO1xuICAgIGNoYW5uZWxNb2Rlcy5mb3JFYWNoKChtb2RlKSA9PiB7XG4gICAgICBpZiAodGhpcy5oYXNGbGFnKG1vZGUpKSB7XG4gICAgICAgIG1vZGVzLnB1c2gobW9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1vZGVzLmxlbmd0aCA+IDAgPyBtb2RlcyA6IHZvaWQgMDtcbiAgfVxufTtcbnZhciBwcm90b2NvbG1lc3NhZ2VfZGVmYXVsdCA9IFByb3RvY29sTWVzc2FnZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2NoYW5uZWxzdGF0ZWNoYW5nZS50c1xudmFyIENoYW5uZWxTdGF0ZUNoYW5nZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocHJldmlvdXMsIGN1cnJlbnQsIHJlc3VtZWQsIGhhc0JhY2tsb2csIHJlYXNvbikge1xuICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgIGlmIChjdXJyZW50ID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgIHRoaXMucmVzdW1lZCA9IHJlc3VtZWQ7XG4gICAgICB0aGlzLmhhc0JhY2tsb2cgPSBoYXNCYWNrbG9nO1xuICAgIH1cbiAgICBpZiAocmVhc29uKVxuICAgICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIH1cbn07XG52YXIgY2hhbm5lbHN0YXRlY2hhbmdlX2RlZmF1bHQgPSBDaGFubmVsU3RhdGVDaGFuZ2U7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZWFsdGltZWNoYW5uZWwudHNcbnZhciBub29wID0gZnVuY3Rpb24oKSB7XG59O1xuZnVuY3Rpb24gdmFsaWRhdGVDaGFubmVsT3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIFwicGFyYW1zXCIgaW4gb3B0aW9ucyAmJiAhaXNPYmplY3Qob3B0aW9ucy5wYXJhbXMpKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvckluZm8oXCJvcHRpb25zLnBhcmFtcyBtdXN0IGJlIGFuIG9iamVjdFwiLCA0ZTQsIDQwMCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgXCJtb2Rlc1wiIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5tb2RlcykpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3JJbmZvKFwib3B0aW9ucy5tb2RlcyBtdXN0IGJlIGFuIGFycmF5XCIsIDRlNCwgNDAwKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLm1vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50TW9kZSA9IG9wdGlvbnMubW9kZXNbaV07XG4gICAgICBpZiAoIWN1cnJlbnRNb2RlIHx8IHR5cGVvZiBjdXJyZW50TW9kZSAhPT0gXCJzdHJpbmdcIiB8fCAhY2hhbm5lbE1vZGVzLmluY2x1ZGVzKFN0cmluZy5wcm90b3R5cGUudG9VcHBlckNhc2UuY2FsbChjdXJyZW50TW9kZSkpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JJbmZvKFwiSW52YWxpZCBjaGFubmVsIG1vZGU6IFwiICsgY3VycmVudE1vZGUsIDRlNCwgNDAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnZhciBSZWFsdGltZUNoYW5uZWwgPSBjbGFzcyBfUmVhbHRpbWVDaGFubmVsIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBzdXBlcihjbGllbnQubG9nZ2VyKTtcbiAgICB0aGlzLl9hbm5vdGF0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5fbW9kZSA9IDA7XG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB0aGlzLmhpc3RvcnkgPSBhc3luYyBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlJlYWx0aW1lQ2hhbm5lbC5oaXN0b3J5KClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgICAgY29uc3QgcmVzdE1peGluID0gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW47XG4gICAgICBpZiAocGFyYW1zICYmIHBhcmFtcy51bnRpbEF0dGFjaCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIm9wdGlvbiB1bnRpbEF0dGFjaCByZXF1aXJlcyB0aGUgY2hhbm5lbCB0byBiZSBhdHRhY2hlZFwiLCA0ZTQsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICAgIFwidW50aWxBdHRhY2ggd2FzIHNwZWNpZmllZCBhbmQgY2hhbm5lbCBpcyBhdHRhY2hlZCwgYnV0IGF0dGFjaFNlcmlhbCBpcyBub3QgZGVmaW5lZFwiLFxuICAgICAgICAgICAgNGU0LFxuICAgICAgICAgICAgNDAwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgcGFyYW1zLnVudGlsQXR0YWNoO1xuICAgICAgICBwYXJhbXMuZnJvbV9zZXJpYWwgPSB0aGlzLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3RNaXhpbi5oaXN0b3J5KHRoaXMsIHBhcmFtcyk7XG4gICAgfTtcbiAgICB0aGlzLndoZW5TdGF0ZSA9IChzdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIGV2ZW50ZW1pdHRlcl9kZWZhdWx0LnByb3RvdHlwZS53aGVuU3RhdGUuY2FsbCh0aGlzLCBzdGF0ZSwgdGhpcy5zdGF0ZSk7XG4gICAgfTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJSZWFsdGltZUNoYW5uZWwoKVwiLCBcInN0YXJ0ZWQ7IG5hbWUgPSBcIiArIG5hbWUpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5jaGFubmVsT3B0aW9ucyA9IG5vcm1hbGlzZUNoYW5uZWxPcHRpb25zKChfYTIgPSBjbGllbnQuX0NyeXB0bykgIT0gbnVsbCA/IF9hMiA6IG51bGwsIHRoaXMubG9nZ2VyLCBvcHRpb25zKTtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLl9wcmVzZW5jZSA9IGNsaWVudC5fUmVhbHRpbWVQcmVzZW5jZSA/IG5ldyBjbGllbnQuX1JlYWx0aW1lUHJlc2VuY2UuUmVhbHRpbWVQcmVzZW5jZSh0aGlzKSA6IG51bGw7XG4gICAgaWYgKGNsaWVudC5fQW5ub3RhdGlvbnMpIHtcbiAgICAgIHRoaXMuX2Fubm90YXRpb25zID0gbmV3IGNsaWVudC5fQW5ub3RhdGlvbnMuUmVhbHRpbWVBbm5vdGF0aW9ucyh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IGNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgIHRoaXMuc3RhdGUgPSBcImluaXRpYWxpemVkXCI7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IGV2ZW50ZW1pdHRlcl9kZWZhdWx0KHRoaXMubG9nZ2VyKTtcbiAgICB0aGlzLnN5bmNDaGFubmVsU2VyaWFsID0gdm9pZCAwO1xuICAgIHRoaXMucHJvcGVydGllcyA9IHtcbiAgICAgIGF0dGFjaFNlcmlhbDogdm9pZCAwLFxuICAgICAgY2hhbm5lbFNlcmlhbDogdm9pZCAwXG4gICAgfTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5lcnJvclJlYXNvbiA9IG51bGw7XG4gICAgdGhpcy5fYXR0YWNoUmVzdW1lID0gZmFsc2U7XG4gICAgdGhpcy5fZGVjb2RpbmdDb250ZXh0ID0ge1xuICAgICAgY2hhbm5lbE9wdGlvbnM6IHRoaXMuY2hhbm5lbE9wdGlvbnMsXG4gICAgICBwbHVnaW5zOiBjbGllbnQub3B0aW9ucy5wbHVnaW5zIHx8IHt9LFxuICAgICAgYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ6IHZvaWQgMFxuICAgIH07XG4gICAgdGhpcy5fbGFzdFBheWxvYWQgPSB7XG4gICAgICBtZXNzYWdlSWQ6IG51bGwsXG4gICAgICBwcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsOiBudWxsLFxuICAgICAgZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzczogbnVsbFxuICAgIH07XG4gICAgdGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMgPSBuZXcgZXZlbnRlbWl0dGVyX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIGlmICgoX2IgPSBjbGllbnQub3B0aW9ucy5wbHVnaW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2IuUHVzaCkge1xuICAgICAgdGhpcy5fcHVzaCA9IG5ldyBjbGllbnQub3B0aW9ucy5wbHVnaW5zLlB1c2guUHVzaENoYW5uZWwodGhpcyk7XG4gICAgfVxuICB9XG4gIGdldCBwcmVzZW5jZSgpIHtcbiAgICBpZiAoIXRoaXMuX3ByZXNlbmNlKSB7XG4gICAgICB0aHJvd01pc3NpbmdQbHVnaW5FcnJvcihcIlJlYWx0aW1lUHJlc2VuY2VcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcmVzZW5jZTtcbiAgfVxuICBnZXQgYW5ub3RhdGlvbnMoKSB7XG4gICAgaWYgKCF0aGlzLl9hbm5vdGF0aW9ucykge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJBbm5vdGF0aW9uc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2Fubm90YXRpb25zO1xuICB9XG4gIGdldCBwdXNoKCkge1xuICAgIGlmICghdGhpcy5fcHVzaCkge1xuICAgICAgdGhyb3dNaXNzaW5nUGx1Z2luRXJyb3IoXCJQdXNoXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHVzaDtcbiAgfVxuICBpbnZhbGlkU3RhdGVFcnJvcigpIHtcbiAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcbiAgICAgIFwiQ2hhbm5lbCBvcGVyYXRpb24gZmFpbGVkIGFzIGNoYW5uZWwgc3RhdGUgaXMgXCIgKyB0aGlzLnN0YXRlLFxuICAgICAgOTAwMDEsXG4gICAgICA0MDAsXG4gICAgICB0aGlzLmVycm9yUmVhc29uIHx8IHZvaWQgMFxuICAgICk7XG4gIH1cbiAgc3RhdGljIHByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJncykge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuICBhc3luYyBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IHByZXZpb3VzQ2hhbm5lbE9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuICAgIGNvbnN0IGVyciA9IHZhbGlkYXRlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoKF9hMiA9IHRoaXMuY2xpZW50Ll9DcnlwdG8pICE9IG51bGwgPyBfYTIgOiBudWxsLCB0aGlzLmxvZ2dlciwgb3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuX2RlY29kaW5nQ29udGV4dClcbiAgICAgIHRoaXMuX2RlY29kaW5nQ29udGV4dC5jaGFubmVsT3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG4gICAgaWYgKHRoaXMuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKG9wdGlvbnMsIHByZXZpb3VzQ2hhbm5lbE9wdGlvbnMpKSB7XG4gICAgICB0aGlzLmF0dGFjaEltcGwoKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLm9uY2UoXG4gICAgICAgICAgW1wiYXR0YWNoZWRcIiwgXCJ1cGRhdGVcIiwgXCJkZXRhY2hlZFwiLCBcImZhaWxlZFwiXSxcbiAgICAgICAgICBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImF0dGFjaGVkXCI6XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlamVjdChzdGF0ZUNoYW5nZS5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMob3B0aW9ucywgcHJldk9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzLnN0YXRlID09PSBcImF0dGFjaGVkXCIgfHwgdGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hpbmdcIikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ZWRQYXJhbXMgPSBvbWl0QWdlbnQob3B0aW9ucy5wYXJhbXMpO1xuICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbXMgPSBvbWl0QWdlbnQocHJldk9wdGlvbnMucGFyYW1zKTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhyZXF1ZXN0ZWRQYXJhbXMpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoZXhpc3RpbmdQYXJhbXMpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghc2hhbGxvd0VxdWFscyhleGlzdGluZ1BhcmFtcywgcmVxdWVzdGVkUGFyYW1zKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZXMpIHtcbiAgICAgIGlmICghcHJldk9wdGlvbnMubW9kZXMgfHwgIWFyckVxdWFscyhvcHRpb25zLm1vZGVzLCBwcmV2T3B0aW9ucy5tb2RlcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKC4uLmFyZ3MpIHtcbiAgICBsZXQgbWVzc2FnZXM7XG4gICAgbGV0IGFyZ0NvdW50ID0gYXJncy5sZW5ndGg7XG4gICAgaWYgKGFyZ0NvdW50ID09IDEpIHtcbiAgICAgIGlmIChpc09iamVjdChhcmdzWzBdKSkge1xuICAgICAgICBtZXNzYWdlcyA9IFttZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlcyhhcmdzWzBdKV07XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgbWVzc2FnZXMgPSBtZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlc0FycmF5KGFyZ3NbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICBcIlRoZSBzaW5nbGUtYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoKCkgZXhwZWN0cyBhIG1lc3NhZ2Ugb2JqZWN0IG9yIGFuIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0c1wiLFxuICAgICAgICAgIDQwMDEzLFxuICAgICAgICAgIDQwMFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlcyA9IFttZXNzYWdlX2RlZmF1bHQuZnJvbVZhbHVlcyh7IG5hbWU6IGFyZ3NbMF0sIGRhdGE6IGFyZ3NbMV0gfSldO1xuICAgIH1cbiAgICBjb25zdCBtYXhNZXNzYWdlU2l6ZSA9IHRoaXMuY2xpZW50Lm9wdGlvbnMubWF4TWVzc2FnZVNpemU7XG4gICAgY29uc3Qgd2lyZU1lc3NhZ2VzID0gYXdhaXQgZW5jb2RlQXJyYXkobWVzc2FnZXMsIHRoaXMuY2hhbm5lbE9wdGlvbnMpO1xuICAgIGNvbnN0IHNpemUgPSBnZXRNZXNzYWdlc1NpemUod2lyZU1lc3NhZ2VzKTtcbiAgICBpZiAoc2l6ZSA+IG1heE1lc3NhZ2VTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBcIk1heGltdW0gc2l6ZSBvZiBtZXNzYWdlcyB0aGF0IGNhbiBiZSBwdWJsaXNoZWQgYXQgb25jZSBleGNlZWRlZCAoIHdhcyBcIiArIHNpemUgKyBcIiBieXRlczsgbGltaXQgaXMgXCIgKyBtYXhNZXNzYWdlU2l6ZSArIFwiIGJ5dGVzKVwiLFxuICAgICAgICA0MDAwOSxcbiAgICAgICAgNDAwXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLl90aHJvd0lmVW5wdWJsaXNoYWJsZVN0YXRlKCk7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wdWJsaXNoKClcIixcbiAgICAgIFwic2VuZGluZyBtZXNzYWdlOyBjaGFubmVsIHN0YXRlIGlzIFwiICsgdGhpcy5zdGF0ZSArIFwiLCBtZXNzYWdlIGNvdW50ID0gXCIgKyB3aXJlTWVzc2FnZXMubGVuZ3RoXG4gICAgKTtcbiAgICBjb25zdCBwbSA9IGZyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuTUVTU0FHRSwgY2hhbm5lbDogdGhpcy5uYW1lLCBtZXNzYWdlczogd2lyZU1lc3NhZ2VzIH0pO1xuICAgIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlKHBtKTtcbiAgfVxuICBfdGhyb3dJZlVucHVibGlzaGFibGVTdGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgdGhyb3cgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJmYWlsZWRcIiB8fCB0aGlzLnN0YXRlID09PSBcInN1c3BlbmRlZFwiKSB7XG4gICAgICB0aHJvdyB0aGlzLmludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgfVxuICB9XG4gIG9uRXZlbnQobWVzc2FnZXMpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZUNoYW5uZWwub25FdmVudCgpXCIsIFwicmVjZWl2ZWQgbWVzc2FnZVwiKTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tpXTtcbiAgICAgIHN1YnNjcmlwdGlvbnMuZW1pdChtZXNzYWdlLm5hbWUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBhc3luYyBhdHRhY2goKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9hdHRhY2goZmFsc2UsIG51bGwsIChlcnIsIHJlc3VsdCkgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlc3VsdCkpO1xuICAgIH0pO1xuICB9XG4gIF9hdHRhY2goZm9yY2VSZWF0dGFjaCwgYXR0YWNoUmVhc29uLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5fYXR0YWNoKClcIixcbiAgICAgICAgICAgIFwiQ2hhbm5lbCBhdHRhY2ggZmFpbGVkOiBcIiArIGVyci50b1N0cmluZygpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgIGlmICghY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgY2FsbGJhY2soY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBcImF0dGFjaGluZ1wiIHx8IGZvcmNlUmVhdHRhY2gpIHtcbiAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiYXR0YWNoaW5nXCIsIGF0dGFjaFJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMub25jZShmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICAgIGNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFjayhudWxsLCBzdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2soXG4gICAgICAgICAgICBzdGF0ZUNoYW5nZS5yZWFzb24gfHwgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSB8fCBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGF0dGFjaDsgcmVhc29uIHVua25vd247IHN0YXRlID0gXCIgKyB0aGlzLmV2ZW50LCA5ZTQsIDUwMClcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGV0YWNoaW5nXCI6XG4gICAgICAgICAgY2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrKG5ldyBFcnJvckluZm8oXCJBdHRhY2ggcmVxdWVzdCBzdXBlcnNlZGVkIGJ5IGEgc3Vic2VxdWVudCBkZXRhY2ggcmVxdWVzdFwiLCA5ZTQsIDQwOSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGF0dGFjaEltcGwoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVDaGFubmVsLmF0dGFjaEltcGwoKVwiLCBcInNlbmRpbmcgQVRUQUNIIG1lc3NhZ2VcIik7XG4gICAgY29uc3QgYXR0YWNoTXNnID0gZnJvbVZhbHVlcyh7XG4gICAgICBhY3Rpb246IGFjdGlvbnMuQVRUQUNILFxuICAgICAgY2hhbm5lbDogdGhpcy5uYW1lLFxuICAgICAgcGFyYW1zOiB0aGlzLmNoYW5uZWxPcHRpb25zLnBhcmFtcyxcbiAgICAgIC8vIFJUTDRjMTogSW5jbHVkZXMgdGhlIGNoYW5uZWwgc2VyaWFsIHRvIHJlc3VtZSBmcm9tIGEgcHJldmlvdXMgbWVzc2FnZVxuICAgICAgLy8gb3IgYXR0YWNobWVudC5cbiAgICAgIGNoYW5uZWxTZXJpYWw6IHRoaXMucHJvcGVydGllcy5jaGFubmVsU2VyaWFsXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuY2hhbm5lbE9wdGlvbnMubW9kZXMpIHtcbiAgICAgIGF0dGFjaE1zZy5lbmNvZGVNb2Rlc1RvRmxhZ3MoYWxsVG9VcHBlckNhc2UodGhpcy5jaGFubmVsT3B0aW9ucy5tb2RlcykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYXR0YWNoUmVzdW1lKSB7XG4gICAgICBhdHRhY2hNc2cuc2V0RmxhZyhcIkFUVEFDSF9SRVNVTUVcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzKSB7XG4gICAgICBhdHRhY2hNc2cuY2hhbm5lbFNlcmlhbCA9IHRoaXMuX2xhc3RQYXlsb2FkLnByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWw7XG4gICAgfVxuICAgIHRoaXMuc2VuZE1lc3NhZ2UoYXR0YWNoTXNnKS5jYXRjaChub29wKTtcbiAgfVxuICBhc3luYyBkZXRhY2goKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgIGlmICghY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgdGhyb3cgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJkZXRhY2hlZFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImRldGFjaGVkXCI6XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBkZXRhY2g7IGNoYW5uZWwgc3RhdGUgPSBmYWlsZWRcIiwgOTAwMDEsIDQwMCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZShcImRldGFjaGluZ1wiKTtcbiAgICAgIGNhc2UgXCJkZXRhY2hpbmdcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLm9uY2UoZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5ldmVudCkge1xuICAgICAgICAgICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICBzdGF0ZUNoYW5nZS5yZWFzb24gfHwgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSB8fCBuZXcgRXJyb3JJbmZvKFwiVW5hYmxlIHRvIGRldGFjaDsgcmVhc29uIHVua25vd247IHN0YXRlID0gXCIgKyB0aGlzLmV2ZW50LCA5ZTQsIDUwMClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvckluZm8oXCJEZXRhY2ggcmVxdWVzdCBzdXBlcnNlZGVkIGJ5IGEgc3Vic2VxdWVudCBhdHRhY2ggcmVxdWVzdFwiLCA5ZTQsIDQwOSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZGV0YWNoSW1wbCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJSZWFsdGltZUNoYW5uZWwuZGV0YWNoKClcIiwgXCJzZW5kaW5nIERFVEFDSCBtZXNzYWdlXCIpO1xuICAgIGNvbnN0IG1zZyA9IGZyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuREVUQUNILCBjaGFubmVsOiB0aGlzLm5hbWUgfSk7XG4gICAgdGhpcy5zZW5kTWVzc2FnZShtc2cpLmNhdGNoKG5vb3ApO1xuICB9XG4gIGFzeW5jIHN1YnNjcmliZSguLi5hcmdzKSB7XG4gICAgY29uc3QgW2V2ZW50LCBsaXN0ZW5lcl0gPSBfUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJncyk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHRocm93IEVycm9ySW5mby5mcm9tVmFsdWVzKHRoaXMuaW52YWxpZFN0YXRlRXJyb3IoKSk7XG4gICAgfVxuICAgIGlmIChldmVudCAmJiB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICB0aGlzLmNsaWVudC5fRmlsdGVyZWRTdWJzY3JpcHRpb25zLnN1YnNjcmliZUZpbHRlcih0aGlzLCBldmVudCwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hhbm5lbE9wdGlvbnMuYXR0YWNoT25TdWJzY3JpYmUgIT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHVuc3Vic2NyaWJlKC4uLmFyZ3MpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IFtldmVudCwgbGlzdGVuZXJdID0gX1JlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3MpO1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgIWxpc3RlbmVyIHx8ICgoX2EyID0gdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaGFzKGxpc3RlbmVyKSkpIHtcbiAgICAgIHRoaXMuY2xpZW50Ll9GaWx0ZXJlZFN1YnNjcmlwdGlvbnMuZ2V0QW5kRGVsZXRlRmlsdGVyZWRTdWJzY3JpcHRpb25zKHRoaXMsIGV2ZW50LCBsaXN0ZW5lcikuZm9yRWFjaCgobCkgPT4gdGhpcy5zdWJzY3JpcHRpb25zLm9mZihsKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICBzeW5jKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBcImluaXRpYWxpemVkXCI6XG4gICAgICBjYXNlIFwiZGV0YWNoaW5nXCI6XG4gICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgdGhyb3cgbmV3IFBhcnRpYWxFcnJvckluZm8oXCJVbmFibGUgdG8gc3luYyB0byBjaGFubmVsOyBub3QgYXR0YWNoZWRcIiwgNGU0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICBpZiAoIWNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgIHRocm93IGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IHN5bmNNZXNzYWdlID0gZnJvbVZhbHVlcyh7IGFjdGlvbjogYWN0aW9ucy5TWU5DLCBjaGFubmVsOiB0aGlzLm5hbWUgfSk7XG4gICAgaWYgKHRoaXMuc3luY0NoYW5uZWxTZXJpYWwpIHtcbiAgICAgIHN5bmNNZXNzYWdlLmNoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsO1xuICAgIH1cbiAgICBjb25uZWN0aW9uTWFuYWdlci5zZW5kKHN5bmNNZXNzYWdlKTtcbiAgfVxuICBhc3luYyBzZW5kTWVzc2FnZShtc2cpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zZW5kKG1zZywgdGhpcy5jbGllbnQub3B0aW9ucy5xdWV1ZU1lc3NhZ2VzLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNlbmRQcmVzZW5jZShwcmVzZW5jZSkge1xuICAgIGNvbnN0IG1zZyA9IGZyb21WYWx1ZXMoe1xuICAgICAgYWN0aW9uOiBhY3Rpb25zLlBSRVNFTkNFLFxuICAgICAgY2hhbm5lbDogdGhpcy5uYW1lLFxuICAgICAgcHJlc2VuY2VcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5zZW5kTWVzc2FnZShtc2cpO1xuICB9XG4gIC8vIEFjY2VzcyB0byB0aGlzIG1ldGhvZCBpcyBzeW5jaHJvbmlzZWQgYnkgQ29ubmVjdGlvbk1hbmFnZXIjcHJvY2Vzc0NoYW5uZWxNZXNzYWdlLCBpbiBvcmRlciB0byBzeW5jaHJvbmlzZSBhY2Nlc3MgdG8gdGhlIHN0YXRlIHN0b3JlZCBpbiBfZGVjb2RpbmdDb250ZXh0LlxuICBhc3luYyBwcm9jZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLkFUVEFDSEVEIHx8IG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLk1FU1NBR0UgfHwgbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0UgfHwgbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuQU5OT1RBVElPTikge1xuICAgICAgdGhpcy5zZXRDaGFubmVsU2VyaWFsKG1lc3NhZ2UuY2hhbm5lbFNlcmlhbCk7XG4gICAgfVxuICAgIGxldCBzeW5jQ2hhbm5lbFNlcmlhbCwgaXNTeW5jID0gZmFsc2U7XG4gICAgc3dpdGNoIChtZXNzYWdlLmFjdGlvbikge1xuICAgICAgY2FzZSBhY3Rpb25zLkFUVEFDSEVEOiB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XG4gICAgICAgIHRoaXMuX21vZGUgPSBtZXNzYWdlLmdldE1vZGUoKTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBtZXNzYWdlLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgY29uc3QgbW9kZXNGcm9tRmxhZ3MgPSBtZXNzYWdlLmRlY29kZU1vZGVzRnJvbUZsYWdzKCk7XG4gICAgICAgIHRoaXMubW9kZXMgPSBtb2Rlc0Zyb21GbGFncyAmJiBhbGxUb0xvd2VyQ2FzZShtb2Rlc0Zyb21GbGFncykgfHwgdm9pZCAwO1xuICAgICAgICBjb25zdCByZXN1bWVkID0gbWVzc2FnZS5oYXNGbGFnKFwiUkVTVU1FRFwiKTtcbiAgICAgICAgY29uc3QgaGFzUHJlc2VuY2UgPSBtZXNzYWdlLmhhc0ZsYWcoXCJIQVNfUFJFU0VOQ0VcIik7XG4gICAgICAgIGNvbnN0IGhhc0JhY2tsb2cgPSBtZXNzYWdlLmhhc0ZsYWcoXCJIQVNfQkFDS0xPR1wiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgICAgIGlmICghcmVzdW1lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXNlbmNlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3ByZXNlbmNlLm9uQXR0YWNoZWQoaGFzUHJlc2VuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlX2RlZmF1bHQodGhpcy5zdGF0ZSwgdGhpcy5zdGF0ZSwgcmVzdW1lZCwgaGFzQmFja2xvZywgbWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgdGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMuZW1pdChcInVwZGF0ZVwiLCBjaGFuZ2UpO1xuICAgICAgICAgIGlmICghcmVzdW1lZCB8fCB0aGlzLmNoYW5uZWxPcHRpb25zLnVwZGF0ZU9uQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBjaGFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBcImRldGFjaGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJhdHRhY2hlZFwiLCBtZXNzYWdlLmVycm9yLCByZXN1bWVkLCBoYXNQcmVzZW5jZSwgaGFzQmFja2xvZyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuREVUQUNIRUQ6IHtcbiAgICAgICAgY29uc3QgZGV0YWNoRXJyID0gbWVzc2FnZS5lcnJvciA/IEVycm9ySW5mby5mcm9tVmFsdWVzKG1lc3NhZ2UuZXJyb3IpIDogbmV3IEVycm9ySW5mbyhcIkNoYW5uZWwgZGV0YWNoZWRcIiwgOTAwMDEsIDQwNCk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImRldGFjaGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcImRldGFjaGVkXCIsIGRldGFjaEVycik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gXCJhdHRhY2hpbmdcIikge1xuICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJzdXNwZW5kZWRcIiwgZGV0YWNoRXJyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBcImF0dGFjaGVkXCIgfHwgdGhpcy5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiYXR0YWNoaW5nXCIsIGRldGFjaEVycik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuU1lOQzpcbiAgICAgICAgaXNTeW5jID0gdHJ1ZTtcbiAgICAgICAgc3luY0NoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuICAgICAgICBpZiAoIW1lc3NhZ2UucHJlc2VuY2UpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuUFJFU0VOQ0U6IHtcbiAgICAgICAgaWYgKCFtZXNzYWdlLnByZXNlbmNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcG9wdWxhdGVGaWVsZHNGcm9tUGFyZW50KG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuX3ByZXNlbmNlKSB7XG4gICAgICAgICAgY29uc3QgcHJlc2VuY2VNZXNzYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgbWVzc2FnZS5wcmVzZW5jZS5tYXAoKHdwbSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gd3BtLmRlY29kZShvcHRpb25zLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5fcHJlc2VuY2Uuc2V0UHJlc2VuY2UocHJlc2VuY2VNZXNzYWdlcywgaXNTeW5jLCBzeW5jQ2hhbm5lbFNlcmlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuTUVTU0FHRToge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gXCJhdHRhY2hlZFwiKSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTWVzc2FnZSgpXCIsXG4gICAgICAgICAgICAnTWVzc2FnZSBcIicgKyBtZXNzYWdlLmlkICsgJ1wiIHNraXBwZWQgYXMgdGhpcyBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIiBzdGF0ZSBpcyBub3QgXCJhdHRhY2hlZFwiIChzdGF0ZSBpcyBcIicgKyB0aGlzLnN0YXRlICsgJ1wiKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcG9wdWxhdGVGaWVsZHNGcm9tUGFyZW50KG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBlbmNvZGVkID0gbWVzc2FnZS5tZXNzYWdlcywgZmlyc3RNZXNzYWdlID0gZW5jb2RlZFswXSwgbGFzdE1lc3NhZ2UgPSBlbmNvZGVkW2VuY29kZWQubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChmaXJzdE1lc3NhZ2UuZXh0cmFzICYmIGZpcnN0TWVzc2FnZS5leHRyYXMuZGVsdGEgJiYgZmlyc3RNZXNzYWdlLmV4dHJhcy5kZWx0YS5mcm9tICE9PSB0aGlzLl9sYXN0UGF5bG9hZC5tZXNzYWdlSWQpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSAnRGVsdGEgbWVzc2FnZSBkZWNvZGUgZmFpbHVyZSAtIHByZXZpb3VzIG1lc3NhZ2Ugbm90IGF2YWlsYWJsZSBmb3IgbWVzc2FnZSBcIicgKyBtZXNzYWdlLmlkICsgJ1wiIG9uIHRoaXMgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCIuJztcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJSZWFsdGltZUNoYW5uZWwucHJvY2Vzc01lc3NhZ2UoKVwiLCBtc2cpO1xuICAgICAgICAgIHRoaXMuX3N0YXJ0RGVjb2RlRmFpbHVyZVJlY292ZXJ5KG5ldyBFcnJvckluZm8obXNnLCA0MDAxOCwgNDAwKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lc3NhZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHsgZGVjb2RlZCwgZXJyIH0gPSBhd2FpdCBlbmNvZGVkW2ldLmRlY29kZVdpdGhFcnIodGhpcy5fZGVjb2RpbmdDb250ZXh0LCB0aGlzLmxvZ2dlcik7XG4gICAgICAgICAgbWVzc2FnZXNbaV0gPSBkZWNvZGVkO1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA0MDAxODpcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeShlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgY2FzZSA0MDAxOTpcbiAgICAgICAgICAgICAgY2FzZSA0MDAyMTpcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiZmFpbGVkXCIsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0UGF5bG9hZC5tZXNzYWdlSWQgPSBsYXN0TWVzc2FnZS5pZDtcbiAgICAgICAgdGhpcy5fbGFzdFBheWxvYWQucHJvdG9jb2xNZXNzYWdlQ2hhbm5lbFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgdGhpcy5vbkV2ZW50KG1lc3NhZ2VzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGFjdGlvbnMuQU5OT1RBVElPTjoge1xuICAgICAgICBwb3B1bGF0ZUZpZWxkc0Zyb21QYXJlbnQobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5fYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgKG1lc3NhZ2UuYW5ub3RhdGlvbnMgfHwgW10pLm1hcCgod3BtKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB3cG0uZGVjb2RlKG9wdGlvbnMsIHRoaXMubG9nZ2VyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLl9hbm5vdGF0aW9ucy5fcHJvY2Vzc0luY29taW5nKGFubm90YXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgYWN0aW9ucy5FUlJPUjoge1xuICAgICAgICBjb25zdCBlcnIgPSBtZXNzYWdlLmVycm9yO1xuICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09IDgwMDE2KSB7XG4gICAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoXCJmYWlsZWRcIiwgRXJyb3JJbmZvLmZyb21WYWx1ZXMoZXJyKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLFxuICAgICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NNZXNzYWdlKClcIixcbiAgICAgICAgICBcIlByb3RvY29sIGVycm9yOiB1bnJlY29nbmlzZWQgbWVzc2FnZSBhY3Rpb24gKFwiICsgbWVzc2FnZS5hY3Rpb24gKyBcIilcIlxuICAgICAgICApO1xuICAgIH1cbiAgfVxuICBfc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgIFwiUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NNZXNzYWdlKClcIixcbiAgICAgICAgXCJTdGFydGluZyBkZWNvZGUgZmFpbHVyZSByZWNvdmVyeSBwcm9jZXNzLlwiXG4gICAgICApO1xuICAgICAgdGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICB0aGlzLl9hdHRhY2godHJ1ZSwgcmVhc29uLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbkF0dGFjaGVkKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZUNoYW5uZWwub25BdHRhY2hlZFwiLFxuICAgICAgXCJhY3RpdmF0aW5nIGNoYW5uZWw7IG5hbWUgPSBcIiArIHRoaXMubmFtZVxuICAgICk7XG4gIH1cbiAgbm90aWZ5U3RhdGUoc3RhdGUsIHJlYXNvbiwgcmVzdW1lZCwgaGFzUHJlc2VuY2UsIGhhc0JhY2tsb2cpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWVDaGFubmVsLm5vdGlmeVN0YXRlXCIsXG4gICAgICBcIm5hbWUgPSBcIiArIHRoaXMubmFtZSArIFwiLCBjdXJyZW50IHN0YXRlID0gXCIgKyB0aGlzLnN0YXRlICsgXCIsIG5vdGlmeWluZyBzdGF0ZSBcIiArIHN0YXRlXG4gICAgKTtcbiAgICB0aGlzLmNsZWFyU3RhdGVUaW1lcigpO1xuICAgIGlmIChbXCJkZXRhY2hlZFwiLCBcInN1c3BlbmRlZFwiLCBcImZhaWxlZFwiXS5pbmNsdWRlcyhzdGF0ZSkpIHtcbiAgICAgIHRoaXMucHJvcGVydGllcy5jaGFubmVsU2VyaWFsID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSB0aGlzLnN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9wcmVzZW5jZSkge1xuICAgICAgdGhpcy5fcHJlc2VuY2UuYWN0T25DaGFubmVsU3RhdGUoc3RhdGUsIGhhc1ByZXNlbmNlLCByZWFzb24pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IFwic3VzcGVuZGVkXCIgJiYgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICB0aGlzLnN0YXJ0UmV0cnlUaW1lcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcbiAgICB9XG4gICAgaWYgKHJlYXNvbikge1xuICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHJlYXNvbjtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0KHRoaXMuc3RhdGUsIHN0YXRlLCByZXN1bWVkLCBoYXNCYWNrbG9nLCByZWFzb24pO1xuICAgIGNvbnN0IGFjdGlvbiA9ICdDaGFubmVsIHN0YXRlIGZvciBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIic7XG4gICAgY29uc3QgbWVzc2FnZSA9IHN0YXRlICsgKHJlYXNvbiA/IFwiOyByZWFzb246IFwiICsgcmVhc29uIDogXCJcIik7XG4gICAgaWYgKHN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgYWN0aW9uLCBtZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsIGFjdGlvbiwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSAhPT0gXCJhdHRhY2hpbmdcIiAmJiBzdGF0ZSAhPT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgIHRoaXMub25BdHRhY2hlZCgpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IFwiYXR0YWNoZWRcIikge1xuICAgICAgdGhpcy5fYXR0YWNoUmVzdW1lID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcImRldGFjaGluZ1wiIHx8IHN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICB0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoc3RhdGUsIGNoYW5nZSk7XG4gICAgdGhpcy5lbWl0KHN0YXRlLCBjaGFuZ2UpO1xuICB9XG4gIHJlcXVlc3RTdGF0ZShzdGF0ZSwgcmVhc29uKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5yZXF1ZXN0U3RhdGVcIixcbiAgICAgIFwibmFtZSA9IFwiICsgdGhpcy5uYW1lICsgXCIsIHN0YXRlID0gXCIgKyBzdGF0ZVxuICAgICk7XG4gICAgdGhpcy5ub3RpZnlTdGF0ZShzdGF0ZSwgcmVhc29uKTtcbiAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gIH1cbiAgY2hlY2tQZW5kaW5nU3RhdGUoKSB7XG4gICAgY29uc3QgY21TdGF0ZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGU7XG4gICAgaWYgKCFjbVN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGVcIixcbiAgICAgICAgXCJzZW5kRXZlbnRzIGlzIGZhbHNlOyBzdGF0ZSBpcyBcIiArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc3RhdGVcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGVcIixcbiAgICAgIFwibmFtZSA9IFwiICsgdGhpcy5uYW1lICsgXCIsIHN0YXRlID0gXCIgKyB0aGlzLnN0YXRlXG4gICAgKTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKTtcbiAgICAgICAgdGhpcy5hdHRhY2hJbXBsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRldGFjaGluZ1wiOlxuICAgICAgICB0aGlzLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZygpO1xuICAgICAgICB0aGlzLmRldGFjaEltcGwoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYXR0YWNoZWRcIjpcbiAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRpbWVvdXRQZW5kaW5nU3RhdGUoKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6IHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9ySW5mbyhcIkNoYW5uZWwgYXR0YWNoIHRpbWVkIG91dFwiLCA5MDAwNywgNDA4KTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShcInN1c3BlbmRlZFwiLCBlcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZXRhY2hpbmdcIjoge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JJbmZvKFwiQ2hhbm5lbCBkZXRhY2ggdGltZWQgb3V0XCIsIDkwMDA3LCA0MDgpO1xuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKFwiYXR0YWNoZWRcIiwgZXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlVGltZXIpIHtcbiAgICAgIHRoaXMuc3RhdGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJSZWFsdGltZUNoYW5uZWwuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nXCIsIFwidGltZXIgZXhwaXJlZFwiKTtcbiAgICAgICAgdGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0UGVuZGluZ1N0YXRlKCk7XG4gICAgICB9LCB0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBjbGVhclN0YXRlVGltZXIoKSB7XG4gICAgY29uc3Qgc3RhdGVUaW1lciA9IHRoaXMuc3RhdGVUaW1lcjtcbiAgICBpZiAoc3RhdGVUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlVGltZXIpO1xuICAgICAgdGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhcnRSZXRyeVRpbWVyKCkge1xuICAgIGlmICh0aGlzLnJldHJ5VGltZXIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yZXRyeUNvdW50Kys7XG4gICAgY29uc3QgcmV0cnlEZWxheSA9IGdldFJldHJ5VGltZSh0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLmNoYW5uZWxSZXRyeVRpbWVvdXQsIHRoaXMucmV0cnlDb3VudCk7XG4gICAgdGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIiAmJiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIlJlYWx0aW1lQ2hhbm5lbCByZXRyeSB0aW1lciBleHBpcmVkXCIsXG4gICAgICAgICAgXCJhdHRlbXB0aW5nIGEgbmV3IGF0dGFjaFwiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKFwiYXR0YWNoaW5nXCIpO1xuICAgICAgfVxuICAgIH0sIHJldHJ5RGVsYXkpO1xuICB9XG4gIGNhbmNlbFJldHJ5VGltZXIoKSB7XG4gICAgaWYgKHRoaXMucmV0cnlUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG4gICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKiBAcmV0dXJucyBudWxsIChpZiBjYW4gc2FmZWx5IGJlIHJlbGVhc2VkKSB8IEVycm9ySW5mbyAoaWYgY2Fubm90KSAqL1xuICBnZXRSZWxlYXNlRXJyKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzID09PSBcImluaXRpYWxpemVkXCIgfHwgcyA9PT0gXCJkZXRhY2hlZFwiIHx8IHMgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9ySW5mbyhcbiAgICAgIFwiQ2FuIG9ubHkgcmVsZWFzZSBhIGNoYW5uZWwgaW4gYSBzdGF0ZSB3aGVyZSB0aGVyZSBpcyBubyBwb3NzaWJpbGl0eSBvZiBmdXJ0aGVyIHVwZGF0ZXMgZnJvbSB0aGUgc2VydmVyIGJlaW5nIHJlY2VpdmVkIChpbml0aWFsaXplZCwgZGV0YWNoZWQsIG9yIGZhaWxlZCk7IHdhcyBcIiArIHMsXG4gICAgICA5MDAwMSxcbiAgICAgIDQwMFxuICAgICk7XG4gIH1cbiAgc2V0Q2hhbm5lbFNlcmlhbChjaGFubmVsU2VyaWFsKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lQ2hhbm5lbC5zZXRDaGFubmVsU2VyaWFsKClcIixcbiAgICAgIFwiVXBkYXRpbmcgY2hhbm5lbCBzZXJpYWw7IHNlcmlhbCA9IFwiICsgY2hhbm5lbFNlcmlhbCArIFwiOyBwcmV2aW91cyA9IFwiICsgdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWxcbiAgICApO1xuICAgIGlmIChjaGFubmVsU2VyaWFsKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IGNoYW5uZWxTZXJpYWw7XG4gICAgfVxuICB9XG4gIGFzeW5jIHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVzdC5jaGFubmVsTWl4aW4uc3RhdHVzKHRoaXMpO1xuICB9XG59O1xuZnVuY3Rpb24gb21pdEFnZW50KGNoYW5uZWxQYXJhbXMpIHtcbiAgY29uc3QgX2EyID0gY2hhbm5lbFBhcmFtcyB8fCB7fSwgeyBhZ2VudDogXyB9ID0gX2EyLCBwYXJhbXNXaXRob3V0QWdlbnQgPSBfX29ialJlc3QoX2EyLCBbXCJhZ2VudFwiXSk7XG4gIHJldHVybiBwYXJhbXNXaXRob3V0QWdlbnQ7XG59XG52YXIgcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQgPSBSZWFsdGltZUNoYW5uZWw7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9yZWFsdGltZWFubm90YXRpb25zLnRzXG52YXIgUmVhbHRpbWVBbm5vdGF0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCkge1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgdGhpcy5sb2dnZXIgPSBjaGFubmVsLmxvZ2dlcjtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2gobXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpIHtcbiAgICBjb25zdCBjaGFubmVsTmFtZSA9IHRoaXMuY2hhbm5lbC5uYW1lO1xuICAgIGNvbnN0IGFubm90YXRpb24gPSBjb25zdHJ1Y3RWYWxpZGF0ZUFubm90YXRpb24obXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpO1xuICAgIGNvbnN0IHdpcmVBbm5vdGF0aW9uID0gYXdhaXQgYW5ub3RhdGlvbi5lbmNvZGUoKTtcbiAgICB0aGlzLmNoYW5uZWwuX3Rocm93SWZVbnB1Ymxpc2hhYmxlU3RhdGUoKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiUmVhbHRpbWVBbm5vdGF0aW9ucy5wdWJsaXNoKClcIixcbiAgICAgIFwiY2hhbm5lbE5hbWUgPSBcIiArIGNoYW5uZWxOYW1lICsgXCIsIHNlbmRpbmcgYW5ub3RhdGlvbiB3aXRoIG1lc3NhZ2VTZXJpYWwgPSBcIiArIGFubm90YXRpb24ubWVzc2FnZVNlcmlhbCArIFwiLCB0eXBlID0gXCIgKyBhbm5vdGF0aW9uLnR5cGVcbiAgICApO1xuICAgIGNvbnN0IHBtID0gZnJvbVZhbHVlcyh7XG4gICAgICBhY3Rpb246IGFjdGlvbnMuQU5OT1RBVElPTixcbiAgICAgIGNoYW5uZWw6IGNoYW5uZWxOYW1lLFxuICAgICAgYW5ub3RhdGlvbnM6IFt3aXJlQW5ub3RhdGlvbl1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLnNlbmRNZXNzYWdlKHBtKTtcbiAgfVxuICBhc3luYyBkZWxldGUobXNnT3JTZXJpYWwsIGFubm90YXRpb25WYWx1ZXMpIHtcbiAgICBhbm5vdGF0aW9uVmFsdWVzLmFjdGlvbiA9IFwiYW5ub3RhdGlvbi5kZWxldGVcIjtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKG1zZ09yU2VyaWFsLCBhbm5vdGF0aW9uVmFsdWVzKTtcbiAgfVxuICBhc3luYyBzdWJzY3JpYmUoLi4uX2FyZ3MpIHtcbiAgICBjb25zdCBhcmdzID0gcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQucHJvY2Vzc0xpc3RlbmVyQXJncyhfYXJncyk7XG4gICAgY29uc3QgZXZlbnQgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gYXJnc1sxXTtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuICAgIGlmIChjaGFubmVsLnN0YXRlID09PSBcImZhaWxlZFwiKSB7XG4gICAgICB0aHJvdyBFcnJvckluZm8uZnJvbVZhbHVlcyhjaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCkpO1xuICAgIH1cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICBpZiAodGhpcy5jaGFubmVsLmNoYW5uZWxPcHRpb25zLmF0dGFjaE9uU3Vic2NyaWJlICE9PSBmYWxzZSkge1xuICAgICAgYXdhaXQgY2hhbm5lbC5hdHRhY2goKTtcbiAgICB9XG4gICAgaWYgKCh0aGlzLmNoYW5uZWwuc3RhdGUgPT09IFwiYXR0YWNoZWRcIiAmJiB0aGlzLmNoYW5uZWwuX21vZGUgJiBmbGFncy5BTk5PVEFUSU9OX1NVQlNDUklCRSkgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXG4gICAgICAgIFwiWW91IGFyZSB0cnlpbmcgdG8gYWRkIGFuIGFubm90YXRpb24gbGlzdGVuZXIsIGJ1dCB5b3UgaGF2ZW4ndCByZXF1ZXN0ZWQgdGhlIGFubm90YXRpb25fc3Vic2NyaWJlIGNoYW5uZWwgbW9kZSBpbiBDaGFubmVsT3B0aW9ucywgc28gdGhpcyB3b24ndCBkbyBhbnl0aGluZyAod2Ugb25seSBkZWxpdmVyIGFubm90YXRpb25zIHRvIGNsaWVudHMgd2hvIGhhdmUgZXhwbGljaXRseSByZXF1ZXN0ZWQgdGhlbSlcIixcbiAgICAgICAgOTMwMDEsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdW5zdWJzY3JpYmUoLi4uX2FyZ3MpIHtcbiAgICBjb25zdCBhcmdzID0gcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQucHJvY2Vzc0xpc3RlbmVyQXJncyhfYXJncyk7XG4gICAgY29uc3QgZXZlbnQgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gYXJnc1sxXTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbiAgX3Byb2Nlc3NJbmNvbWluZyhhbm5vdGF0aW9ucykge1xuICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiBhbm5vdGF0aW9ucykge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmVtaXQoYW5ub3RhdGlvbi50eXBlIHx8IFwiXCIsIGFubm90YXRpb24pO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXQobXNnT3JTZXJpYWwsIHBhcmFtcykge1xuICAgIHJldHVybiByZXN0YW5ub3RhdGlvbnNfZGVmYXVsdC5wcm90b3R5cGUuZ2V0LmNhbGwodGhpcywgbXNnT3JTZXJpYWwsIHBhcmFtcyk7XG4gIH1cbn07XG52YXIgcmVhbHRpbWVhbm5vdGF0aW9uc19kZWZhdWx0ID0gUmVhbHRpbWVBbm5vdGF0aW9ucztcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L2RlZmF1bHRyZXN0LnRzXG52YXIgX0RlZmF1bHRSZXN0ID0gY2xhc3MgX0RlZmF1bHRSZXN0IGV4dGVuZHMgQmFzZVJlc3Qge1xuICAvLyBUaGUgcHVibGljIHR5cGluZ3MgZGVjbGFyZSB0aGF0IHRoaXMgcmVxdWlyZXMgYW4gYXJndW1lbnQgdG8gYmUgcGFzc2VkLCBidXQgc2luY2Ugd2Ugd2FudCB0byBlbWl0IGEgZ29vZCBlcnJvciBtZXNzYWdlIGluIHRoZSBjYXNlIHdoZXJlIGEgbm9uLVR5cGVTY3JpcHQgdXNlciBkb2VzIG5vdCBwYXNzIGFuIGFyZ3VtZW50LCB0ZWxsIHRoZSBjb21waWxlciB0aGF0IHRoaXMgaXMgcG9zc2libGUgc28gdGhhdCBpdCBmb3JjZXMgdXMgdG8gaGFuZGxlIGl0LlxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgY29uc3QgTXNnUGFjayA9IF9EZWZhdWx0UmVzdC5fTXNnUGFjaztcbiAgICBpZiAoIU1zZ1BhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIERlZmF1bHRSZXN0Ll9Nc2dQYWNrIHRvIGhhdmUgYmVlbiBzZXRcIik7XG4gICAgfVxuICAgIHN1cGVyKFxuICAgICAgZGVmYXVsdHNfZGVmYXVsdC5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMsIHRydWUsIFwiUmVzdFwiLCBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBhbGxDb21tb25Nb2R1bGFyUGx1Z2lucyksIHtcbiAgICAgICAgQ3J5cHRvOiAoX2EyID0gX0RlZmF1bHRSZXN0LkNyeXB0bykgIT0gbnVsbCA/IF9hMiA6IHZvaWQgMCxcbiAgICAgICAgTXNnUGFjazogKF9iID0gX0RlZmF1bHRSZXN0Ll9Nc2dQYWNrKSAhPSBudWxsID8gX2IgOiB2b2lkIDAsXG4gICAgICAgIEFubm90YXRpb25zOiB7XG4gICAgICAgICAgQW5ub3RhdGlvbjogYW5ub3RhdGlvbl9kZWZhdWx0LFxuICAgICAgICAgIFdpcmVBbm5vdGF0aW9uLFxuICAgICAgICAgIFJlYWx0aW1lQW5ub3RhdGlvbnM6IHJlYWx0aW1lYW5ub3RhdGlvbnNfZGVmYXVsdCxcbiAgICAgICAgICBSZXN0QW5ub3RhdGlvbnM6IHJlc3Rhbm5vdGF0aW9uc19kZWZhdWx0XG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgICk7XG4gIH1cbiAgc3RhdGljIGdldCBDcnlwdG8oKSB7XG4gICAgaWYgKHRoaXMuX0NyeXB0byA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBub3QgZW5hYmxlZDsgdXNlIGFibHkuZW5jcnlwdGlvbi5qcyBpbnN0ZWFkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fQ3J5cHRvO1xuICB9XG4gIHN0YXRpYyBzZXQgQ3J5cHRvKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fQ3J5cHRvID0gbmV3VmFsdWU7XG4gIH1cbn07XG5fRGVmYXVsdFJlc3QuX0NyeXB0byA9IG51bGw7XG5fRGVmYXVsdFJlc3QuTWVzc2FnZSA9IERlZmF1bHRNZXNzYWdlO1xuX0RlZmF1bHRSZXN0LlByZXNlbmNlTWVzc2FnZSA9IERlZmF1bHRQcmVzZW5jZU1lc3NhZ2U7XG5fRGVmYXVsdFJlc3QuQW5ub3RhdGlvbiA9IERlZmF1bHRBbm5vdGF0aW9uO1xuX0RlZmF1bHRSZXN0Ll9Nc2dQYWNrID0gbnVsbDtcbi8vIFVzZWQgYnkgdGVzdHNcbl9EZWZhdWx0UmVzdC5fSHR0cCA9IEh0dHA7XG52YXIgRGVmYXVsdFJlc3QgPSBfRGVmYXVsdFJlc3Q7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC9tZXNzYWdlcXVldWUudHNcbnZhciBNZXNzYWdlUXVldWUgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IobG9nZ2VyKSB7XG4gICAgc3VwZXIobG9nZ2VyKTtcbiAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gIH1cbiAgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMubGVuZ3RoO1xuICB9XG4gIHB1c2gobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgfVxuICBzaGlmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5zaGlmdCgpO1xuICB9XG4gIGxhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXNbdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgfVxuICBjb3B5QWxsKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLnNsaWNlKCk7XG4gIH1cbiAgYXBwZW5kKG1lc3NhZ2VzKSB7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoLmFwcGx5KHRoaXMubWVzc2FnZXMsIG1lc3NhZ2VzKTtcbiAgfVxuICBwcmVwZW5kKG1lc3NhZ2VzKSB7XG4gICAgdGhpcy5tZXNzYWdlcy51bnNoaWZ0LmFwcGx5KHRoaXMubWVzc2FnZXMsIG1lc3NhZ2VzKTtcbiAgfVxuICBjb21wbGV0ZU1lc3NhZ2VzKHNlcmlhbCwgY291bnQsIGVycikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJNZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcygpXCIsXG4gICAgICBcInNlcmlhbCA9IFwiICsgc2VyaWFsICsgXCI7IGNvdW50ID0gXCIgKyBjb3VudFxuICAgICk7XG4gICAgZXJyID0gZXJyIHx8IG51bGw7XG4gICAgY29uc3QgbWVzc2FnZXMgPSB0aGlzLm1lc3NhZ2VzO1xuICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKCk6IGNvbXBsZXRlTWVzc2FnZXMgY2FsbGVkIG9uIGFueSBlbXB0eSBNZXNzYWdlUXVldWVcIik7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0ID0gbWVzc2FnZXNbMF07XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBjb25zdCBzdGFydFNlcmlhbCA9IGZpcnN0Lm1lc3NhZ2UubXNnU2VyaWFsO1xuICAgICAgY29uc3QgZW5kU2VyaWFsID0gc2VyaWFsICsgY291bnQ7XG4gICAgICBpZiAoZW5kU2VyaWFsID4gc3RhcnRTZXJpYWwpIHtcbiAgICAgICAgY29uc3QgY29tcGxldGVNZXNzYWdlcyA9IG1lc3NhZ2VzLnNwbGljZSgwLCBlbmRTZXJpYWwgLSBzdGFydFNlcmlhbCk7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBjb21wbGV0ZU1lc3NhZ2VzKSB7XG4gICAgICAgICAgbWVzc2FnZS5jYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZXMubGVuZ3RoID09IDApXG4gICAgICAgIHRoaXMuZW1pdChcImlkbGVcIik7XG4gICAgfVxuICB9XG4gIGNvbXBsZXRlQWxsTWVzc2FnZXMoZXJyKSB7XG4gICAgdGhpcy5jb21wbGV0ZU1lc3NhZ2VzKDAsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IE51bWJlci5NQVhfVkFMVUUsIGVycik7XG4gIH1cbiAgcmVzZXRTZW5kQXR0ZW1wdGVkKCkge1xuICAgIGZvciAobGV0IG1zZyBvZiB0aGlzLm1lc3NhZ2VzKSB7XG4gICAgICBtc2cuc2VuZEF0dGVtcHRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiTWVzc2FnZVF1ZXVlLmNsZWFyKClcIixcbiAgICAgIFwiY2xlYXJpbmcgXCIgKyB0aGlzLm1lc3NhZ2VzLmxlbmd0aCArIFwiIG1lc3NhZ2VzXCJcbiAgICApO1xuICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICB0aGlzLmVtaXQoXCJpZGxlXCIpO1xuICB9XG59O1xudmFyIG1lc3NhZ2VxdWV1ZV9kZWZhdWx0ID0gTWVzc2FnZVF1ZXVlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvcHJvdG9jb2wudHNcbnZhciBQZW5kaW5nTWVzc2FnZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLm1lcmdlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFjdGlvbiA9IG1lc3NhZ2UuYWN0aW9uO1xuICAgIHRoaXMuc2VuZEF0dGVtcHRlZCA9IGZhbHNlO1xuICAgIHRoaXMuYWNrUmVxdWlyZWQgPSBhY3Rpb24gPT0gYWN0aW9ucy5NRVNTQUdFIHx8IGFjdGlvbiA9PSBhY3Rpb25zLlBSRVNFTkNFIHx8IGFjdGlvbiA9PSBhY3Rpb25zLkFOTk9UQVRJT047XG4gIH1cbn07XG52YXIgUHJvdG9jb2wgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgc3VwZXIodHJhbnNwb3J0LmxvZ2dlcik7XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5tZXNzYWdlUXVldWUgPSBuZXcgbWVzc2FnZXF1ZXVlX2RlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgIHRyYW5zcG9ydC5vbihcImFja1wiLCAoc2VyaWFsLCBjb3VudCkgPT4ge1xuICAgICAgdGhpcy5vbkFjayhzZXJpYWwsIGNvdW50KTtcbiAgICB9KTtcbiAgICB0cmFuc3BvcnQub24oXCJuYWNrXCIsIChzZXJpYWwsIGNvdW50LCBlcnIpID0+IHtcbiAgICAgIHRoaXMub25OYWNrKHNlcmlhbCwgY291bnQsIGVycik7XG4gICAgfSk7XG4gIH1cbiAgb25BY2soc2VyaWFsLCBjb3VudCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIlByb3RvY29sLm9uQWNrKClcIiwgXCJzZXJpYWwgPSBcIiArIHNlcmlhbCArIFwiOyBjb3VudCA9IFwiICsgY291bnQpO1xuICAgIHRoaXMubWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoc2VyaWFsLCBjb3VudCk7XG4gIH1cbiAgb25OYWNrKHNlcmlhbCwgY291bnQsIGVycikge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgXCJQcm90b2NvbC5vbk5hY2soKVwiLFxuICAgICAgXCJzZXJpYWwgPSBcIiArIHNlcmlhbCArIFwiOyBjb3VudCA9IFwiICsgY291bnQgKyBcIjsgZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICk7XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gc2VuZCBtZXNzYWdlOyBjaGFubmVsIG5vdCByZXNwb25kaW5nXCIsIDUwMDAxLCA1MDApO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKHNlcmlhbCwgY291bnQsIGVycik7XG4gIH1cbiAgb25jZUlkbGUobGlzdGVuZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlUXVldWUgPSB0aGlzLm1lc3NhZ2VRdWV1ZTtcbiAgICBpZiAobWVzc2FnZVF1ZXVlLmNvdW50KCkgPT09IDApIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1lc3NhZ2VRdWV1ZS5vbmNlKFwiaWRsZVwiLCBsaXN0ZW5lcik7XG4gIH1cbiAgc2VuZChwZW5kaW5nTWVzc2FnZSkge1xuICAgIGlmIChwZW5kaW5nTWVzc2FnZS5hY2tSZXF1aXJlZCkge1xuICAgICAgdGhpcy5tZXNzYWdlUXVldWUucHVzaChwZW5kaW5nTWVzc2FnZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxvZ2dlci5zaG91bGRMb2cobG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uTm9TdHJpcChcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJQcm90b2NvbC5zZW5kKClcIixcbiAgICAgICAgXCJzZW5kaW5nIG1zZzsgXCIgKyBzdHJpbmdpZnkoXG4gICAgICAgICAgcGVuZGluZ01lc3NhZ2UubWVzc2FnZSxcbiAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fUmVhbHRpbWVQcmVzZW5jZSxcbiAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fQW5ub3RhdGlvbnNcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgcGVuZGluZ01lc3NhZ2Uuc2VuZEF0dGVtcHRlZCA9IHRydWU7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZChwZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcbiAgfVxuICBnZXRUcmFuc3BvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0O1xuICB9XG4gIGdldFBlbmRpbmdNZXNzYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlUXVldWUuY29weUFsbCgpO1xuICB9XG4gIGNsZWFyUGVuZGluZ01lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VRdWV1ZS5jbGVhcigpO1xuICB9XG4gIGZpbmlzaCgpIHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydDtcbiAgICB0aGlzLm9uY2VJZGxlKGZ1bmN0aW9uKCkge1xuICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBwcm90b2NvbF9kZWZhdWx0ID0gUHJvdG9jb2w7XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9jb25uZWN0aW9uc3RhdGVjaGFuZ2UudHNcbnZhciBDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHByZXZpb3VzLCBjdXJyZW50LCByZXRyeUluLCByZWFzb24pIHtcbiAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICBpZiAocmV0cnlJbilcbiAgICAgIHRoaXMucmV0cnlJbiA9IHJldHJ5SW47XG4gICAgaWYgKHJlYXNvbilcbiAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB9XG59O1xudmFyIGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV9kZWZhdWx0ID0gQ29ubmVjdGlvblN0YXRlQ2hhbmdlO1xuXG4vLyBzcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvY29ubmVjdGlvbmVycm9ycy50c1xudmFyIENvbm5lY3Rpb25FcnJvckNvZGVzID0ge1xuICBESVNDT05ORUNURUQ6IDgwMDAzLFxuICBTVVNQRU5ERUQ6IDgwMDAyLFxuICBGQUlMRUQ6IDhlNCxcbiAgQ0xPU0lORzogODAwMTcsXG4gIENMT1NFRDogODAwMTcsXG4gIFVOS05PV05fQ09OTkVDVElPTl9FUlI6IDUwMDAyLFxuICBVTktOT1dOX0NIQU5ORUxfRVJSOiA1MDAwMVxufTtcbnZhciBDb25uZWN0aW9uRXJyb3JzID0ge1xuICBkaXNjb25uZWN0ZWQ6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuRElTQ09OTkVDVEVELFxuICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiB0byBzZXJ2ZXIgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGVcIlxuICB9KSxcbiAgc3VzcGVuZGVkOiAoKSA9PiBFcnJvckluZm8uZnJvbVZhbHVlcyh7XG4gICAgc3RhdHVzQ29kZTogNDAwLFxuICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLlNVU1BFTkRFRCxcbiAgICBtZXNzYWdlOiBcIkNvbm5lY3Rpb24gdG8gc2VydmVyIHVuYXZhaWxhYmxlXCJcbiAgfSksXG4gIGZhaWxlZDogKCkgPT4gRXJyb3JJbmZvLmZyb21WYWx1ZXMoe1xuICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5GQUlMRUQsXG4gICAgbWVzc2FnZTogXCJDb25uZWN0aW9uIGZhaWxlZCBvciBkaXNjb25uZWN0ZWQgYnkgc2VydmVyXCJcbiAgfSksXG4gIGNsb3Npbmc6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuQ0xPU0lORyxcbiAgICBtZXNzYWdlOiBcIkNvbm5lY3Rpb24gY2xvc2luZ1wiXG4gIH0pLFxuICBjbG9zZWQ6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuQ0xPU0VELFxuICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiBjbG9zZWRcIlxuICB9KSxcbiAgdW5rbm93bkNvbm5lY3Rpb25FcnI6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuVU5LTk9XTl9DT05ORUNUSU9OX0VSUixcbiAgICBtZXNzYWdlOiBcIkludGVybmFsIGNvbm5lY3Rpb24gZXJyb3JcIlxuICB9KSxcbiAgdW5rbm93bkNoYW5uZWxFcnI6ICgpID0+IEVycm9ySW5mby5mcm9tVmFsdWVzKHtcbiAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuVU5LTk9XTl9DT05ORUNUSU9OX0VSUixcbiAgICBtZXNzYWdlOiBcIkludGVybmFsIGNoYW5uZWwgZXJyb3JcIlxuICB9KVxufTtcbmZ1bmN0aW9uIGlzUmV0cmlhYmxlKGVycikge1xuICBpZiAoIWVyci5zdGF0dXNDb2RlIHx8ICFlcnIuY29kZSB8fCBlcnIuc3RhdHVzQ29kZSA+PSA1MDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhDb25uZWN0aW9uRXJyb3JDb2RlcykuaW5jbHVkZXMoZXJyLmNvZGUpO1xufVxudmFyIGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdCA9IENvbm5lY3Rpb25FcnJvcnM7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC90cmFuc3BvcnQudHNcbnZhciBjbG9zZU1lc3NhZ2UgPSBmcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkNMT1NFIH0pO1xudmFyIGRpc2Nvbm5lY3RNZXNzYWdlID0gZnJvbVZhbHVlcyh7IGFjdGlvbjogYWN0aW9ucy5ESVNDT05ORUNUIH0pO1xudmFyIFRyYW5zcG9ydCA9IGNsYXNzIGV4dGVuZHMgZXZlbnRlbWl0dGVyX2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCBmb3JjZUpzb25Qcm90b2NvbCkge1xuICAgIHN1cGVyKGNvbm5lY3Rpb25NYW5hZ2VyLmxvZ2dlcik7XG4gICAgaWYgKGZvcmNlSnNvblByb3RvY29sKSB7XG4gICAgICBwYXJhbXMuZm9ybWF0ID0gdm9pZCAwO1xuICAgICAgcGFyYW1zLmhlYXJ0YmVhdHMgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLnRpbWVvdXRzID0gcGFyYW1zLm9wdGlvbnMudGltZW91dHM7XG4gICAgdGhpcy5mb3JtYXQgPSBwYXJhbXMuZm9ybWF0O1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG4gICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgIHRoaXMubGFzdEFjdGl2aXR5ID0gbnVsbDtcbiAgfVxuICBjb25uZWN0KCkge1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnJlcXVlc3RDbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaChcImNsb3NlZFwiLCBjb25uZWN0aW9uZXJyb3JzX2RlZmF1bHQuY2xvc2VkKCkpO1xuICB9XG4gIGRpc2Nvbm5lY3QoZXJyKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMucmVxdWVzdERpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgZXJyIHx8IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdC5kaXNjb25uZWN0ZWQoKSk7XG4gIH1cbiAgZmFpbChlcnIpIHtcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5yZXF1ZXN0RGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaChcImZhaWxlZFwiLCBlcnIgfHwgY29ubmVjdGlvbmVycm9yc19kZWZhdWx0LmZhaWxlZCgpKTtcbiAgfVxuICBmaW5pc2goZXZlbnQsIGVycikge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG4gICAgY2xlYXJUaW1lb3V0KChfYTIgPSB0aGlzLmlkbGVUaW1lcikgIT0gbnVsbCA/IF9hMiA6IHZvaWQgMCk7XG4gICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuZW1pdChldmVudCwgZXJyKTtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgfVxuICBvblByb3RvY29sTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMubG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb25Ob1N0cmlwKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIlRyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpXCIsXG4gICAgICAgIFwicmVjZWl2ZWQgb24gXCIgKyB0aGlzLnNob3J0TmFtZSArIFwiOiBcIiArIHN0cmluZ2lmeShcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX1JlYWx0aW1lUHJlc2VuY2UsXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fQW5ub3RhdGlvbnNcbiAgICAgICAgKSArIFwiOyBjb25uZWN0aW9uSWQgPSBcIiArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UuYWN0aW9uKSB7XG4gICAgICBjYXNlIGFjdGlvbnMuSEVBUlRCRUFUOlxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb25Ob1N0cmlwKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIlRyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpXCIsXG4gICAgICAgICAgdGhpcy5zaG9ydE5hbWUgKyBcIiBoZWFydGJlYXQ7IGNvbm5lY3Rpb25JZCA9IFwiICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWRcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiaGVhcnRiZWF0XCIsIG1lc3NhZ2UuaWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5DT05ORUNURUQ6XG4gICAgICAgIHRoaXMub25Db25uZWN0KG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0ZWRcIiwgbWVzc2FnZS5lcnJvciwgbWVzc2FnZS5jb25uZWN0aW9uSWQsIG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMsIG1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5DTE9TRUQ6XG4gICAgICAgIHRoaXMub25DbG9zZShtZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuRElTQ09OTkVDVEVEOlxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdChtZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuQUNLOlxuICAgICAgICB0aGlzLmVtaXQoXCJhY2tcIiwgbWVzc2FnZS5tc2dTZXJpYWwsIG1lc3NhZ2UuY291bnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5OQUNLOlxuICAgICAgICB0aGlzLmVtaXQoXCJuYWNrXCIsIG1lc3NhZ2UubXNnU2VyaWFsLCBtZXNzYWdlLmNvdW50LCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuU1lOQzpcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5BQ1RJVkFURTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGFjdGlvbnMuQVVUSDpcbiAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKHRoaXMuYXV0aC5hdXRob3JpemUoKSwgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgICAgXCJUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKVwiLFxuICAgICAgICAgICAgICBcIkFibHkgcmVxdWVzdGVkIHJlLWF1dGhlbnRpY2F0aW9uLCBidXQgdW5hYmxlIHRvIG9idGFpbiBhIG5ldyB0b2tlbjogXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYWN0aW9ucy5FUlJPUjpcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIlRyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpXCIsXG4gICAgICAgICAgXCJyZWNlaXZlZCBlcnJvciBhY3Rpb247IGNvbm5lY3Rpb25JZCA9IFwiICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQgKyBcIjsgZXJyID0gXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChtZXNzYWdlLmVycm9yKSArIChtZXNzYWdlLmNoYW5uZWwgPyBcIiwgY2hhbm5lbDogXCIgKyBtZXNzYWdlLmNoYW5uZWwgOiBcIlwiKVxuICAgICAgICApO1xuICAgICAgICBpZiAobWVzc2FnZS5jaGFubmVsID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aGlzLm9uRmF0YWxFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuICAgIH1cbiAgfVxuICBvbkNvbm5lY3QobWVzc2FnZSkge1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIGlmICghbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0Lm9uQ29ubmVjdCgpOiBDb25uZWN0IG1lc3NhZ2UgcmVjaWV2ZWQgd2l0aG91dCBjb25uZWN0aW9uRGV0YWlsc1wiKTtcbiAgICB9XG4gICAgY29uc3QgbWF4UHJvbWlzZWRJZGxlID0gbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscy5tYXhJZGxlSW50ZXJ2YWw7XG4gICAgaWYgKG1heFByb21pc2VkSWRsZSkge1xuICAgICAgdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBtYXhQcm9taXNlZElkbGUgKyB0aGlzLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG4gICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICB9XG4gIH1cbiAgb25EaXNjb25uZWN0KG1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0Lm9uRGlzY29ubmVjdCgpXCIsIFwiZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgZXJyKTtcbiAgfVxuICBvbkZhdGFsRXJyb3IobWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJUcmFuc3BvcnQub25GYXRhbEVycm9yKClcIiwgXCJlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpKTtcbiAgICB0aGlzLmZpbmlzaChcImZhaWxlZFwiLCBlcnIpO1xuICB9XG4gIG9uQ2xvc2UobWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJUcmFuc3BvcnQub25DbG9zZSgpXCIsIFwiZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgdGhpcy5maW5pc2goXCJjbG9zZWRcIiwgZXJyKTtcbiAgfVxuICByZXF1ZXN0Q2xvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0LnJlcXVlc3RDbG9zZSgpXCIsIFwiXCIpO1xuICAgIHRoaXMuc2VuZChjbG9zZU1lc3NhZ2UpO1xuICB9XG4gIHJlcXVlc3REaXNjb25uZWN0KCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlRyYW5zcG9ydC5yZXF1ZXN0RGlzY29ubmVjdCgpXCIsIFwiXCIpO1xuICAgIHRoaXMuc2VuZChkaXNjb25uZWN0TWVzc2FnZSk7XG4gIH1cbiAgcGluZyhpZCkge1xuICAgIGNvbnN0IG1zZyA9IHsgYWN0aW9uOiBhY3Rpb25zLkhFQVJUQkVBVCB9O1xuICAgIGlmIChpZClcbiAgICAgIG1zZy5pZCA9IGlkO1xuICAgIHRoaXMuc2VuZChmcm9tVmFsdWVzKG1zZykpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiVHJhbnNwb3J0LmRpc3Bvc2UoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgIHRoaXMub2ZmKCk7XG4gIH1cbiAgb25BY3Rpdml0eSgpIHtcbiAgICBpZiAoIXRoaXMubWF4SWRsZUludGVydmFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdEFjdGl2aXR5ID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5sYXN0QWN0aXZpdHkgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuc2V0SWRsZVRpbWVyKHRoaXMubWF4SWRsZUludGVydmFsICsgMTAwKTtcbiAgfVxuICBzZXRJZGxlVGltZXIodGltZW91dCkge1xuICAgIGlmICghdGhpcy5pZGxlVGltZXIpIHtcbiAgICAgIHRoaXMuaWRsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMub25JZGxlVGltZXJFeHBpcmUoKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBvbklkbGVUaW1lckV4cGlyZSgpIHtcbiAgICBpZiAoIXRoaXMubGFzdEFjdGl2aXR5IHx8ICF0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0Lm9uSWRsZVRpbWVyRXhwaXJlKCk6IGxhc3RBY3Rpdml0eS9tYXhJZGxlSW50ZXJ2YWwgbm90IHNldFwiKTtcbiAgICB9XG4gICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgIGNvbnN0IHNpbmNlTGFzdCA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RBY3Rpdml0eTtcbiAgICBjb25zdCB0aW1lUmVtYWluaW5nID0gdGhpcy5tYXhJZGxlSW50ZXJ2YWwgLSBzaW5jZUxhc3Q7XG4gICAgaWYgKHRpbWVSZW1haW5pbmcgPD0gMCkge1xuICAgICAgY29uc3QgbXNnID0gXCJObyBhY3Rpdml0eSBzZWVuIGZyb20gcmVhbHRpbWUgaW4gXCIgKyBzaW5jZUxhc3QgKyBcIm1zOyBhc3N1bWluZyBjb25uZWN0aW9uIGhhcyBkcm9wcGVkXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJUcmFuc3BvcnQub25JZGxlVGltZXJFeHBpcmUoKVwiLCBtc2cpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KG5ldyBFcnJvckluZm8obXNnLCA4MDAwMywgNDA4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0SWRsZVRpbWVyKHRpbWVSZW1haW5pbmcgKyAxMDApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgdHJ5Q29ubmVjdCh0cmFuc3BvcnRDdG9yLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgdHJhbnNwb3J0UGFyYW1zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRDdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCB0cmFuc3BvcnRQYXJhbXMpO1xuICAgIGxldCB0cmFuc3BvcnRBdHRlbXB0VGltZXI7XG4gICAgY29uc3QgZXJyb3JDYiA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRyYW5zcG9ydEF0dGVtcHRUaW1lcik7XG4gICAgICBjYWxsYmFjayh7IGV2ZW50OiB0aGlzLmV2ZW50LCBlcnJvcjogZXJyIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVhbHRpbWVSZXF1ZXN0VGltZW91dCA9IGNvbm5lY3Rpb25NYW5hZ2VyLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dDtcbiAgICB0cmFuc3BvcnRBdHRlbXB0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRyYW5zcG9ydC5vZmYoW1wicHJlY29ubmVjdFwiLCBcImRpc2Nvbm5lY3RlZFwiLCBcImZhaWxlZFwiXSk7XG4gICAgICB0cmFuc3BvcnQuZGlzcG9zZSgpO1xuICAgICAgZXJyb3JDYi5jYWxsKFxuICAgICAgICB7IGV2ZW50OiBcImRpc2Nvbm5lY3RlZFwiIH0sXG4gICAgICAgIG5ldyBFcnJvckluZm8oXCJUaW1lb3V0IHdhaXRpbmcgZm9yIHRyYW5zcG9ydCB0byBpbmRpY2F0ZSBpdHNlbGYgdmlhYmxlXCIsIDVlNCwgNTAwKVxuICAgICAgKTtcbiAgICB9LCByZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcbiAgICB0cmFuc3BvcnQub24oW1wiZmFpbGVkXCIsIFwiZGlzY29ubmVjdGVkXCJdLCBlcnJvckNiKTtcbiAgICB0cmFuc3BvcnQub24oXCJwcmVjb25uZWN0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJUcmFuc3BvcnQudHJ5Q29ubmVjdCgpXCIsXG4gICAgICAgIFwidmlhYmxlIHRyYW5zcG9ydCBcIiArIHRyYW5zcG9ydFxuICAgICAgKTtcbiAgICAgIGNsZWFyVGltZW91dCh0cmFuc3BvcnRBdHRlbXB0VGltZXIpO1xuICAgICAgdHJhbnNwb3J0Lm9mZihbXCJmYWlsZWRcIiwgXCJkaXNjb25uZWN0ZWRcIl0sIGVycm9yQ2IpO1xuICAgICAgY2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcbiAgICB9KTtcbiAgICB0cmFuc3BvcnQuY29ubmVjdCgpO1xuICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gIH1cbiAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xuICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJpc0F2YWlsYWJsZSBub3QgaW1wbGVtZW50ZWQgZm9yIHRyYW5zcG9ydFwiLCA1ZTQsIDUwMCk7XG4gIH1cbn07XG52YXIgdHJhbnNwb3J0X2RlZmF1bHQgPSBUcmFuc3BvcnQ7XG5cbi8vIHNyYy9jb21tb24vY29uc3RhbnRzL1RyYW5zcG9ydE5hbWUudHNcbnZhciBUcmFuc3BvcnROYW1lcztcbigoVHJhbnNwb3J0TmFtZXMyKSA9PiB7XG4gIFRyYW5zcG9ydE5hbWVzMi5XZWJTb2NrZXQgPSBcIndlYl9zb2NrZXRcIjtcbiAgVHJhbnNwb3J0TmFtZXMyLkNvbWV0ID0gXCJjb21ldFwiO1xuICBUcmFuc3BvcnROYW1lczIuWGhyUG9sbGluZyA9IFwieGhyX3BvbGxpbmdcIjtcbn0pKFRyYW5zcG9ydE5hbWVzIHx8IChUcmFuc3BvcnROYW1lcyA9IHt9KSk7XG5cbi8vIHNyYy9jb21tb24vbGliL3RyYW5zcG9ydC9jb25uZWN0aW9ubWFuYWdlci50c1xudmFyIGdsb2JhbE9iamVjdDIgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG52YXIgaGF2ZVdlYlN0b3JhZ2UgPSAoKSA9PiB7XG4gIHZhciBfYTI7XG4gIHJldHVybiB0eXBlb2YgUGxhdGZvcm0uV2ViU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubG9jYWxTdXBwb3J0ZWQpO1xufTtcbnZhciBoYXZlU2Vzc2lvblN0b3JhZ2UgPSAoKSA9PiB7XG4gIHZhciBfYTI7XG4gIHJldHVybiB0eXBlb2YgUGxhdGZvcm0uV2ViU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2Vzc2lvblN1cHBvcnRlZCk7XG59O1xudmFyIG5vb3AyID0gZnVuY3Rpb24oKSB7XG59O1xudmFyIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lID0gXCJhYmx5LXRyYW5zcG9ydC1wcmVmZXJlbmNlXCI7XG5mdW5jdGlvbiBidW5kbGVXaXRoKGRlc3QsIHNyYywgbWF4U2l6ZSkge1xuICBsZXQgYWN0aW9uO1xuICBpZiAoZGVzdC5jaGFubmVsICE9PSBzcmMuY2hhbm5lbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKGFjdGlvbiA9IGRlc3QuYWN0aW9uKSAhPT0gYWN0aW9ucy5QUkVTRU5DRSAmJiBhY3Rpb24gIT09IGFjdGlvbnMuTUVTU0FHRSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYWN0aW9uICE9PSBzcmMuYWN0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtpbmQgPSBhY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0UgPyBcInByZXNlbmNlXCIgOiBcIm1lc3NhZ2VzXCIsIHByb3Bvc2VkID0gZGVzdFtraW5kXS5jb25jYXQoc3JjW2tpbmRdKSwgc2l6ZSA9IGdldE1lc3NhZ2VzU2l6ZShwcm9wb3NlZCk7XG4gIGlmIChzaXplID4gbWF4U2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWFsbFNhbWUocHJvcG9zZWQsIFwiY2xpZW50SWRcIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFwcm9wb3NlZC5ldmVyeShmdW5jdGlvbihtc2cpIHtcbiAgICByZXR1cm4gIW1zZy5pZDtcbiAgfSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVzdFtraW5kXSA9IHByb3Bvc2VkO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlY29kZVJlY292ZXJ5S2V5KHJlY292ZXJ5S2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmVjb3ZlcnlLZXkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbnZhciBUcmFuc3BvcnRQYXJhbXMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGhvc3QsIG1vZGUsIGNvbm5lY3Rpb25LZXkpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uS2V5O1xuICAgIHRoaXMuZm9ybWF0ID0gb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFwibXNncGFja1wiIC8qIG1zZ3BhY2sgKi8gOiBcImpzb25cIiAvKiBqc29uICovO1xuICB9XG4gIGdldENvbm5lY3RQYXJhbXMoYXV0aFBhcmFtcykge1xuICAgIGNvbnN0IHBhcmFtcyA9IGF1dGhQYXJhbXMgPyBjb3B5KGF1dGhQYXJhbXMpIDoge307XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgY2FzZSBcInJlc3VtZVwiOlxuICAgICAgICBwYXJhbXMucmVzdW1lID0gdGhpcy5jb25uZWN0aW9uS2V5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZWNvdmVyXCI6IHtcbiAgICAgICAgY29uc3QgcmVjb3ZlcnlDb250ZXh0ID0gZGVjb2RlUmVjb3ZlcnlLZXkob3B0aW9ucy5yZWNvdmVyKTtcbiAgICAgICAgaWYgKHJlY292ZXJ5Q29udGV4dCkge1xuICAgICAgICAgIHBhcmFtcy5yZWNvdmVyID0gcmVjb3ZlcnlDb250ZXh0LmNvbm5lY3Rpb25LZXk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jbGllbnRJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbXMuY2xpZW50SWQgPSBvcHRpb25zLmNsaWVudElkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lY2hvTWVzc2FnZXMgPT09IGZhbHNlKSB7XG4gICAgICBwYXJhbXMuZWNobyA9IFwiZmFsc2VcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZm9ybWF0ICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtcy5mb3JtYXQgPSB0aGlzLmZvcm1hdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RyZWFtICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtcy5zdHJlYW0gPSB0aGlzLnN0cmVhbTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGVhcnRiZWF0cyAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbXMuaGVhcnRiZWF0cyA9IHRoaXMuaGVhcnRiZWF0cztcbiAgICB9XG4gICAgcGFyYW1zLnYgPSBkZWZhdWx0c19kZWZhdWx0LnByb3RvY29sVmVyc2lvbjtcbiAgICBwYXJhbXMuYWdlbnQgPSBnZXRBZ2VudFN0cmluZyh0aGlzLm9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zcG9ydFBhcmFtcyAhPT0gdm9pZCAwKSB7XG4gICAgICBtaXhpbihwYXJhbXMsIG9wdGlvbnMudHJhbnNwb3J0UGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJbbW9kZT1cIiArIHRoaXMubW9kZTtcbiAgICBpZiAodGhpcy5ob3N0KSB7XG4gICAgICByZXN1bHQgKz0gXCIsaG9zdD1cIiArIHRoaXMuaG9zdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbktleSkge1xuICAgICAgcmVzdWx0ICs9IFwiLGNvbm5lY3Rpb25LZXk9XCIgKyB0aGlzLmNvbm5lY3Rpb25LZXk7XG4gICAgfVxuICAgIGlmICh0aGlzLmZvcm1hdCkge1xuICAgICAgcmVzdWx0ICs9IFwiLGZvcm1hdD1cIiArIHRoaXMuZm9ybWF0O1xuICAgIH1cbiAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbnZhciBDb25uZWN0aW9uTWFuYWdlciA9IGNsYXNzIF9Db25uZWN0aW9uTWFuYWdlciBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocmVhbHRpbWUsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihyZWFsdGltZS5sb2dnZXIpO1xuICAgIHRoaXMuc3VwcG9ydGVkVHJhbnNwb3J0cyA9IHt9O1xuICAgIHRoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCA9IDA7XG4gICAgdGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUgPSB7IGlzUHJvY2Vzc2luZzogZmFsc2UsIHF1ZXVlOiBbXSB9O1xuICAgIHRoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcbiAgICB0aGlzLmluaXRUcmFuc3BvcnRzKCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBjb25zdCB0aW1lb3V0cyA9IG9wdGlvbnMudGltZW91dHM7XG4gICAgY29uc3QgY29ubmVjdGluZ1RpbWVvdXQgPSB0aW1lb3V0cy53ZWJTb2NrZXRDb25uZWN0VGltZW91dCArIHRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG4gICAgdGhpcy5zdGF0ZXMgPSB7XG4gICAgICBpbml0aWFsaXplZDoge1xuICAgICAgICBzdGF0ZTogXCJpbml0aWFsaXplZFwiLFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgIHF1ZXVlRXZlbnRzOiB0cnVlLFxuICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgZmFpbFN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiXG4gICAgICB9LFxuICAgICAgY29ubmVjdGluZzoge1xuICAgICAgICBzdGF0ZTogXCJjb25uZWN0aW5nXCIsXG4gICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgcXVldWVFdmVudHM6IHRydWUsXG4gICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICByZXRyeURlbGF5OiBjb25uZWN0aW5nVGltZW91dCxcbiAgICAgICAgZmFpbFN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiXG4gICAgICB9LFxuICAgICAgY29ubmVjdGVkOiB7XG4gICAgICAgIHN0YXRlOiBcImNvbm5lY3RlZFwiLFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgIHF1ZXVlRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgc2VuZEV2ZW50czogdHJ1ZSxcbiAgICAgICAgZmFpbFN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiXG4gICAgICB9LFxuICAgICAgZGlzY29ubmVjdGVkOiB7XG4gICAgICAgIHN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgIHF1ZXVlRXZlbnRzOiB0cnVlLFxuICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgcmV0cnlEZWxheTogdGltZW91dHMuZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0LFxuICAgICAgICBmYWlsU3RhdGU6IFwiZGlzY29ubmVjdGVkXCJcbiAgICAgIH0sXG4gICAgICBzdXNwZW5kZWQ6IHtcbiAgICAgICAgc3RhdGU6IFwic3VzcGVuZGVkXCIsXG4gICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgcXVldWVFdmVudHM6IGZhbHNlLFxuICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgcmV0cnlEZWxheTogdGltZW91dHMuc3VzcGVuZGVkUmV0cnlUaW1lb3V0LFxuICAgICAgICBmYWlsU3RhdGU6IFwic3VzcGVuZGVkXCJcbiAgICAgIH0sXG4gICAgICBjbG9zaW5nOiB7XG4gICAgICAgIHN0YXRlOiBcImNsb3NpbmdcIixcbiAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICBxdWV1ZUV2ZW50czogZmFsc2UsXG4gICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICByZXRyeURlbGF5OiB0aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0LFxuICAgICAgICBmYWlsU3RhdGU6IFwiY2xvc2VkXCJcbiAgICAgIH0sXG4gICAgICBjbG9zZWQ6IHsgc3RhdGU6IFwiY2xvc2VkXCIsIHRlcm1pbmFsOiB0cnVlLCBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IGZhbHNlLCBmYWlsU3RhdGU6IFwiY2xvc2VkXCIgfSxcbiAgICAgIGZhaWxlZDogeyBzdGF0ZTogXCJmYWlsZWRcIiwgdGVybWluYWw6IHRydWUsIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIGZhaWxTdGF0ZTogXCJmYWlsZWRcIiB9XG4gICAgfTtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMuaW5pdGlhbGl6ZWQ7XG4gICAgdGhpcy5lcnJvclJlYXNvbiA9IG51bGw7XG4gICAgdGhpcy5xdWV1ZWRNZXNzYWdlcyA9IG5ldyBtZXNzYWdlcXVldWVfZGVmYXVsdCh0aGlzLmxvZ2dlcik7XG4gICAgdGhpcy5tc2dTZXJpYWwgPSAwO1xuICAgIHRoaXMuY29ubmVjdGlvbkRldGFpbHMgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25uZWN0aW9uSWQgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25uZWN0aW9uS2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuY29ubmVjdGlvblN0YXRlVHRsID0gdGltZW91dHMuY29ubmVjdGlvblN0YXRlVHRsO1xuICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydHMgPSBpbnRlcnNlY3Qob3B0aW9ucy50cmFuc3BvcnRzIHx8IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFRyYW5zcG9ydHMsIHRoaXMuc3VwcG9ydGVkVHJhbnNwb3J0cyk7XG4gICAgdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gbnVsbDtcbiAgICBpZiAodGhpcy50cmFuc3BvcnRzLmluY2x1ZGVzKFRyYW5zcG9ydE5hbWVzLldlYlNvY2tldCkpIHtcbiAgICAgIHRoaXMud2ViU29ja2V0VHJhbnNwb3J0QXZhaWxhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMudHJhbnNwb3J0cy5pbmNsdWRlcyhUcmFuc3BvcnROYW1lcy5YaHJQb2xsaW5nKSkge1xuICAgICAgdGhpcy5iYXNlVHJhbnNwb3J0ID0gVHJhbnNwb3J0TmFtZXMuWGhyUG9sbGluZztcbiAgICB9IGVsc2UgaWYgKHRoaXMudHJhbnNwb3J0cy5pbmNsdWRlcyhUcmFuc3BvcnROYW1lcy5Db21ldCkpIHtcbiAgICAgIHRoaXMuYmFzZVRyYW5zcG9ydCA9IFRyYW5zcG9ydE5hbWVzLkNvbWV0O1xuICAgIH1cbiAgICB0aGlzLmh0dHBIb3N0cyA9IGRlZmF1bHRzX2RlZmF1bHQuZ2V0SG9zdHMob3B0aW9ucyk7XG4gICAgdGhpcy53c0hvc3RzID0gZGVmYXVsdHNfZGVmYXVsdC5nZXRIb3N0cyhvcHRpb25zLCB0cnVlKTtcbiAgICB0aGlzLmFjdGl2ZVByb3RvY29sID0gbnVsbDtcbiAgICB0aGlzLmhvc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RBY3Rpdml0eSA9IG51bGw7XG4gICAgdGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IGZhbHNlO1xuICAgIHRoaXMuY29ubmVjdENvdW50ZXIgPSAwO1xuICAgIHRoaXMud3NDaGVja1Jlc3VsdCA9IG51bGw7XG4gICAgdGhpcy53ZWJTb2NrZXRTbG93VGltZXIgPSBudWxsO1xuICAgIHRoaXMud2ViU29ja2V0R2l2ZVVwVGltZXIgPSBudWxsO1xuICAgIHRoaXMuYWJhbmRvbmVkV2ViU29ja2V0ID0gZmFsc2U7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKVwiLCBcInN0YXJ0ZWRcIik7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKClcIixcbiAgICAgIFwicmVxdWVzdGVkIHRyYW5zcG9ydHMgPSBbXCIgKyAob3B0aW9ucy50cmFuc3BvcnRzIHx8IGRlZmF1bHRzX2RlZmF1bHQuZGVmYXVsdFRyYW5zcG9ydHMpICsgXCJdXCJcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsXG4gICAgICBcImF2YWlsYWJsZSB0cmFuc3BvcnRzID0gW1wiICsgdGhpcy50cmFuc3BvcnRzICsgXCJdXCJcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsXG4gICAgICBcImh0dHAgaG9zdHMgPSBbXCIgKyB0aGlzLmh0dHBIb3N0cyArIFwiXVwiXG4gICAgKTtcbiAgICBpZiAoIXRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwibm8gcmVxdWVzdGVkIHRyYW5zcG9ydHMgYXZhaWxhYmxlXCI7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJyZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpXCIsIG1zZyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgY29uc3QgYWRkRXZlbnRMaXN0ZW5lciA9IFBsYXRmb3JtLkNvbmZpZy5hZGRFdmVudExpc3RlbmVyO1xuICAgIGlmIChhZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBpZiAoaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgdHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgdGhpcy5wZXJzaXN0Q29ubmVjdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmNsb3NlT25VbmxvYWQgPT09IHRydWUpIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgICAgICBcIlJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKClcIixcbiAgICAgICAgICAgIFwiYmVmb3JldW5sb2FkIGV2ZW50IGhhcyB0cmlnZ2VyZWQgdGhlIGNvbm5lY3Rpb24gdG8gY2xvc2UgYXMgY2xvc2VPblVubG9hZCBpcyB0cnVlXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6IFwiY2xvc2luZ1wiIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgKCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5kaXNjb25uZWN0ZWQgfHwgdGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5zdXNwZW5kZWQpIHtcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIgY2F1Z2h0IGJyb3dzZXIgXFx1MjAxOG9ubGluZVxcdTIwMTkgZXZlbnRcIixcbiAgICAgICAgICAgIFwicmVhdHRlbXB0aW5nIGNvbm5lY3Rpb25cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgKF9hMiA9IHRoaXMucGVuZGluZ1RyYW5zcG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5vZmYoKTtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICAgICAgdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCkge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBjYXVnaHQgYnJvd3NlciBcXHUyMDE4b2ZmbGluZVxcdTIwMTkgZXZlbnRcIixcbiAgICAgICAgICAgIFwiZGlzY29ubmVjdGluZyBhY3RpdmUgdHJhbnNwb3J0XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKioqKioqKioqKioqKioqKioqKipcbiAgICogdHJhbnNwb3J0IG1hbmFnZW1lbnRcbiAgICoqKioqKioqKioqKioqKioqKioqKi9cbiAgLy8gVXNlZCBieSB0ZXN0c1xuICBzdGF0aWMgc3VwcG9ydGVkVHJhbnNwb3J0cyhhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHsgc3VwcG9ydGVkVHJhbnNwb3J0czoge30gfTtcbiAgICB0aGlzLmluaXRUcmFuc3BvcnRzKGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMsIHN0b3JhZ2UpO1xuICAgIHJldHVybiBzdG9yYWdlLnN1cHBvcnRlZFRyYW5zcG9ydHM7XG4gIH1cbiAgc3RhdGljIGluaXRUcmFuc3BvcnRzKGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMsIHN0b3JhZ2UpIHtcbiAgICBjb25zdCBpbXBsZW1lbnRhdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgUGxhdGZvcm0uVHJhbnNwb3J0cy5idW5kbGVkSW1wbGVtZW50YXRpb25zKSwgYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucyk7XG4gICAgW1RyYW5zcG9ydE5hbWVzLldlYlNvY2tldCwgLi4uUGxhdGZvcm0uVHJhbnNwb3J0cy5vcmRlcl0uZm9yRWFjaCgodHJhbnNwb3J0TmFtZSkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gaW1wbGVtZW50YXRpb25zW3RyYW5zcG9ydE5hbWVdO1xuICAgICAgaWYgKHRyYW5zcG9ydCAmJiB0cmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICBzdG9yYWdlLnN1cHBvcnRlZFRyYW5zcG9ydHNbdHJhbnNwb3J0TmFtZV0gPSB0cmFuc3BvcnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaW5pdFRyYW5zcG9ydHMoKSB7XG4gICAgX0Nvbm5lY3Rpb25NYW5hZ2VyLmluaXRUcmFuc3BvcnRzKHRoaXMucmVhbHRpbWUuX2FkZGl0aW9uYWxUcmFuc3BvcnRJbXBsZW1lbnRhdGlvbnMsIHRoaXMpO1xuICB9XG4gIGNyZWF0ZVRyYW5zcG9ydFBhcmFtcyhob3N0LCBtb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc3BvcnRQYXJhbXModGhpcy5vcHRpb25zLCBob3N0LCBtb2RlLCB0aGlzLmNvbm5lY3Rpb25LZXkpO1xuICB9XG4gIGdldFRyYW5zcG9ydFBhcmFtcyhjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlY2lkZU1vZGUgPSAobW9kZUNiKSA9PiB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0aW9uS2V5KSB7XG4gICAgICAgIG1vZGVDYihcInJlc3VtZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucmVjb3ZlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtb2RlQ2IoXCJyZWNvdmVyXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZWNvdmVyRm4gPSB0aGlzLm9wdGlvbnMucmVjb3ZlciwgbGFzdFNlc3Npb25EYXRhID0gdGhpcy5nZXRTZXNzaW9uUmVjb3ZlckRhdGEoKSwgc2Vzc2lvblJlY292ZXJ5TmFtZSA9IHRoaXMuc2Vzc2lvblJlY292ZXJ5TmFtZSgpO1xuICAgICAgaWYgKGxhc3RTZXNzaW9uRGF0YSAmJiB0eXBlb2YgcmVjb3ZlckZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpXCIsXG4gICAgICAgICAgXCJDYWxsaW5nIGNsaWVudE9wdGlvbnMtcHJvdmlkZWQgcmVjb3ZlciBmdW5jdGlvbiB3aXRoIGxhc3Qgc2Vzc2lvbiBkYXRhIChyZWNvdmVyeSBzY29wZTogXCIgKyBzZXNzaW9uUmVjb3ZlcnlOYW1lICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmVjb3ZlckZuKGxhc3RTZXNzaW9uRGF0YSwgKHNob3VsZFJlY292ZXIpID0+IHtcbiAgICAgICAgICBpZiAoc2hvdWxkUmVjb3Zlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJlY292ZXIgPSBsYXN0U2Vzc2lvbkRhdGEucmVjb3ZlcnlLZXk7XG4gICAgICAgICAgICBtb2RlQ2IoXCJyZWNvdmVyXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlQ2IoXCJjbGVhblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtb2RlQ2IoXCJjbGVhblwiKTtcbiAgICB9O1xuICAgIGRlY2lkZU1vZGUoKG1vZGUpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydFBhcmFtcyA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0UGFyYW1zKG51bGwsIG1vZGUpO1xuICAgICAgaWYgKG1vZGUgPT09IFwicmVjb3ZlclwiKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKVwiLFxuICAgICAgICAgIFwiVHJhbnNwb3J0IHJlY292ZXJ5IG1vZGUgPSByZWNvdmVyOyByZWNvdmVyeUtleSA9IFwiICsgdGhpcy5vcHRpb25zLnJlY292ZXJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVjb3ZlcnlDb250ZXh0ID0gZGVjb2RlUmVjb3ZlcnlLZXkodGhpcy5vcHRpb25zLnJlY292ZXIpO1xuICAgICAgICBpZiAocmVjb3ZlcnlDb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5tc2dTZXJpYWwgPSByZWNvdmVyeUNvbnRleHQubXNnU2VyaWFsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKClcIixcbiAgICAgICAgICBcIlRyYW5zcG9ydCBwYXJhbXMgPSBcIiArIHRyYW5zcG9ydFBhcmFtcy50b1N0cmluZygpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayh0cmFuc3BvcnRQYXJhbXMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGNvbm5lY3QgdXNpbmcgYSBnaXZlbiB0cmFuc3BvcnRcbiAgICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuICAgKiBAcGFyYW0gY2FuZGlkYXRlLCB0aGUgdHJhbnNwb3J0IHRvIHRyeVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpXCIsIFwidHJ5aW5nIFwiICsgY2FuZGlkYXRlKTtcbiAgICB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0ID0gdHJhbnNwb3J0X2RlZmF1bHQudHJ5Q29ubmVjdChcbiAgICAgIHRoaXMuc3VwcG9ydGVkVHJhbnNwb3J0c1tjYW5kaWRhdGVdLFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMucmVhbHRpbWUuYXV0aCxcbiAgICAgIHRyYW5zcG9ydFBhcmFtcyxcbiAgICAgICh3cmFwcGVkRXJyLCB0cmFuc3BvcnQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2luZyB8fCBzdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zZWQgfHwgc3RhdGUgPT0gdGhpcy5zdGF0ZXMuZmFpbGVkKSB7XG4gICAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKVwiLFxuICAgICAgICAgICAgICBcImNvbm5lY3Rpb24gXCIgKyBzdGF0ZS5zdGF0ZSArIFwiIHdoaWxlIHdlIHdlcmUgYXR0ZW1wdGluZyB0aGUgdHJhbnNwb3J0OyBjbG9zaW5nIFwiICsgdHJhbnNwb3J0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcHBlZEVycikge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KClcIixcbiAgICAgICAgICAgIFwidHJhbnNwb3J0IFwiICsgY2FuZGlkYXRlICsgXCIgXCIgKyB3cmFwcGVkRXJyLmV2ZW50ICsgXCIsIGVycjogXCIgKyB3cmFwcGVkRXJyLmVycm9yLnRvU3RyaW5nKClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChhdXRoX2RlZmF1bHQuaXNUb2tlbkVycih3cmFwcGVkRXJyLmVycm9yKSAmJiAhKHRoaXMuZXJyb3JSZWFzb24gJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gd3JhcHBlZEVyci5lcnJvcjtcbiAgICAgICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyh0aGlzLnJlYWx0aW1lLmF1dGguX2ZvcmNlTmV3VG9rZW4obnVsbCwgbnVsbCksIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgY2FuZGlkYXRlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBwZWRFcnIuZXZlbnQgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJmYWlsZWRcIiwgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3IgfSk7XG4gICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBwZWRFcnIuZXZlbnQgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICAgIGlmICghaXNSZXRyaWFibGUod3JhcHBlZEVyci5lcnJvcikpIHtcbiAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSwgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3IgfSk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKVwiLFxuICAgICAgICAgIFwidmlhYmxlIHRyYW5zcG9ydCBcIiArIGNhbmRpZGF0ZSArIFwiOyBzZXR0aW5nIHBlbmRpbmdcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLnNldFRyYW5zcG9ydFBlbmRpbmcodHJhbnNwb3J0LCB0cmFuc3BvcnRQYXJhbXMpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIGluZGljYXRlZCB0byBiZSB2aWFibGUsIGFuZCB0aGUgQ29ubmVjdGlvbk1hbmFnZXJcbiAgICogZXhwZWN0cyB0byBhY3RpdmF0ZSB0aGlzIHRyYW5zcG9ydCBhcyBzb29uIGFzIGl0IGlzIGNvbm5lY3RlZC5cbiAgICogQHBhcmFtIHRyYW5zcG9ydFxuICAgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG4gICAqL1xuICBzZXRUcmFuc3BvcnRQZW5kaW5nKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKSB7XG4gICAgY29uc3QgbW9kZSA9IHRyYW5zcG9ydFBhcmFtcy5tb2RlO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5zZXRUcmFuc3BvcnRQZW5kaW5nKClcIixcbiAgICAgIFwidHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnQgKyBcIjsgbW9kZSA9IFwiICsgbW9kZVxuICAgICk7XG4gICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0U2xvd1RpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgIHRyYW5zcG9ydC5vbmNlKFwiY29ubmVjdGVkXCIsIChlcnJvciwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykgPT4ge1xuICAgICAgdGhpcy5hY3RpdmF0ZVRyYW5zcG9ydChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKTtcbiAgICAgIGlmIChtb2RlID09PSBcInJlY292ZXJcIiAmJiB0aGlzLm9wdGlvbnMucmVjb3Zlcikge1xuICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLnJlY292ZXI7XG4gICAgICAgIHRoaXMudW5wZXJzaXN0Q29ubmVjdGlvbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICB0cmFuc3BvcnQub24oW1wiZGlzY29ubmVjdGVkXCIsIFwiY2xvc2VkXCIsIFwiZmFpbGVkXCJdLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgc2VsZjIuZGVhY3RpdmF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRoaXMuZXZlbnQsIGVycm9yKTtcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoXCJ0cmFuc3BvcnQucGVuZGluZ1wiLCB0cmFuc3BvcnQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQsIGFuZCB0aGUgY29ubmVjdGlvbm1hbmFnZXIgZGVjaWRlcyB0aGF0XG4gICAqIGl0IHdpbGwgbm93IGJlIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGl0IGFjdGl2YXRlZFxuICAgKiB0aGUgdHJhbnNwb3J0IChpZiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nL2Nsb3NlZCBpdCB3aWxsIGNob29zZSBub3QgdG8pLlxuICAgKiBAcGFyYW0gdHJhbnNwb3J0IHRoZSB0cmFuc3BvcnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCB0aGUgaWQgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuICAgKiBAcGFyYW0gY29ubmVjdGlvbkRldGFpbHMgdGhlIGRldGFpbHMgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuICAgKi9cbiAgYWN0aXZhdGVUcmFuc3BvcnQoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICBcInRyYW5zcG9ydCA9IFwiICsgdHJhbnNwb3J0XG4gICAgKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KClcIiwgXCJlcnJvciA9IFwiICsgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoY29ubmVjdGlvbklkKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcImNvbm5lY3Rpb25JZCA9ICBcIiArIGNvbm5lY3Rpb25JZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcImNvbm5lY3Rpb25EZXRhaWxzID0gIFwiICsgSlNPTi5zdHJpbmdpZnkoY29ubmVjdGlvbkRldGFpbHMpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKHRyYW5zcG9ydCk7XG4gICAgY29uc3QgZXhpc3RpbmdTdGF0ZSA9IHRoaXMuc3RhdGUsIGNvbm5lY3RlZFN0YXRlID0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICBcImN1cnJlbnQgc3RhdGUgPSBcIiArIGV4aXN0aW5nU3RhdGUuc3RhdGVcbiAgICApO1xuICAgIGlmIChleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3Npbmcuc3RhdGUgfHwgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zZWQuc3RhdGUgfHwgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5mYWlsZWQuc3RhdGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgIFwiRGlzY29ubmVjdGluZyB0cmFuc3BvcnQgYW5kIGFiYW5kb25pbmdcIlxuICAgICAgKTtcbiAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFuc3BvcnQ7XG4gICAgaWYgKCF0cmFuc3BvcnQuaXNDb25uZWN0ZWQpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgIFwiRGVjbGluaW5nIHRvIGFjdGl2YXRlIHRyYW5zcG9ydCBcIiArIHRyYW5zcG9ydCArIFwiIHNpbmNlIGl0IGFwcGVhcnMgdG8gbm8gbG9uZ2VyIGJlIGNvbm5lY3RlZFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0FjdGl2ZVByb3RvY29sID0gdGhpcy5hY3RpdmVQcm90b2NvbDtcbiAgICB0aGlzLmFjdGl2ZVByb3RvY29sID0gbmV3IHByb3RvY29sX2RlZmF1bHQodHJhbnNwb3J0KTtcbiAgICB0aGlzLmhvc3QgPSB0cmFuc3BvcnQucGFyYW1zLmhvc3Q7XG4gICAgY29uc3QgY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25LZXk7XG4gICAgaWYgKGNvbm5lY3Rpb25LZXkgJiYgdGhpcy5jb25uZWN0aW9uS2V5ICE9IGNvbm5lY3Rpb25LZXkpIHtcbiAgICAgIHRoaXMuc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCAhIWVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xuICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICB0cmFuc3BvcnQub24oXG4gICAgICAgIFwiY29ubmVjdGVkXCIsXG4gICAgICAgIChjb25uZWN0ZWRFcnIsIF9jb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzMikgPT4ge1xuICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlsczIsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfZGVmYXVsdChjb25uZWN0ZWRTdGF0ZSwgY29ubmVjdGVkU3RhdGUsIG51bGwsIGNvbm5lY3RlZEVycikpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICAgIGlmIChleGlzdGluZ1N0YXRlLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gZXJyb3I7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQoY29ubmVjdGVkU3RhdGUsIGNvbm5lY3RlZFN0YXRlLCBudWxsLCBlcnJvcikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiY29ubmVjdGVkXCIsIGVycm9yIH0pO1xuICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IGVycm9yIHx8IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydC5hY3RpdmVcIiwgdHJhbnNwb3J0KTtcbiAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgPiAwKSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsXG4gICAgICAgICAgXCJQcmV2aW91cyBhY3RpdmUgcHJvdG9jb2wgKGZvciB0cmFuc3BvcnQgXCIgKyBleGlzdGluZ0FjdGl2ZVByb3RvY29sLnRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIiwgbmV3IG9uZSBpcyBcIiArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIikgZmluaXNoaW5nIHdpdGggXCIgKyBleGlzdGluZ0FjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpICsgXCIgbWVzc2FnZXMgc3RpbGwgcGVuZGluZ1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbC50cmFuc3BvcnQgPT09IHRyYW5zcG9ydCkge1xuICAgICAgICBjb25zdCBtc2cgPSBcIkFzc3VtcHRpb24gdmlvbGF0ZWQ6IGFjdGl2YXRpbmcgYSB0cmFuc3BvcnQgdGhhdCB3YXMgYWxzbyB0aGUgdHJhbnNwb3J0IGZvciB0aGUgcHJldmlvdXMgYWN0aXZlIHByb3RvY29sOyB0cmFuc3BvcnQgPSBcIiArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyBcIjsgc3RhY2sgPSBcIiArIG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpXCIsIG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZ0FjdGl2ZVByb3RvY29sLmZpbmlzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgbm8gbG9uZ2VyIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBUaGlzIGNhbiBvY2N1clxuICAgKiBpbiBhbnkgdHJhbnNwb3J0IGNvbm5lY3Rpb24gc3RhdGUuXG4gICAqIEBwYXJhbSB0cmFuc3BvcnRcbiAgICovXG4gIGRlYWN0aXZhdGVUcmFuc3BvcnQodHJhbnNwb3J0LCBzdGF0ZSwgZXJyb3IpIHtcbiAgICBjb25zdCBjdXJyZW50UHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sLCB3YXNBY3RpdmUgPSBjdXJyZW50UHJvdG9jb2wgJiYgY3VycmVudFByb3RvY29sLmdldFRyYW5zcG9ydCgpID09PSB0cmFuc3BvcnQsIHdhc1BlbmRpbmcgPSB0cmFuc3BvcnQgPT09IHRoaXMucGVuZGluZ1RyYW5zcG9ydCwgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiA9IHRoaXMubm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbigpO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgIFwidHJhbnNwb3J0ID0gXCIgKyB0cmFuc3BvcnRcbiAgICApO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KClcIixcbiAgICAgIFwic3RhdGUgPSBcIiArIHN0YXRlICsgKHdhc0FjdGl2ZSA/IFwiOyB3YXMgYWN0aXZlXCIgOiB3YXNQZW5kaW5nID8gXCI7IHdhcyBwZW5kaW5nXCIgOiBcIlwiKSArIChub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID8gXCJcIiA6IFwiOyBhbm90aGVyIHRyYW5zcG9ydCBpcyBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb25cIilcbiAgICApO1xuICAgIGlmIChlcnJvciAmJiBlcnJvci5tZXNzYWdlKVxuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcInJlYXNvbiA9ICBcIiArIGVycm9yLm1lc3NhZ2VcbiAgICAgICk7XG4gICAgaWYgKHdhc0FjdGl2ZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKVwiLFxuICAgICAgICBcIkdldHRpbmcsIGNsZWFyaW5nLCBhbmQgcmVxdWV1aW5nIFwiICsgdGhpcy5hY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSArIFwiIHBlbmRpbmcgbWVzc2FnZXNcIlxuICAgICAgKTtcbiAgICAgIHRoaXMucXVldWVQZW5kaW5nTWVzc2FnZXMoY3VycmVudFByb3RvY29sLmdldFBlbmRpbmdNZXNzYWdlcygpKTtcbiAgICAgIGN1cnJlbnRQcm90b2NvbC5jbGVhclBlbmRpbmdNZXNzYWdlcygpO1xuICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbCA9IHRoaXMuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydC5pbmFjdGl2ZVwiLCB0cmFuc3BvcnQpO1xuICAgIGlmICh3YXNBY3RpdmUgJiYgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiB8fCB3YXNBY3RpdmUgJiYgc3RhdGUgPT09IFwiZmFpbGVkXCIgfHwgc3RhdGUgPT09IFwiY2xvc2VkXCIgfHwgY3VycmVudFByb3RvY29sID09PSBudWxsICYmIHdhc1BlbmRpbmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiAmJiBlcnJvciAmJiBlcnJvci5zdGF0dXNDb2RlID4gNTAwICYmIHRoaXMuaHR0cEhvc3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgICAgIHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSB0cnVlO1xuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGUsIGVycm9yLCByZXRyeUltbWVkaWF0ZWx5OiB0cnVlIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdDb25uZWN0aW9uU3RhdGUgPSBzdGF0ZSA9PT0gXCJmYWlsZWRcIiAmJiBhdXRoX2RlZmF1bHQuaXNUb2tlbkVycihlcnJvcikgPyBcImRpc2Nvbm5lY3RlZFwiIDogc3RhdGU7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IG5ld0Nvbm5lY3Rpb25TdGF0ZSwgZXJyb3IgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIC8qIEhlbHBlciB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgbm8gdHJhbnNwb3J0cyB3aGljaCBhcmUgcGVuZGluZyxcbiAgICogaGF2ZSBiZWVuIGNvbm5lY3RlZCwgYW5kIGFyZSBqdXN0IHdhaXRpbmcgZm9yIG9uY2VOb1BlbmRpbmcgdG8gZmlyZSBiZWZvcmVcbiAgICogYmVpbmcgYWN0aXZhdGVkICovXG4gIG5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLnBlbmRpbmdUcmFuc3BvcnQgfHwgIXRoaXMucGVuZGluZ1RyYW5zcG9ydC5pc0Nvbm5lY3RlZDtcbiAgfVxuICBzZXRDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIGhhc0Nvbm5lY3Rpb25FcnJvcikge1xuICAgIGNvbnN0IHByZXZDb25uSWQgPSB0aGlzLmNvbm5lY3Rpb25JZCwgY29ubklkQ2hhbmdlZCA9IHByZXZDb25uSWQgJiYgcHJldkNvbm5JZCAhPT0gY29ubmVjdGlvbklkLCByZWNvdmVyRmFpbHVyZSA9ICFwcmV2Q29ubklkICYmIGhhc0Nvbm5lY3Rpb25FcnJvcjtcbiAgICBpZiAoY29ubklkQ2hhbmdlZCB8fCByZWNvdmVyRmFpbHVyZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvbigpXCIsIFwiUmVzZXR0aW5nIG1zZ1NlcmlhbFwiKTtcbiAgICAgIHRoaXMubXNnU2VyaWFsID0gMDtcbiAgICAgIHRoaXMucXVldWVkTWVzc2FnZXMucmVzZXRTZW5kQXR0ZW1wdGVkKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25JZCAhPT0gY29ubmVjdGlvbklkKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvbigpXCIsXG4gICAgICAgIFwiTmV3IGNvbm5lY3Rpb25JZDsgcmVhdHRhY2hpbmcgYW55IGF0dGFjaGVkIGNoYW5uZWxzXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5pZCA9IHRoaXMuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5rZXkgPSB0aGlzLmNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uS2V5O1xuICB9XG4gIGNsZWFyQ29ubmVjdGlvbigpIHtcbiAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uaWQgPSB0aGlzLmNvbm5lY3Rpb25JZCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ua2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ID0gdm9pZCAwO1xuICAgIHRoaXMubXNnU2VyaWFsID0gMDtcbiAgICB0aGlzLnVucGVyc2lzdENvbm5lY3Rpb24oKTtcbiAgfVxuICBjcmVhdGVSZWNvdmVyeUtleSgpIHtcbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvbktleSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBjb25uZWN0aW9uS2V5OiB0aGlzLmNvbm5lY3Rpb25LZXksXG4gICAgICBtc2dTZXJpYWw6IHRoaXMubXNnU2VyaWFsLFxuICAgICAgY2hhbm5lbFNlcmlhbHM6IHRoaXMucmVhbHRpbWUuY2hhbm5lbHMuY2hhbm5lbFNlcmlhbHMoKVxuICAgIH0pO1xuICB9XG4gIGNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCkge1xuICAgIGlmICghdGhpcy5sYXN0QWN0aXZpdHkgfHwgIXRoaXMuY29ubmVjdGlvbklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNpbmNlTGFzdCA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RBY3Rpdml0eTtcbiAgICBpZiAoc2luY2VMYXN0ID4gdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgKyB0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKClcIixcbiAgICAgICAgXCJMYXN0IGtub3duIGFjdGl2aXR5IGZyb20gcmVhbHRpbWUgd2FzIFwiICsgc2luY2VMYXN0ICsgXCJtcyBhZ287IGRpc2NhcmRpbmcgY29ubmVjdGlvbiBzdGF0ZVwiXG4gICAgICApO1xuICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb24oKTtcbiAgICAgIHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gXCJzdXNwZW5kZWRcIjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuICAgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxuICAgKi9cbiAgcGVyc2lzdENvbm5lY3Rpb24oKSB7XG4gICAgaWYgKGhhdmVTZXNzaW9uU3RvcmFnZSgpKSB7XG4gICAgICBjb25zdCByZWNvdmVyeUtleSA9IHRoaXMuY3JlYXRlUmVjb3ZlcnlLZXkoKTtcbiAgICAgIGlmIChyZWNvdmVyeUtleSkge1xuICAgICAgICB0aGlzLnNldFNlc3Npb25SZWNvdmVyRGF0YSh7XG4gICAgICAgICAgcmVjb3ZlcnlLZXksXG4gICAgICAgICAgZGlzY29ubmVjdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgbG9jYXRpb246IGdsb2JhbE9iamVjdDIubG9jYXRpb24sXG4gICAgICAgICAgY2xpZW50SWQ6IHRoaXMucmVhbHRpbWUuYXV0aC5jbGllbnRJZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuICAgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxuICAgKi9cbiAgdW5wZXJzaXN0Q29ubmVjdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU2Vzc2lvblJlY292ZXJEYXRhKCk7XG4gIH1cbiAgLyoqKioqKioqKioqKioqKioqKioqKlxuICAgKiBzdGF0ZSBtYW5hZ2VtZW50XG4gICAqKioqKioqKioqKioqKioqKioqKiovXG4gIGdldEVycm9yKCkge1xuICAgIGlmICh0aGlzLmVycm9yUmVhc29uKSB7XG4gICAgICBjb25zdCBuZXdFcnJvciA9IFBhcnRpYWxFcnJvckluZm8uZnJvbVZhbHVlcyh0aGlzLmVycm9yUmVhc29uKTtcbiAgICAgIG5ld0Vycm9yLmNhdXNlID0gdGhpcy5lcnJvclJlYXNvbjtcbiAgICAgIHJldHVybiBuZXdFcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVFcnJvcigpO1xuICB9XG4gIGdldFN0YXRlRXJyb3IoKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYTIgPSBjb25uZWN0aW9uZXJyb3JzX2RlZmF1bHQpW3RoaXMuc3RhdGUuc3RhdGVdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIpO1xuICB9XG4gIGFjdGl2ZVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnF1ZXVlRXZlbnRzIHx8IHRoaXMuc3RhdGUuc2VuZEV2ZW50cztcbiAgfVxuICBlbmFjdFN0YXRlQ2hhbmdlKHN0YXRlQ2hhbmdlKSB7XG4gICAgY29uc3QgYWN0aW9uID0gXCJDb25uZWN0aW9uIHN0YXRlXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IHN0YXRlQ2hhbmdlLmN1cnJlbnQgKyAoc3RhdGVDaGFuZ2UucmVhc29uID8gXCI7IHJlYXNvbjogXCIgKyBzdGF0ZUNoYW5nZS5yZWFzb24gOiBcIlwiKTtcbiAgICBpZiAoc3RhdGVDaGFuZ2UuY3VycmVudCA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIGFjdGlvbiwgbWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01BSk9SLCBhY3Rpb24sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZW5hY3RTdGF0ZUNoYW5nZVwiLFxuICAgICAgXCJzZXR0aW5nIG5ldyBzdGF0ZTogXCIgKyBzdGF0ZUNoYW5nZS5jdXJyZW50ICsgXCI7IHJlYXNvbiA9IFwiICsgKHN0YXRlQ2hhbmdlLnJlYXNvbiAmJiBzdGF0ZUNoYW5nZS5yZWFzb24ubWVzc2FnZSlcbiAgICApO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlQ2hhbmdlLmN1cnJlbnRdO1xuICAgIGlmIChzdGF0ZUNoYW5nZS5yZWFzb24pIHtcbiAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG4gICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG4gICAgfVxuICAgIGlmIChuZXdTdGF0ZS50ZXJtaW5hbCB8fCBuZXdTdGF0ZS5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb24oKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbnN0YXRlXCIsIHN0YXRlQ2hhbmdlKTtcbiAgfVxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBDb25uZWN0aW9uTWFuYWdlciBjb25uZWN0aW9uIGxpZmVjeWNsZVxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgc3RhcnRUcmFuc2l0aW9uVGltZXIodHJhbnNpdGlvblN0YXRlKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0VHJhbnNpdGlvblRpbWVyKClcIixcbiAgICAgIFwidHJhbnNpdGlvblN0YXRlOiBcIiArIHRyYW5zaXRpb25TdGF0ZS5zdGF0ZVxuICAgICk7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uVGltZXIoKVwiLFxuICAgICAgICBcImNsZWFyaW5nIGFscmVhZHktcnVubmluZyB0aW1lclwiXG4gICAgICApO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHJhbnNpdGlvblRpbWVyKTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2l0aW9uVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25UaW1lcikge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBcIiArIHRyYW5zaXRpb25TdGF0ZS5zdGF0ZSArIFwiIHRpbWVyIGV4cGlyZWRcIixcbiAgICAgICAgICBcInJlcXVlc3RpbmcgbmV3IHN0YXRlOiBcIiArIHRyYW5zaXRpb25TdGF0ZS5mYWlsU3RhdGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0cmFuc2l0aW9uU3RhdGUuZmFpbFN0YXRlIH0pO1xuICAgICAgfVxuICAgIH0sIHRyYW5zaXRpb25TdGF0ZS5yZXRyeURlbGF5KTtcbiAgfVxuICBjYW5jZWxUcmFuc2l0aW9uVGltZXIoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuY2FuY2VsVHJhbnNpdGlvblRpbWVyKClcIiwgXCJcIik7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuICAgICAgdGhpcy50cmFuc2l0aW9uVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFN1c3BlbmRUaW1lcigpIHtcbiAgICBpZiAodGhpcy5zdXNwZW5kVGltZXIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5zdXNwZW5kVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN1c3BlbmRUaW1lcikge1xuICAgICAgICB0aGlzLnN1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBzdXNwZW5kIHRpbWVyIGV4cGlyZWRcIixcbiAgICAgICAgICBcInJlcXVlc3RpbmcgbmV3IHN0YXRlOiBzdXNwZW5kZWRcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9IFwic3VzcGVuZGVkXCI7XG4gICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJzdXNwZW5kZWRcIiB9KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCk7XG4gIH1cbiAgY2hlY2tTdXNwZW5kVGltZXIoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgIT09IFwiZGlzY29ubmVjdGVkXCIgJiYgc3RhdGUgIT09IFwic3VzcGVuZGVkXCIgJiYgc3RhdGUgIT09IFwiY29ubmVjdGluZ1wiKVxuICAgICAgdGhpcy5jYW5jZWxTdXNwZW5kVGltZXIoKTtcbiAgfVxuICBjYW5jZWxTdXNwZW5kVGltZXIoKSB7XG4gICAgdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIGlmICh0aGlzLnN1c3BlbmRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc3VzcGVuZFRpbWVyKTtcbiAgICAgIHRoaXMuc3VzcGVuZFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhcnRSZXRyeVRpbWVyKGludGVydmFsKSB7XG4gICAgdGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uTWFuYWdlciByZXRyeSB0aW1lciBleHBpcmVkXCIsIFwicmV0cnlpbmdcIik7XG4gICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gICAgfSwgaW50ZXJ2YWwpO1xuICB9XG4gIGNhbmNlbFJldHJ5VGltZXIoKSB7XG4gICAgaWYgKHRoaXMucmV0cnlUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG4gICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFdlYlNvY2tldFNsb3dUaW1lcigpIHtcbiAgICB0aGlzLndlYlNvY2tldFNsb3dUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgIFwiY2hlY2tpbmcgY29ubmVjdGl2aXR5XCJcbiAgICAgICk7XG4gICAgICB0aGlzLmNoZWNrV3NDb25uZWN0aXZpdHkoKS50aGVuKCgpID0+IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgICAgXCJ3cyBjb25uZWN0aXZpdHkgY2hlY2sgc3VjY2VlZGVkXCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy53c0NoZWNrUmVzdWx0ID0gdHJ1ZTtcbiAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NQUpPUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBzbG93IHRpbWVyXCIsXG4gICAgICAgICAgXCJ3cyBjb25uZWN0aXZpdHkgY2hlY2sgZmFpbGVkXCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy53c0NoZWNrUmVzdWx0ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnJlYWx0aW1lLmh0dHAuY2hlY2tDb25uZWN0aXZpdHkpIHtcbiAgICAgICAgd2hlblByb21pc2VTZXR0bGVzKHRoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpLCAoZXJyLCBjb25uZWN0aXZpdHkpID0+IHtcbiAgICAgICAgICBpZiAoZXJyIHx8ICFjb25uZWN0aXZpdHkpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NQUpPUixcbiAgICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBXZWJTb2NrZXQgc2xvdyB0aW1lclwiLFxuICAgICAgICAgICAgICBcImh0dHAgY29ubmVjdGl2aXR5IGNoZWNrIGZhaWxlZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7XG4gICAgICAgICAgICAgIHN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBjb25uZWN0IChuZXR3b3JrIHVucmVhY2hhYmxlKVwiLCA4MDAwMywgNDA0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlciBXZWJTb2NrZXQgc2xvdyB0aW1lclwiLFxuICAgICAgICAgICAgICBcImh0dHAgY29ubmVjdGl2aXR5IGNoZWNrIHN1Y2NlZWRlZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLndlYlNvY2tldFNsb3dUaW1lb3V0KTtcbiAgfVxuICBjYW5jZWxXZWJTb2NrZXRTbG93VGltZXIoKSB7XG4gICAgaWYgKHRoaXMud2ViU29ja2V0U2xvd1RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy53ZWJTb2NrZXRTbG93VGltZXIpO1xuICAgICAgdGhpcy53ZWJTb2NrZXRTbG93VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGFydFdlYlNvY2tldEdpdmVVcFRpbWVyKHRyYW5zcG9ydFBhcmFtcykge1xuICAgIHRoaXMud2ViU29ja2V0R2l2ZVVwVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgaWYgKCF0aGlzLndzQ2hlY2tSZXN1bHQpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBnaXZlIHVwIHRpbWVyXCIsXG4gICAgICAgICAgXCJ3ZWJzb2NrZXQgY29ubmVjdGlvbiB0b29rIG1vcmUgdGhhbiAxMHM7IFwiICsgKHRoaXMuYmFzZVRyYW5zcG9ydCA/IFwidHJ5aW5nIGJhc2UgdHJhbnNwb3J0XCIgOiBcIlwiKVxuICAgICAgICApO1xuICAgICAgICBpZiAodGhpcy5iYXNlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgdGhpcy5hYmFuZG9uZWRXZWJTb2NrZXQgPSB0cnVlO1xuICAgICAgICAgIChfYTIgPSB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAoX2IgPSB0aGlzLnBlbmRpbmdUcmFuc3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5kaXNwb3NlKCk7XG4gICAgICAgICAgdGhpcy5jb25uZWN0QmFzZSh0cmFuc3BvcnRQYXJhbXMsICsrdGhpcy5jb25uZWN0Q291bnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUFKT1IsXG4gICAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyIFdlYlNvY2tldCBnaXZlIHVwIHRpbWVyXCIsXG4gICAgICAgICAgICBcIndlYnNvY2tldCBjb25uZWN0aXZpdHkgYXBwZWFycyB0byBiZSB1bmF2YWlsYWJsZSBidXQgbm8gb3RoZXIgdHJhbnNwb3J0cyB0byB0cnlcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzLm9wdGlvbnMudGltZW91dHMud2ViU29ja2V0Q29ubmVjdFRpbWVvdXQpO1xuICB9XG4gIGNhbmNlbFdlYlNvY2tldEdpdmVVcFRpbWVyKCkge1xuICAgIGlmICh0aGlzLndlYlNvY2tldEdpdmVVcFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy53ZWJTb2NrZXRHaXZlVXBUaW1lcik7XG4gICAgICB0aGlzLndlYlNvY2tldEdpdmVVcFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgbm90aWZ5U3RhdGUoaW5kaWNhdGVkKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgY29uc3Qgc3RhdGUgPSBpbmRpY2F0ZWQuc3RhdGU7XG4gICAgY29uc3QgcmV0cnlJbW1lZGlhdGVseSA9IHN0YXRlID09PSBcImRpc2Nvbm5lY3RlZFwiICYmICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQgfHwgaW5kaWNhdGVkLnJldHJ5SW1tZWRpYXRlbHkgfHwgdGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZyAmJiBpbmRpY2F0ZWQuZXJyb3IgJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIoaW5kaWNhdGVkLmVycm9yKSAmJiAhKHRoaXMuZXJyb3JSZWFzb24gJiYgYXV0aF9kZWZhdWx0LmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKVwiLFxuICAgICAgXCJuZXcgc3RhdGU6IFwiICsgc3RhdGUgKyAocmV0cnlJbW1lZGlhdGVseSA/IFwiOyB3aWxsIHJldHJ5IGNvbm5lY3Rpb24gaW1tZWRpYXRlbHlcIiA6IFwiXCIpXG4gICAgKTtcbiAgICBpZiAoc3RhdGUgPT0gdGhpcy5zdGF0ZS5zdGF0ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsUmV0cnlUaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0U2xvd1RpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgIHRoaXMuY2hlY2tTdXNwZW5kVGltZXIoaW5kaWNhdGVkLnN0YXRlKTtcbiAgICBpZiAoc3RhdGUgPT09IFwic3VzcGVuZGVkXCIgfHwgc3RhdGUgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCA9IDA7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlLnRlcm1pbmFsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZXNbaW5kaWNhdGVkLnN0YXRlXTtcbiAgICBsZXQgcmV0cnlEZWxheSA9IG5ld1N0YXRlLnJldHJ5RGVsYXk7XG4gICAgaWYgKG5ld1N0YXRlLnN0YXRlID09PSBcImRpc2Nvbm5lY3RlZFwiKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQrKztcbiAgICAgIHJldHJ5RGVsYXkgPSBnZXRSZXRyeVRpbWUobmV3U3RhdGUucmV0cnlEZWxheSwgdGhpcy5kaXNjb25uZWN0ZWRSZXRyeUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlID0gbmV3IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV9kZWZhdWx0KFxuICAgICAgdGhpcy5zdGF0ZS5zdGF0ZSxcbiAgICAgIG5ld1N0YXRlLnN0YXRlLFxuICAgICAgcmV0cnlEZWxheSxcbiAgICAgIGluZGljYXRlZC5lcnJvciB8fCAoKF9iID0gKF9hMiA9IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdClbbmV3U3RhdGUuc3RhdGVdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIpKVxuICAgICk7XG4gICAgaWYgKHJldHJ5SW1tZWRpYXRlbHkpIHtcbiAgICAgIGNvbnN0IGF1dG9SZWNvbm5lY3QgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5kaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBzaW5jZUxhc3QgPSB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCAmJiBEYXRlLm5vdygpIC0gdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgKyAxO1xuICAgICAgaWYgKHNpbmNlTGFzdCAmJiBzaW5jZUxhc3QgPCAxZTMpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKClcIixcbiAgICAgICAgICBcIkxhc3QgcmVjb25uZWN0IGF0dGVtcHQgd2FzIG9ubHkgXCIgKyBzaW5jZUxhc3QgKyBcIm1zIGFnbywgd2FpdGluZyBhbm90aGVyIFwiICsgKDFlMyAtIHNpbmNlTGFzdCkgKyBcIm1zIGJlZm9yZSB0cnlpbmcgYWdhaW5cIlxuICAgICAgICApO1xuICAgICAgICBzZXRUaW1lb3V0KGF1dG9SZWNvbm5lY3QsIDFlMyAtIHNpbmNlTGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soYXV0b1JlY29ubmVjdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiB8fCBzdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgdGhpcy5zdGFydFJldHJ5VGltZXIocmV0cnlEZWxheSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiAmJiAhcmV0cnlJbW1lZGlhdGVseSB8fCBzdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIiB8fCBuZXdTdGF0ZS50ZXJtaW5hbCkge1xuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PSBcImNvbm5lY3RlZFwiICYmICF0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKVwiLFxuICAgICAgICBcIkJyb2tlbiBpbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBnbyBpbnRvIGNvbm5lY3RlZCBzdGF0ZSwgYnV0IHRoZXJlIGlzIG5vIGFjdGl2ZSBwcm90b2NvbFwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmVuYWN0U3RhdGVDaGFuZ2UoY2hhbmdlKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICB0aGlzLnNlbmRRdWV1ZWRNZXNzYWdlcygpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuc3RhdGUucXVldWVFdmVudHMpIHtcbiAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMucHJvcG9nYXRlQ29ubmVjdGlvbkludGVycnVwdGlvbihzdGF0ZSwgY2hhbmdlLnJlYXNvbik7XG4gICAgICB0aGlzLmZhaWxRdWV1ZWRNZXNzYWdlcyhjaGFuZ2UucmVhc29uKTtcbiAgICB9XG4gIH1cbiAgcmVxdWVzdFN0YXRlKHJlcXVlc3QpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBjb25zdCBzdGF0ZSA9IHJlcXVlc3Quc3RhdGU7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSgpXCIsXG4gICAgICBcInJlcXVlc3RlZCBzdGF0ZTogXCIgKyBzdGF0ZSArIFwiOyBjdXJyZW50IHN0YXRlOiBcIiArIHRoaXMuc3RhdGUuc3RhdGVcbiAgICApO1xuICAgIGlmIChzdGF0ZSA9PSB0aGlzLnN0YXRlLnN0YXRlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY2FuY2VsV2ViU29ja2V0U2xvd1RpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxXZWJTb2NrZXRHaXZlVXBUaW1lcigpO1xuICAgIHRoaXMuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCk7XG4gICAgdGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG4gICAgdGhpcy5jaGVja1N1c3BlbmRUaW1lcihzdGF0ZSk7XG4gICAgaWYgKHN0YXRlID09IFwiY29ubmVjdGluZ1wiICYmIHRoaXMuc3RhdGUuc3RhdGUgPT0gXCJjb25uZWN0ZWRcIilcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc3RhdGUgPT0gXCJjbG9zaW5nXCIgJiYgdGhpcy5zdGF0ZS5zdGF0ZSA9PSBcImNsb3NlZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZXNbc3RhdGVdLCBjaGFuZ2UgPSBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlX2RlZmF1bHQoXG4gICAgICB0aGlzLnN0YXRlLnN0YXRlLFxuICAgICAgbmV3U3RhdGUuc3RhdGUsXG4gICAgICBudWxsLFxuICAgICAgcmVxdWVzdC5lcnJvciB8fCAoKF9iID0gKF9hMiA9IGNvbm5lY3Rpb25lcnJvcnNfZGVmYXVsdClbbmV3U3RhdGUuc3RhdGVdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIpKVxuICAgICk7XG4gICAgdGhpcy5lbmFjdFN0YXRlQ2hhbmdlKGNoYW5nZSk7XG4gICAgaWYgKHN0YXRlID09IFwiY29ubmVjdGluZ1wiKSB7XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PSBcImNsb3NpbmdcIikge1xuICAgICAgdGhpcy5jbG9zZUltcGwoKTtcbiAgICB9XG4gIH1cbiAgc3RhcnRDb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRDb25uZWN0KClcIixcbiAgICAgICAgXCJNdXN0IGJlIGluIGNvbm5lY3Rpbmcgc3RhdGUgdG8gY29ubmVjdCwgYnV0IHdhcyBcIiArIHRoaXMuc3RhdGUuc3RhdGVcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF1dGggPSB0aGlzLnJlYWx0aW1lLmF1dGg7XG4gICAgY29uc3QgY29ubmVjdENvdW50ID0gKyt0aGlzLmNvbm5lY3RDb3VudGVyO1xuICAgIGNvbnN0IGNvbm5lY3QgPSAoKSA9PiB7XG4gICAgICB0aGlzLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCk7XG4gICAgICB0aGlzLmdldFRyYW5zcG9ydFBhcmFtcygodHJhbnNwb3J0UGFyYW1zKSA9PiB7XG4gICAgICAgIGlmICh0cmFuc3BvcnRQYXJhbXMubW9kZSA9PT0gXCJyZWNvdmVyXCIgJiYgdHJhbnNwb3J0UGFyYW1zLm9wdGlvbnMucmVjb3Zlcikge1xuICAgICAgICAgIGNvbnN0IHJlY292ZXJ5Q29udGV4dCA9IGRlY29kZVJlY292ZXJ5S2V5KHRyYW5zcG9ydFBhcmFtcy5vcHRpb25zLnJlY292ZXIpO1xuICAgICAgICAgIGlmIChyZWNvdmVyeUNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMucmVjb3ZlckNoYW5uZWxzKHJlY292ZXJ5Q29udGV4dC5jaGFubmVsU2VyaWFscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IHRoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0Q29ubmVjdCgpXCIsIFwic3RhcnRpbmcgY29ubmVjdGlvblwiKTtcbiAgICB0aGlzLnN0YXJ0U3VzcGVuZFRpbWVyKCk7XG4gICAgdGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jb25uZWN0aW5nKTtcbiAgICBpZiAoYXV0aC5tZXRob2QgPT09IFwiYmFzaWNcIikge1xuICAgICAgY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhdXRoQ2IgPSAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IHRoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRoaXMuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5lcnJvclJlYXNvbiAmJiBhdXRoX2RlZmF1bHQuaXNUb2tlbkVycih0aGlzLmVycm9yUmVhc29uKSkge1xuICAgICAgICB3aGVuUHJvbWlzZVNldHRsZXMoYXV0aC5fZm9yY2VOZXdUb2tlbihudWxsLCBudWxsKSwgYXV0aENiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoZW5Qcm9taXNlU2V0dGxlcyhhdXRoLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSksIGF1dGhDYik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIHRoZXJlIGFyZSwgYXQgbW9zdCwgdHdvIHRyYW5zcG9ydHMgYXZhaWxhYmxlIHdpdGggd2hpY2ggYSBjb25uZWN0aW9uIG1heVxuICAgKiBiZSBhdHRlbXB0ZWQ6IHdlYl9zb2NrZXQgYW5kL29yIGEgYmFzZSB0cmFuc3BvcnQgKHhocl9wb2xsaW5nIGluIGJyb3dzZXJzLFxuICAgKiBjb21ldCBpbiBub2RlanMpLiB3ZWJfc29ja2V0IGlzIGFsd2F5cyBwcmVmZXJyZWQsIGFuZCB0aGUgYmFzZSB0cmFuc3BvcnQgaXNcbiAgICogb25seSB1c2VkIGluIGNhc2Ugd2ViX3NvY2tldCBjb25uZWN0aXZpdHkgYXBwZWFycyB0byBiZSB1bmF2YWlsYWJsZS5cbiAgICpcbiAgICogY29ubmVjdEltcGwgYmVnaW5zIHRoZSB0cmFuc3BvcnQgc2VsZWN0aW9uIHByb2Nlc3MgYnkgY2hlY2tpbmcgd2hpY2ggdHJhbnNwb3J0c1xuICAgKiBhcmUgYXZhaWxhYmxlLCBhbmQgaWYgdGhlcmUgaXMgYSBjYWNoZWQgcHJlZmVyZW5jZS4gSXQgdGhlbiBkZWZlcnMgdG8gdGhlXG4gICAqIHRyYW5zcG9ydC1zcGVjaWZpYyBjb25uZWN0IG1ldGhvZHM6IGNvbm5lY3RXcyBhbmQgY29ubmVjdEJhc2UuXG4gICAqXG4gICAqIEl0IGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGludmFsaWRhdGluZyB0aGUgY2FjaGUgaW4gdGhlIGNhc2UgdGhhdCBhIGJhc2VcbiAgICogdHJhbnNwb3J0IHByZWZlcmVuY2UgaXMgc3RvcmVkIGJ1dCB3ZWIgc29ja2V0IGNvbm5lY3Rpdml0eSBpcyBub3cgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBoYW5kbGluZyBvZiB0aGUgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIGZhaWxvdmVyIGZyb20gd2ViX3NvY2tldCB0byB0aGUgYmFzZVxuICAgKiB0cmFuc3BvcnQgaXMgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbm5lY3RXcyBtZXRob2QuXG4gICAqL1xuICBjb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5zdGF0ZTtcbiAgICBpZiAoc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3Rpbmcuc3RhdGUpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpXCIsXG4gICAgICAgIFwiTXVzdCBiZSBpbiBjb25uZWN0aW5nIHN0YXRlIHRvIGNvbm5lY3QsIGJ1dCB3YXMgXCIgKyBzdGF0ZVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNwb3J0UHJlZmVyZW5jZSA9IHRoaXMuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgIGlmICh0cmFuc3BvcnRQcmVmZXJlbmNlICYmIHRyYW5zcG9ydFByZWZlcmVuY2UgPT09IHRoaXMuYmFzZVRyYW5zcG9ydCAmJiB0aGlzLndlYlNvY2tldFRyYW5zcG9ydEF2YWlsYWJsZSkge1xuICAgICAgdGhpcy5jaGVja1dzQ29ubmVjdGl2aXR5KCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZykge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpOlwiLFxuICAgICAgICAgICAgXCJ3ZWIgc29ja2V0IGNvbm5lY3Rpdml0eSBhdmFpbGFibGUsIGNhbmNlbGxpbmcgY29ubmVjdGlvbiBhdHRlbXB0IHdpdGggXCIgKyB0aGlzLmJhc2VUcmFuc3BvcnRcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RXcyh0cmFuc3BvcnRQYXJhbXMsICsrdGhpcy5jb25uZWN0Q291bnRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKG5vb3AyKTtcbiAgICB9XG4gICAgaWYgKHRyYW5zcG9ydFByZWZlcmVuY2UgJiYgdHJhbnNwb3J0UHJlZmVyZW5jZSA9PT0gdGhpcy5iYXNlVHJhbnNwb3J0IHx8IHRoaXMuYmFzZVRyYW5zcG9ydCAmJiAhdGhpcy53ZWJTb2NrZXRUcmFuc3BvcnRBdmFpbGFibGUpIHtcbiAgICAgIHRoaXMuY29ubmVjdEJhc2UodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbm5lY3RXcyh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIGNvbm5lY3RXcyBzdGFydHMgdHdvIHRpbWVycyB0byBtb25pdG9yIHRoZSBzdWNjZXNzIG9mIGEgd2ViX3NvY2tldCBjb25uZWN0aW9uIGF0dGVtcHQ6XG4gICAqIC0gd2ViU29ja2V0U2xvd1RpbWVyOiBpZiB0aGlzIHRpbWVyIGZpcmVzIGJlZm9yZSB0aGUgY29ubmVjdGlvbiBzdWNjZWVkcyxcbiAgICogICBjbSB3aWxsIHNpbXVsdGFuZW91c2x5IGNoZWNrIHdlYnNvY2tldCBhbmQgaHR0cC94aHIgY29ubmVjdGl2aXR5LiBpZiB0aGUgaHR0cFxuICAgKiAgIGNvbm5lY3Rpdml0eSBjaGVjayBmYWlscywgd2UgZ2l2ZSB1cCB0aGUgY29ubmVjdGlvbiBzZXF1ZW5jZSBlbnRpcmVseSBhbmRcbiAgICogICB0cmFuc2l0aW9uIHRvIGRpc2Nvbm5lY3RlZC4gaWYgdGhlIHdlYnNvY2tldCBjb25uZWN0aXZpdHkgY2hlY2sgZmFpbHMgdGhlblxuICAgKiAgIHdlIGFzc3VtZSBubyB3cyBjb25uZWN0aXZpdHkgYW5kIGZhaWxvdmVyIHRvIGJhc2UgdHJhbnNwb3J0LiBpbiB0aGUgY2FzZSB0aGF0XG4gICAqICAgdGhlIGNoZWNrcyBzdWNjZWVkLCB3ZSBjb250aW51ZSB3aXRoIHdlYnNvY2tldCBhbmQgd2FpdCBmb3IgaXQgdG8gdHJ5IGZhbGxiYWNrIGhvc3RzXG4gICAqICAgYW5kLCBpZiB1bnN1Y2Nlc3NmdWwsIHVsdGltYXRlbHkgdHJhbnNpdGlvbiB0byBkaXNjb25uZWN0ZWQuXG4gICAqIC0gd2ViU29ja2V0R2l2ZVVwVGltZXI6IGlmIHRoaXMgdGltZXIgZmlyZXMsIGFuZCB0aGUgcHJlY2VkaW5nIHdlYnNvY2tldFxuICAgKiAgIGNvbm5lY3Rpdml0eSBjaGVjayBpcyBzdGlsbCBwZW5kaW5nIHRoZW4gd2UgYXNzdW1lIHRoYXQgdGhlcmUgaXMgYW4gaXNzdWVcbiAgICogICB3aXRoIHRoZSB0cmFuc3BvcnQgYW5kIGZhbGxiYWNrIHRvIGJhc2UgdHJhbnNwb3J0LlxuICAgKi9cbiAgY29ubmVjdFdzKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdFdzKClcIik7XG4gICAgdGhpcy53c0NoZWNrUmVzdWx0ID0gbnVsbDtcbiAgICB0aGlzLmFiYW5kb25lZFdlYlNvY2tldCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRXZWJTb2NrZXRTbG93VGltZXIoKTtcbiAgICB0aGlzLnN0YXJ0V2ViU29ja2V0R2l2ZVVwVGltZXIodHJhbnNwb3J0UGFyYW1zKTtcbiAgICB0aGlzLnRyeVRyYW5zcG9ydFdpdGhGYWxsYmFja3MoXCJ3ZWJfc29ja2V0XCIsIHRyYW5zcG9ydFBhcmFtcywgdHJ1ZSwgY29ubmVjdENvdW50LCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy53c0NoZWNrUmVzdWx0ICE9PSBmYWxzZSAmJiAhdGhpcy5hYmFuZG9uZWRXZWJTb2NrZXQ7XG4gICAgfSk7XG4gIH1cbiAgY29ubmVjdEJhc2UodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0QmFzZSgpXCIpO1xuICAgIGlmICh0aGlzLmJhc2VUcmFuc3BvcnQpIHtcbiAgICAgIHRoaXMudHJ5VHJhbnNwb3J0V2l0aEZhbGxiYWNrcyh0aGlzLmJhc2VUcmFuc3BvcnQsIHRyYW5zcG9ydFBhcmFtcywgZmFsc2UsIGNvbm5lY3RDb3VudCwgKCkgPT4gdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoe1xuICAgICAgICBzdGF0ZTogXCJkaXNjb25uZWN0ZWRcIixcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvckluZm8oXCJObyB0cmFuc3BvcnRzIGxlZnQgdG8gdHJ5XCIsIDhlNCwgNDA0KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHRyeVRyYW5zcG9ydFdpdGhGYWxsYmFja3ModHJhbnNwb3J0TmFtZSwgdHJhbnNwb3J0UGFyYW1zLCB3cywgY29ubmVjdENvdW50LCBzaG91bGRDb250aW51ZSkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci50cnlUcmFuc3BvcnRXaXRoRmFsbGJhY2tzKClcIixcbiAgICAgIHRyYW5zcG9ydE5hbWVcbiAgICApO1xuICAgIGNvbnN0IGdpdmVVcCA9IChlcnIpID0+IHtcbiAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUsIGVycm9yOiBlcnIgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjYW5kaWRhdGVIb3N0cyA9IHdzID8gdGhpcy53c0hvc3RzLnNsaWNlKCkgOiB0aGlzLmh0dHBIb3N0cy5zbGljZSgpO1xuICAgIGNvbnN0IGhvc3RBdHRlbXB0Q2IgPSAoZmF0YWwsIHRyYW5zcG9ydCkgPT4ge1xuICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXNob3VsZENvbnRpbnVlKCkpIHtcbiAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgIHRyYW5zcG9ydC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0cmFuc3BvcnQgJiYgIWZhdGFsKSB7XG4gICAgICAgIHRyeUZhbGxiYWNrSG9zdHMoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhvc3QgPSBjYW5kaWRhdGVIb3N0cy5zaGlmdCgpO1xuICAgIGlmICghaG9zdCkge1xuICAgICAgZ2l2ZVVwKG5ldyBFcnJvckluZm8oXCJVbmFibGUgdG8gY29ubmVjdCAobm8gYXZhaWxhYmxlIGhvc3QpXCIsIDgwMDAzLCA0MDQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBob3N0O1xuICAgIGNvbnN0IHRyeUZhbGxiYWNrSG9zdHMgPSAoKSA9PiB7XG4gICAgICBpZiAoIWNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuICAgICAgICBnaXZlVXAobmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBjb25uZWN0IChhbmQgbm8gbW9yZSBmYWxsYmFjayBob3N0cyB0byB0cnkpXCIsIDgwMDAzLCA0MDQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lLmh0dHAuY2hlY2tDb25uZWN0aXZpdHkpIHtcbiAgICAgICAgZ2l2ZVVwKG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiSW50ZXJuYWwgZXJyb3I6IEh0dHAuY2hlY2tDb25uZWN0aXZpdHkgbm90IHNldFwiLCBudWxsLCA1MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hlblByb21pc2VTZXR0bGVzKFxuICAgICAgICB0aGlzLnJlYWx0aW1lLmh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKSxcbiAgICAgICAgKGVyciwgY29ubmVjdGl2aXR5KSA9PiB7XG4gICAgICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNob3VsZENvbnRpbnVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZ2l2ZVVwKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY29ubmVjdGl2aXR5KSB7XG4gICAgICAgICAgICBnaXZlVXAobmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBjb25uZWN0IChuZXR3b3JrIHVucmVhY2hhYmxlKVwiLCA4MDAwMywgNDA0KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYW5zcG9ydFBhcmFtcy5ob3N0ID0gYXJyUG9wUmFuZG9tRWxlbWVudChjYW5kaWRhdGVIb3N0cyk7XG4gICAgICAgICAgdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgdHJhbnNwb3J0TmFtZSwgaG9zdEF0dGVtcHRDYik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5mb3JjZUZhbGxiYWNrSG9zdCAmJiBjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSBmYWxzZTtcbiAgICAgIHRyeUZhbGxiYWNrSG9zdHMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgdHJhbnNwb3J0TmFtZSwgaG9zdEF0dGVtcHRDYik7XG4gIH1cbiAgY2xvc2VJbXBsKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpXCIsIFwiY2xvc2luZyBjb25uZWN0aW9uXCIpO1xuICAgIHRoaXMuY2FuY2VsU3VzcGVuZFRpbWVyKCk7XG4gICAgdGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jbG9zaW5nKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nVHJhbnNwb3J0KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKClcIixcbiAgICAgICAgXCJDbG9zaW5nIHBlbmRpbmcgdHJhbnNwb3J0OiBcIiArIHRoaXMucGVuZGluZ1RyYW5zcG9ydFxuICAgICAgKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hY3RpdmVQcm90b2NvbCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpXCIsXG4gICAgICAgIFwiQ2xvc2luZyBhY3RpdmUgdHJhbnNwb3J0OiBcIiArIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KClcbiAgICAgICk7XG4gICAgICB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogXCJjbG9zZWRcIiB9KTtcbiAgfVxuICBvbkF1dGhVcGRhdGVkKHRva2VuRGV0YWlscywgY2FsbGJhY2spIHtcbiAgICB2YXIgX2EyO1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS5zdGF0ZSkge1xuICAgICAgY2FzZSBcImNvbm5lY3RlZFwiOiB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKClcIixcbiAgICAgICAgICBcIlNlbmRpbmcgQVVUSCBtZXNzYWdlIG9uIGFjdGl2ZSB0cmFuc3BvcnRcIlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBhY3RpdmVUcmFuc3BvcnQgPSAoX2EyID0gdGhpcy5hY3RpdmVQcm90b2NvbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXRUcmFuc3BvcnQoKTtcbiAgICAgICAgaWYgKGFjdGl2ZVRyYW5zcG9ydCAmJiBhY3RpdmVUcmFuc3BvcnQub25BdXRoVXBkYXRlZCkge1xuICAgICAgICAgIGFjdGl2ZVRyYW5zcG9ydC5vbkF1dGhVcGRhdGVkKHRva2VuRGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXV0aE1zZyA9IGZyb21WYWx1ZXMoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9ucy5BVVRILFxuICAgICAgICAgIGF1dGg6IHtcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbmQoYXV0aE1zZyk7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLm9mZihmYWlsdXJlTGlzdGVuZXIpO1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZhaWx1cmVMaXN0ZW5lciA9IChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgICAgIGlmIChzdGF0ZUNoYW5nZS5jdXJyZW50ID09PSBcImZhaWxlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLm9mZihzdWNjZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5vZmYoZmFpbHVyZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCB0aGlzLmdldFN0YXRlRXJyb3IoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uY2UoXCJjb25uZWN0aW9uZGV0YWlsc1wiLCBzdWNjZXNzTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLm9uKFwiY29ubmVjdGlvbnN0YXRlXCIsIGZhaWx1cmVMaXN0ZW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImNvbm5lY3RpbmdcIjpcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKVwiLFxuICAgICAgICAgIFwiQWJvcnRpbmcgY3VycmVudCBjb25uZWN0aW9uIGF0dGVtcHRzIGluIG9yZGVyIHRvIHN0YXJ0IGFnYWluIHdpdGggdGhlIG5ldyBhdXRoIGRldGFpbHNcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgICAgXCJDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKClcIixcbiAgICAgICAgICBcIkNvbm5lY3Rpb24gc3RhdGUgaXMgXCIgKyB0aGlzLnN0YXRlLnN0YXRlICsgXCI7IHdhaXRpbmcgdW50aWwgZWl0aGVyIGNvbm5lY3RlZCBvciBmYWlsZWRcIlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoc3RhdGVDaGFuZ2UuY3VycmVudCkge1xuICAgICAgICAgICAgY2FzZSBcImNvbm5lY3RlZFwiOlxuICAgICAgICAgICAgICB0aGlzLm9mZihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImNsb3NlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInN1c3BlbmRlZFwiOlxuICAgICAgICAgICAgICB0aGlzLm9mZihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCB0aGlzLmdldFN0YXRlRXJyb3IoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uKFwiY29ubmVjdGlvbnN0YXRlXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdGUgPT09IFwiY29ubmVjdGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiBcImNvbm5lY3RpbmdcIiB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKVwiLFxuICAgICAgXCJEaXNjb25uZWN0aW5nIGFsbCB0cmFuc3BvcnRzXCJcbiAgICApO1xuICAgIHRoaXMuY29ubmVjdENvdW50ZXIrKztcbiAgICBpZiAodGhpcy5wZW5kaW5nVHJhbnNwb3J0KSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKVwiLFxuICAgICAgICBcIkRpc2Nvbm5lY3RpbmcgcGVuZGluZyB0cmFuc3BvcnQ6IFwiICsgdGhpcy5wZW5kaW5nVHJhbnNwb3J0XG4gICAgICApO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYW5zcG9ydDtcbiAgICBpZiAodGhpcy5wcm9wb3NlZFRyYW5zcG9ydCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKClcIixcbiAgICAgICAgXCJEaXNjb25uZWN0aW5nIHByb3Bvc2VkIHRyYW5zcG9ydDogXCIgKyB0aGlzLnBlbmRpbmdUcmFuc3BvcnRcbiAgICAgICk7XG4gICAgICB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYW5zcG9ydDtcbiAgICBpZiAodGhpcy5hY3RpdmVQcm90b2NvbCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKClcIixcbiAgICAgICAgXCJEaXNjb25uZWN0aW5nIGFjdGl2ZSB0cmFuc3BvcnQ6IFwiICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKVxuICAgICAgKTtcbiAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfVxuICAvKioqKioqKioqKioqKioqKioqXG4gICAqIGV2ZW50IHF1ZXVlaW5nXG4gICAqKioqKioqKioqKioqKioqKiovXG4gIHNlbmQobXNnLCBxdWV1ZUV2ZW50LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDI7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDb25uZWN0aW9uTWFuYWdlci5zZW5kKClcIiwgXCJzZW5kaW5nIGV2ZW50XCIpO1xuICAgICAgdGhpcy5zZW5kSW1wbChuZXcgUGVuZGluZ01lc3NhZ2UobXNnLCBjYWxsYmFjaykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRRdWV1ZSA9IHF1ZXVlRXZlbnQgJiYgc3RhdGUucXVldWVFdmVudHM7XG4gICAgaWYgKCFzaG91bGRRdWV1ZSkge1xuICAgICAgY29uc3QgZXJyID0gXCJyZWplY3RpbmcgZXZlbnQsIHF1ZXVlRXZlbnQgd2FzIFwiICsgcXVldWVFdmVudCArIFwiLCBzdGF0ZSB3YXMgXCIgKyBzdGF0ZS5zdGF0ZTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKVwiLCBlcnIpO1xuICAgICAgY2FsbGJhY2sodGhpcy5lcnJvclJlYXNvbiB8fCBuZXcgRXJyb3JJbmZvKGVyciwgOWU0LCA0MDApKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9nZ2VyLnNob3VsZExvZyhsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICAgIFwiQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpXCIsXG4gICAgICAgIFwicXVldWVpbmcgbXNnOyBcIiArIHN0cmluZ2lmeShtc2csIHRoaXMucmVhbHRpbWUuX1JlYWx0aW1lUHJlc2VuY2UsIHRoaXMucmVhbHRpbWUuX0Fubm90YXRpb25zKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5xdWV1ZShtc2csIGNhbGxiYWNrKTtcbiAgfVxuICBzZW5kSW1wbChwZW5kaW5nTWVzc2FnZSkge1xuICAgIGNvbnN0IG1zZyA9IHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2U7XG4gICAgaWYgKHBlbmRpbmdNZXNzYWdlLmFja1JlcXVpcmVkICYmICFwZW5kaW5nTWVzc2FnZS5zZW5kQXR0ZW1wdGVkKSB7XG4gICAgICBtc2cubXNnU2VyaWFsID0gdGhpcy5tc2dTZXJpYWwrKztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuc2VuZChwZW5kaW5nTWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNlbmRJbXBsKClcIixcbiAgICAgICAgXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiBpbiB0cmFuc3BvcnQuc2VuZCgpOiBcIiArIGUuc3RhY2tcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHF1ZXVlKG1zZywgY2FsbGJhY2spIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDb25uZWN0aW9uTWFuYWdlci5xdWV1ZSgpXCIsIFwicXVldWVpbmcgZXZlbnRcIik7XG4gICAgY29uc3QgbGFzdFF1ZXVlZCA9IHRoaXMucXVldWVkTWVzc2FnZXMubGFzdCgpO1xuICAgIGNvbnN0IG1heFNpemUgPSB0aGlzLm9wdGlvbnMubWF4TWVzc2FnZVNpemU7XG4gICAgaWYgKGxhc3RRdWV1ZWQgJiYgIWxhc3RRdWV1ZWQuc2VuZEF0dGVtcHRlZCAmJiBidW5kbGVXaXRoKGxhc3RRdWV1ZWQubWVzc2FnZSwgbXNnLCBtYXhTaXplKSkge1xuICAgICAgaWYgKCFsYXN0UXVldWVkLm1lcmdlZCkge1xuICAgICAgICBsYXN0UXVldWVkLmNhbGxiYWNrID0gbXVsdGljYXN0ZXJfZGVmYXVsdC5jcmVhdGUodGhpcy5sb2dnZXIsIFtsYXN0UXVldWVkLmNhbGxiYWNrXSk7XG4gICAgICAgIGxhc3RRdWV1ZWQubWVyZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxhc3RRdWV1ZWQuY2FsbGJhY2sucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucXVldWVkTWVzc2FnZXMucHVzaChuZXcgUGVuZGluZ01lc3NhZ2UobXNnLCBjYWxsYmFjaykpO1xuICAgIH1cbiAgfVxuICBzZW5kUXVldWVkTWVzc2FnZXMoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnNlbmRRdWV1ZWRNZXNzYWdlcygpXCIsXG4gICAgICBcInNlbmRpbmcgXCIgKyB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvdW50KCkgKyBcIiBxdWV1ZWQgbWVzc2FnZXNcIlxuICAgICk7XG4gICAgbGV0IHBlbmRpbmdNZXNzYWdlO1xuICAgIHdoaWxlIChwZW5kaW5nTWVzc2FnZSA9IHRoaXMucXVldWVkTWVzc2FnZXMuc2hpZnQoKSlcbiAgICAgIHRoaXMuc2VuZEltcGwocGVuZGluZ01lc3NhZ2UpO1xuICB9XG4gIHF1ZXVlUGVuZGluZ01lc3NhZ2VzKHBlbmRpbmdNZXNzYWdlcykge1xuICAgIGlmIChwZW5kaW5nTWVzc2FnZXMgJiYgcGVuZGluZ01lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnF1ZXVlUGVuZGluZ01lc3NhZ2VzKClcIixcbiAgICAgICAgXCJxdWV1ZWluZyBcIiArIHBlbmRpbmdNZXNzYWdlcy5sZW5ndGggKyBcIiBwZW5kaW5nIG1lc3NhZ2VzXCJcbiAgICAgICk7XG4gICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnByZXBlbmQocGVuZGluZ01lc3NhZ2VzKTtcbiAgICB9XG4gIH1cbiAgZmFpbFF1ZXVlZE1lc3NhZ2VzKGVycikge1xuICAgIGNvbnN0IG51bVF1ZXVlZCA9IHRoaXMucXVldWVkTWVzc2FnZXMuY291bnQoKTtcbiAgICBpZiAobnVtUXVldWVkID4gMCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLmZhaWxRdWV1ZWRNZXNzYWdlcygpXCIsXG4gICAgICAgIFwiZmFpbGluZyBcIiArIG51bVF1ZXVlZCArIFwiIHF1ZXVlZCBtZXNzYWdlcywgZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgKTtcbiAgICAgIHRoaXMucXVldWVkTWVzc2FnZXMuY29tcGxldGVBbGxNZXNzYWdlcyhlcnIpO1xuICAgIH1cbiAgfVxuICBvbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zcG9ydCkge1xuICAgIHRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlLnF1ZXVlLnB1c2goeyBtZXNzYWdlLCB0cmFuc3BvcnQgfSk7XG4gICAgaWYgKCF0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZS5pc1Byb2Nlc3NpbmcpIHtcbiAgICAgIHRoaXMucHJvY2Vzc05leHRQZW5kaW5nQ2hhbm5lbE1lc3NhZ2UoKTtcbiAgICB9XG4gIH1cbiAgcHJvY2Vzc05leHRQZW5kaW5nQ2hhbm5lbE1lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucGVuZGluZ0NoYW5uZWxNZXNzYWdlc1N0YXRlLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICBjb25zdCBwZW5kaW5nQ2hhbm5lbE1lc3NhZ2UgPSB0aGlzLnBlbmRpbmdDaGFubmVsTWVzc2FnZXNTdGF0ZS5xdWV1ZS5zaGlmdCgpO1xuICAgICAgdGhpcy5wcm9jZXNzQ2hhbm5lbE1lc3NhZ2UocGVuZGluZ0NoYW5uZWxNZXNzYWdlLm1lc3NhZ2UpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICBcIkNvbm5lY3Rpb25NYW5hZ2VyLnByb2Nlc3NOZXh0UGVuZGluZ0NoYW5uZWxNZXNzYWdlKCkgcmVjZWl2ZWQgZXJyb3IgXCIsXG4gICAgICAgICAgZXJyXG4gICAgICAgICk7XG4gICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2hhbm5lbE1lc3NhZ2VzU3RhdGUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvY2Vzc05leHRQZW5kaW5nQ2hhbm5lbE1lc3NhZ2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcm9jZXNzQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGF3YWl0IHRoaXMucmVhbHRpbWUuY2hhbm5lbHMucHJvY2Vzc0NoYW5uZWxNZXNzYWdlKG1lc3NhZ2UpO1xuICB9XG4gIGFzeW5jIHBpbmcoKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdGF0ZSAhPT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcIlVuYWJsZSB0byBwaW5nIHNlcnZpY2U7IG5vdCBjb25uZWN0ZWRcIiwgNGU0LCA0MDApO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc3BvcnQgPSAoX2EyID0gdGhpcy5hY3RpdmVQcm90b2NvbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXRUcmFuc3BvcnQoKTtcbiAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgdGhyb3cgdGhpcy5nZXRTdGF0ZUVycm9yKCk7XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLnBpbmcoKVwiLCBcInRyYW5zcG9ydCA9IFwiICsgdHJhbnNwb3J0KTtcbiAgICBjb25zdCBwaW5nU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGlkID0gY2hlYXBSYW5kU3RyKCk7XG4gICAgcmV0dXJuIHdpdGhUaW1lb3V0QXN5bmMoXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCBvbkhlYXJ0YmVhdCA9IChyZXNwb25zZUlkKSA9PiB7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlSWQgPT09IGlkKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQub2ZmKFwiaGVhcnRiZWF0XCIsIG9uSGVhcnRiZWF0KTtcbiAgICAgICAgICAgIHJlc29sdmUoRGF0ZS5ub3coKSAtIHBpbmdTdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0cmFuc3BvcnQub24oXCJoZWFydGJlYXRcIiwgb25IZWFydGJlYXQpO1xuICAgICAgICB0cmFuc3BvcnQucGluZyhpZCk7XG4gICAgICB9KSxcbiAgICAgIHRoaXMub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0LFxuICAgICAgXCJUaW1lb3V0IHdhaXRpbmcgZm9yIGhlYXJ0YmVhdCByZXNwb25zZVwiXG4gICAgKTtcbiAgfVxuICBhYm9ydChlcnJvcikge1xuICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuZmFpbChlcnJvcik7XG4gIH1cbiAgZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSgpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlIHx8IGhhdmVXZWJTdG9yYWdlKCkgJiYgKChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCB0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSkpO1xuICB9XG4gIHBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKHRyYW5zcG9ydCkge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IHRyYW5zcG9ydC5zaG9ydE5hbWU7XG4gICAgaWYgKGhhdmVXZWJTdG9yYWdlKCkpIHtcbiAgICAgIChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCB0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSwgdHJhbnNwb3J0LnNob3J0TmFtZSk7XG4gICAgfVxuICB9XG4gIHVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UoKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gbnVsbDtcbiAgICBpZiAoaGF2ZVdlYlN0b3JhZ2UoKSkge1xuICAgICAgKF9iID0gKF9hMiA9IFBsYXRmb3JtLldlYlN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucmVtb3ZlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lKTtcbiAgICB9XG4gIH1cbiAgLyogVGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGR1cmluZyBjb25uZWN0aW9uIGF0dGVtcHRzLCBzbyBpbXBsZW1lbnRzIFJTQTRjMSwgUlNBNGMyLFxuICAgKiBhbmQgUlNBNGQuIEl0IGlzIGdlbmVyYWxseSBub3QgaW52b2tlZCBmb3Igc2VydmVyc2lkZS10cmlnZ2VyZWQgcmVhdXRocyBvciBtYW51YWxcbiAgICogcmVhdXRocywgc28gUlNBNGMzIGRvZXMgbm90IGFwcGx5LCBleGNlcHQgKHBlciBwZXIgUlNBNGQxKSBpbiB0aGUgY2FzZSB0aGF0IHRoZSBhdXRoXG4gICAqIHNlcnZlciByZXR1cm5zIDQwMy4gKi9cbiAgYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlID09PSA0MDE3MSkge1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBcImZhaWxlZFwiLCBlcnJvcjogZXJyIH0pO1xuICAgIH0gZWxzZSBpZiAoZXJyLmNvZGUgPT09IDQwMTAyKSB7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IFwiZmFpbGVkXCIsIGVycm9yOiBlcnIgfSk7XG4gICAgfSBlbHNlIGlmIChlcnIuc3RhdHVzQ29kZSA9PT0gSHR0cFN0YXR1c0NvZGVzX2RlZmF1bHQuRm9yYmlkZGVuKSB7XG4gICAgICBjb25zdCBtc2cgPSBcIkNsaWVudCBjb25maWd1cmVkIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHJldHVybmVkIDQwMzsgZmFpbGluZyB0aGUgY29ubmVjdGlvblwiO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemUoKVwiLCBtc2cpO1xuICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBcImZhaWxlZFwiLCBlcnJvcjogbmV3IEVycm9ySW5mbyhtc2csIDgwMDE5LCA0MDMsIGVycikgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiQ2xpZW50IGNvbmZpZ3VyZWQgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgcmVxdWVzdCBmYWlsZWRcIjtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplXCIsIG1zZyk7XG4gICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IHRoaXMuc3RhdGUuZmFpbFN0YXRlLCBlcnJvcjogbmV3IEVycm9ySW5mbyhtc2csIDgwMDE5LCA0MDEsIGVycikgfSk7XG4gICAgfVxuICB9XG4gIG9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUoY29ubmVjdGlvbkRldGFpbHMsIHRyYW5zcG9ydCkge1xuICAgIGlmICghY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aW9uRGV0YWlscyA9IGNvbm5lY3Rpb25EZXRhaWxzO1xuICAgIGlmIChjb25uZWN0aW9uRGV0YWlscy5tYXhNZXNzYWdlU2l6ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLm1heE1lc3NhZ2VTaXplID0gY29ubmVjdGlvbkRldGFpbHMubWF4TWVzc2FnZVNpemU7XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudElkID0gY29ubmVjdGlvbkRldGFpbHMuY2xpZW50SWQ7XG4gICAgaWYgKGNsaWVudElkKSB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLnJlYWx0aW1lLmF1dGguX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiQ29ubmVjdGlvbk1hbmFnZXIub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZSgpXCIsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgdHJhbnNwb3J0LmZhaWwoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uU3RhdGVUdGwgPSBjb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uU3RhdGVUdGw7XG4gICAgaWYgKGNvbm5lY3Rpb25TdGF0ZVR0bCkge1xuICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgPSBjb25uZWN0aW9uU3RhdGVUdGw7XG4gICAgfVxuICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gY29ubmVjdGlvbkRldGFpbHMubWF4SWRsZUludGVydmFsO1xuICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25kZXRhaWxzXCIsIGNvbm5lY3Rpb25EZXRhaWxzKTtcbiAgfVxuICBjaGVja1dzQ29ubmVjdGl2aXR5KCkge1xuICAgIGNvbnN0IHdzQ29ubmVjdGl2aXR5Q2hlY2tVcmwgPSB0aGlzLm9wdGlvbnMud3NDb25uZWN0aXZpdHlDaGVja1VybCB8fCBkZWZhdWx0c19kZWZhdWx0LndzQ29ubmVjdGl2aXR5Q2hlY2tVcmw7XG4gICAgY29uc3Qgd3MgPSBuZXcgUGxhdGZvcm0uQ29uZmlnLldlYlNvY2tldCh3c0Nvbm5lY3Rpdml0eUNoZWNrVXJsKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG4gICAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIHdzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3cy5vbmNsb3NlID0gd3Mub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFmaW5pc2hlZCkge1xuICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBzZXNzaW9uUmVjb3ZlcnlOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmVjb3ZlcnlLZXlTdG9yYWdlTmFtZSB8fCBcImFibHktY29ubmVjdGlvbi1yZWNvdmVyeVwiO1xuICB9XG4gIGdldFNlc3Npb25SZWNvdmVyRGF0YSgpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgKChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFNlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdGhpcy5zZXNzaW9uUmVjb3ZlcnlOYW1lKCkpKTtcbiAgfVxuICBzZXRTZXNzaW9uUmVjb3ZlckRhdGEodmFsdWUpIHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgKChfYiA9IChfYTIgPSBQbGF0Zm9ybS5XZWJTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNldFNlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdGhpcy5zZXNzaW9uUmVjb3ZlcnlOYW1lKCksIHZhbHVlKSk7XG4gIH1cbiAgY2xlYXJTZXNzaW9uUmVjb3ZlckRhdGEoKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgcmV0dXJuIGhhdmVTZXNzaW9uU3RvcmFnZSgpICYmICgoX2IgPSAoX2EyID0gUGxhdGZvcm0uV2ViU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZW1vdmVTZXNzaW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHRoaXMuc2Vzc2lvblJlY292ZXJ5TmFtZSgpKSk7XG4gIH1cbn07XG52YXIgY29ubmVjdGlvbm1hbmFnZXJfZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvY29ubmVjdGlvbi50c1xudmFyIENvbm5lY3Rpb24gPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoYWJseSwgb3B0aW9ucykge1xuICAgIHN1cGVyKGFibHkubG9nZ2VyKTtcbiAgICB0aGlzLndoZW5TdGF0ZSA9IChzdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIGV2ZW50ZW1pdHRlcl9kZWZhdWx0LnByb3RvdHlwZS53aGVuU3RhdGUuY2FsbCh0aGlzLCBzdGF0ZSwgdGhpcy5zdGF0ZSk7XG4gICAgfTtcbiAgICB0aGlzLmFibHkgPSBhYmx5O1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgY29ubmVjdGlvbm1hbmFnZXJfZGVmYXVsdChhYmx5LCBvcHRpb25zKTtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zdGF0ZTtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub24oXCJjb25uZWN0aW9uc3RhdGVcIiwgKHN0YXRlQ2hhbmdlKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUgPSBzdGF0ZUNoYW5nZS5jdXJyZW50O1xuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KHN0YXRlLCBzdGF0ZUNoYW5nZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKFwidXBkYXRlXCIsIChzdGF0ZUNoYW5nZSkgPT4ge1xuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHN0YXRlQ2hhbmdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbi5jb25uZWN0KClcIiwgXCJcIik7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogXCJjb25uZWN0aW5nXCIgfSk7XG4gIH1cbiAgYXN5bmMgcGluZygpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb25uZWN0aW9uLnBpbmcoKVwiLCBcIlwiKTtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5waW5nKCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29ubmVjdGlvbi5jbG9zZSgpXCIsIFwiY29ubmVjdGlvbktleSA9IFwiICsgdGhpcy5rZXkpO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKHsgc3RhdGU6IFwiY2xvc2luZ1wiIH0pO1xuICB9XG4gIGdldCByZWNvdmVyeUtleSgpIHtcbiAgICB0aGlzLmxvZ2dlci5kZXByZWNhdGlvbldhcm5pbmcoXG4gICAgICBcIlRoZSBgQ29ubmVjdGlvbi5yZWNvdmVyeUtleWAgYXR0cmlidXRlIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IHRoZSBgQ29ubmVjdGlvbi5jcmVhdGVSZWNvdmVyeUtleSgpYCBtZXRob2QuIFJlcGxhY2UgeW91ciB1c2FnZSBvZiBgcmVjb3ZlcnlLZXlgIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiBgY3JlYXRlUmVjb3ZlcnlLZXkoKWAuIGByZWNvdmVyeUtleWAgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVJlY292ZXJ5S2V5KCk7XG4gIH1cbiAgY3JlYXRlUmVjb3ZlcnlLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY3JlYXRlUmVjb3ZlcnlLZXkoKTtcbiAgfVxufTtcbnZhciBjb25uZWN0aW9uX2RlZmF1bHQgPSBDb25uZWN0aW9uO1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvYmFzZXJlYWx0aW1lLnRzXG52YXIgX0Jhc2VSZWFsdGltZSA9IGNsYXNzIF9CYXNlUmVhbHRpbWUgZXh0ZW5kcyBiYXNlY2xpZW50X2RlZmF1bHQge1xuICAvKlxuICAgKiBUaGUgcHVibGljIHR5cGluZ3MgZGVjbGFyZSB0aGF0IHRoaXMgb25seSBhY2NlcHRzIGFuIG9iamVjdCwgYnV0IHNpbmNlIHdlIHdhbnQgdG8gZW1pdCBhIGdvb2QgZXJyb3IgbWVzc2FnZSBpbiB0aGUgY2FzZSB3aGVyZSBhIG5vbi1UeXBlU2NyaXB0IHVzZXIgZG9lcyBvbmUgb2YgdGhlc2UgdGhpbmdzOlxuICAgKlxuICAgKiAxLiBwYXNzZXMgYSBzdHJpbmcgKHdoaWNoIGlzIHF1aXRlIGxpa2VseSBpZiB0aGV54oCZcmUgZS5nLiBtaWdyYXRpbmcgZnJvbSB0aGUgZGVmYXVsdCB2YXJpYW50IHRvIHRoZSBtb2R1bGFyIHZhcmlhbnQpXG4gICAqIDIuIHBhc3NlcyBubyBhcmd1bWVudCBhdCBhbGxcbiAgICpcbiAgICogdGVsbCB0aGUgY29tcGlsZXIgdGhhdCB0aGVzZSBjYXNlcyBhcmUgcG9zc2libGUgc28gdGhhdCBpdCBmb3JjZXMgdXMgdG8gaGFuZGxlIHRoZW0uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgc3VwZXIoZGVmYXVsdHNfZGVmYXVsdC5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMsIGZhbHNlLCBcIkJhc2VSZWFsdGltZVwiLCBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyKSk7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiUmVhbHRpbWUoKVwiLCBcIlwiKTtcbiAgICBpZiAodHlwZW9mIEVkZ2VSdW50aW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBgQWJseS5SZWFsdGltZSBpbnN0YW5jZSBjYW5ub3QgYmUgdXNlZCBpbiBWZXJjZWwgRWRnZSBydW50aW1lLiBJZiB5b3UgYXJlIHJ1bm5pbmcgVmVyY2VsIEVkZ2UgZnVuY3Rpb25zLCBwbGVhc2UgcmVwbGFjZSB5b3VyIFwibmV3IEFibHkuUmVhbHRpbWUoKVwiIHdpdGggXCJuZXcgQWJseS5SZXN0KClcIiBhbmQgdXNlIEFibHkgUmVzdCBBUEkgaW5zdGVhZCBvZiB0aGUgUmVhbHRpbWUgQVBJLiBJZiB5b3UgYXJlIHNlcnZlci1yZW5kZXJpbmcgeW91ciBhcHBsaWNhdGlvbiBpbiB0aGUgVmVyY2VsIEVkZ2UgcnVudGltZSwgcGxlYXNlIHVzZSB0aGUgY29uZGl0aW9uIFwiaWYgKHR5cGVvZiBFZGdlUnVudGltZSA9PT0gJ3N0cmluZycpXCIgdG8gcHJldmVudCBpbnN0YW50aWF0aW5nIEFibHkuUmVhbHRpbWUgaW5zdGFuY2UgZHVyaW5nIFNTUiBpbiB0aGUgVmVyY2VsIEVkZ2UgcnVudGltZS5gLFxuICAgICAgICA0ZTQsXG4gICAgICAgIDQwMFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5fYWRkaXRpb25hbFRyYW5zcG9ydEltcGxlbWVudGF0aW9ucyA9IF9CYXNlUmVhbHRpbWUudHJhbnNwb3J0SW1wbGVtZW50YXRpb25zRnJvbVBsdWdpbnModGhpcy5vcHRpb25zLnBsdWdpbnMpO1xuICAgIHRoaXMuX1JlYWx0aW1lUHJlc2VuY2UgPSAoX2IgPSAoX2EyID0gdGhpcy5vcHRpb25zLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuUmVhbHRpbWVQcmVzZW5jZSkgIT0gbnVsbCA/IF9iIDogbnVsbDtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgY29ubmVjdGlvbl9kZWZhdWx0KHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5fY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHMyKHRoaXMpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlKVxuICAgICAgdGhpcy5jb25uZWN0KCk7XG4gIH1cbiAgc3RhdGljIHRyYW5zcG9ydEltcGxlbWVudGF0aW9uc0Zyb21QbHVnaW5zKHBsdWdpbnMpIHtcbiAgICBjb25zdCB0cmFuc3BvcnRzID0ge307XG4gICAgaWYgKHBsdWdpbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsdWdpbnMuV2ViU29ja2V0VHJhbnNwb3J0KSB7XG4gICAgICB0cmFuc3BvcnRzW1RyYW5zcG9ydE5hbWVzLldlYlNvY2tldF0gPSBwbHVnaW5zLldlYlNvY2tldFRyYW5zcG9ydDtcbiAgICB9XG4gICAgaWYgKHBsdWdpbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsdWdpbnMuWEhSUG9sbGluZykge1xuICAgICAgdHJhbnNwb3J0c1tUcmFuc3BvcnROYW1lcy5YaHJQb2xsaW5nXSA9IHBsdWdpbnMuWEhSUG9sbGluZztcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zcG9ydHM7XG4gIH1cbiAgZ2V0IGNoYW5uZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFubmVscztcbiAgfVxuICBjb25uZWN0KCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlYWx0aW1lLmNvbm5lY3QoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCgpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIlJlYWx0aW1lLmNsb3NlKClcIiwgXCJcIik7XG4gICAgdGhpcy5jb25uZWN0aW9uLmNsb3NlKCk7XG4gIH1cbn07XG4vLyBpbnRlcm5hbCBBUEkgdG8gbWFrZSBFdmVudEVtaXR0ZXIgdXNhYmxlIGluIG90aGVyIFNES3Ncbl9CYXNlUmVhbHRpbWUuRXZlbnRFbWl0dGVyID0gZXZlbnRlbWl0dGVyX2RlZmF1bHQ7XG52YXIgQmFzZVJlYWx0aW1lID0gX0Jhc2VSZWFsdGltZTtcbnZhciBDaGFubmVsczIgPSBjbGFzcyBleHRlbmRzIGV2ZW50ZW1pdHRlcl9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocmVhbHRpbWUpIHtcbiAgICBzdXBlcihyZWFsdGltZS5sb2dnZXIpO1xuICAgIHRoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcbiAgICB0aGlzLmFsbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJlYWx0aW1lLmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIub24oXCJ0cmFuc3BvcnQuYWN0aXZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMub25UcmFuc3BvcnRBY3RpdmUoKTtcbiAgICB9KTtcbiAgfVxuICBjaGFubmVsU2VyaWFscygpIHtcbiAgICBsZXQgc2VyaWFscyA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBrZXlzQXJyYXkodGhpcy5hbGwsIHRydWUpKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgICBpZiAoY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwpIHtcbiAgICAgICAgc2VyaWFsc1tuYW1lXSA9IGNoYW5uZWwucHJvcGVydGllcy5jaGFubmVsU2VyaWFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFscztcbiAgfVxuICAvLyByZWNvdmVyQ2hhbm5lbHMgZ2V0cyB0aGUgZ2l2ZW4gY2hhbm5lbHMgYW5kIHNldHMgdGhlaXIgY2hhbm5lbCBzZXJpYWxzLlxuICByZWNvdmVyQ2hhbm5lbHMoY2hhbm5lbFNlcmlhbHMpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Yga2V5c0FycmF5KGNoYW5uZWxTZXJpYWxzLCB0cnVlKSkge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuZ2V0KG5hbWUpO1xuICAgICAgY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwgPSBjaGFubmVsU2VyaWFsc1tuYW1lXTtcbiAgICB9XG4gIH1cbiAgLy8gQWNjZXNzIHRvIHRoaXMgbWV0aG9kIGlzIHN5bmNocm9uaXNlZCBieSBDb25uZWN0aW9uTWFuYWdlciNwcm9jZXNzQ2hhbm5lbE1lc3NhZ2UuXG4gIGFzeW5jIHByb2Nlc3NDaGFubmVsTWVzc2FnZShtc2cpIHtcbiAgICBjb25zdCBjaGFubmVsTmFtZSA9IG1zZy5jaGFubmVsO1xuICAgIGlmIChjaGFubmVsTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ2hhbm5lbHMucHJvY2Vzc0NoYW5uZWxNZXNzYWdlKClcIixcbiAgICAgICAgXCJyZWNlaXZlZCBldmVudCB1bnNwZWNpZmllZCBjaGFubmVsLCBhY3Rpb24gPSBcIiArIG1zZy5hY3Rpb25cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsTmFtZV07XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsXG4gICAgICAgIFwiQ2hhbm5lbHMucHJvY2Vzc0NoYW5uZWxNZXNzYWdlKClcIixcbiAgICAgICAgXCJyZWNlaXZlZCBldmVudCBmb3Igbm9uLWV4aXN0ZW50IGNoYW5uZWw6IFwiICsgY2hhbm5lbE5hbWVcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IGNoYW5uZWwucHJvY2Vzc01lc3NhZ2UobXNnKTtcbiAgfVxuICAvKiBjYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBiZWNvbWVzIGNvbm5lY3RlZDsgcmVhdHRlbXB0IGF0dGFjaC9kZXRhY2hcbiAgICogZm9yIGNoYW5uZWxzIHRoYXQgYXJlIGF0dGFjaGluZyBvciBkZXRhY2hpbmcuICovXG4gIG9uVHJhbnNwb3J0QWN0aXZlKCkge1xuICAgIGZvciAoY29uc3QgY2hhbm5lbE5hbWUgaW4gdGhpcy5hbGwpIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsTmFtZV07XG4gICAgICBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gXCJhdHRhY2hpbmdcIiB8fCBjaGFubmVsLnN0YXRlID09PSBcImRldGFjaGluZ1wiKSB7XG4gICAgICAgIGNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgICBjaGFubmVsLl9hdHRhY2goZmFsc2UsIG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsLnN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgICAgY2hhbm5lbC5yZXF1ZXN0U3RhdGUoXCJhdHRhY2hpbmdcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIENvbm5lY3Rpb24gaW50ZXJydXB0aW9ucyAoaWUgd2hlbiB0aGUgY29ubmVjdGlvbiB3aWxsIG5vIGxvbmdlciBxdWV1ZVxuICAgKiBldmVudHMpIGltcGx5IGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlcyBmb3IgYW55IGNoYW5uZWwgd2hpY2ggaXMgZWl0aGVyXG4gICAqIGF0dGFjaGVkLCBwZW5kaW5nLCBvciB3aWxsIGF0dGVtcHQgdG8gYmVjb21lIGF0dGFjaGVkIGluIHRoZSBmdXR1cmUgKi9cbiAgcHJvcG9nYXRlQ29ubmVjdGlvbkludGVycnVwdGlvbihjb25uZWN0aW9uU3RhdGUsIHJlYXNvbikge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25TdGF0ZVRvQ2hhbm5lbFN0YXRlID0ge1xuICAgICAgY2xvc2luZzogXCJkZXRhY2hlZFwiLFxuICAgICAgY2xvc2VkOiBcImRldGFjaGVkXCIsXG4gICAgICBmYWlsZWQ6IFwiZmFpbGVkXCIsXG4gICAgICBzdXNwZW5kZWQ6IFwic3VzcGVuZGVkXCJcbiAgICB9O1xuICAgIGNvbnN0IGZyb21DaGFubmVsU3RhdGVzID0gW1wiYXR0YWNoaW5nXCIsIFwiYXR0YWNoZWRcIiwgXCJkZXRhY2hpbmdcIiwgXCJzdXNwZW5kZWRcIl07XG4gICAgY29uc3QgdG9DaGFubmVsU3RhdGUgPSBjb25uZWN0aW9uU3RhdGVUb0NoYW5uZWxTdGF0ZVtjb25uZWN0aW9uU3RhdGVdO1xuICAgIGZvciAoY29uc3QgY2hhbm5lbElkIGluIHRoaXMuYWxsKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbElkXTtcbiAgICAgIGlmIChmcm9tQ2hhbm5lbFN0YXRlcy5pbmNsdWRlcyhjaGFubmVsLnN0YXRlKSkge1xuICAgICAgICBjaGFubmVsLm5vdGlmeVN0YXRlKHRvQ2hhbm5lbFN0YXRlLCByZWFzb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQobmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgIGxldCBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV0gPSBuZXcgcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQodGhpcy5yZWFsdGltZSwgbmFtZSwgY2hhbm5lbE9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgIGlmIChjaGFubmVsLl9zaG91bGRSZWF0dGFjaFRvU2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucywgY2hhbm5lbC5jaGFubmVsT3B0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICBcIkNoYW5uZWxzLmdldCgpIGNhbm5vdCBiZSB1c2VkIHRvIHNldCBjaGFubmVsIG9wdGlvbnMgdGhhdCB3b3VsZCBjYXVzZSB0aGUgY2hhbm5lbCB0byByZWF0dGFjaC4gUGxlYXNlLCB1c2UgUmVhbHRpbWVDaGFubmVsLnNldE9wdGlvbnMoKSBpbnN0ZWFkLlwiLFxuICAgICAgICAgIDRlNCxcbiAgICAgICAgICA0MDBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoYW5uZWwuc2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVsO1xuICB9XG4gIGdldERlcml2ZWQobmFtZSwgZGVyaXZlT3B0aW9ucywgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICBpZiAoZGVyaXZlT3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIGNvbnN0IGZpbHRlciA9IHRvQmFzZTY0KGRlcml2ZU9wdGlvbnMuZmlsdGVyKTtcbiAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hEZXJpdmVkQ2hhbm5lbChuYW1lKTtcbiAgICAgIG5hbWUgPSBgW2ZpbHRlcj0ke2ZpbHRlcn0ke21hdGNoLnF1YWxpZmllclBhcmFtfV0ke21hdGNoLmNoYW5uZWxOYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldChuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gIH1cbiAgLyogSW5jbHVkZWQgdG8gc3VwcG9ydCBjZXJ0YWluIG5pY2hlIHVzZS1jYXNlczsgbW9zdCB1c2VycyBzaG91bGQgaWdub3JlIHRoaXMuXG4gICAqIFBsZWFzZSBkbyBub3QgdXNlIHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nICovXG4gIHJlbGVhc2UobmFtZSkge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWxlYXNlRXJyID0gY2hhbm5lbC5nZXRSZWxlYXNlRXJyKCk7XG4gICAgaWYgKHJlbGVhc2VFcnIpIHtcbiAgICAgIHRocm93IHJlbGVhc2VFcnI7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmFsbFtuYW1lXTtcbiAgfVxufTtcbnZhciBiYXNlcmVhbHRpbWVfZGVmYXVsdCA9IEJhc2VSZWFsdGltZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3ByZXNlbmNlbWFwLnRzXG5mdW5jdGlvbiBuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmcpIHtcbiAgaWYgKGl0ZW0uaXNTeW50aGVzaXplZCgpIHx8IGV4aXN0aW5nLmlzU3ludGhlc2l6ZWQoKSkge1xuICAgIHJldHVybiBpdGVtLnRpbWVzdGFtcCA+PSBleGlzdGluZy50aW1lc3RhbXA7XG4gIH1cbiAgY29uc3QgaXRlbU9yZGVyaW5ncyA9IGl0ZW0ucGFyc2VJZCgpLCBleGlzdGluZ09yZGVyaW5ncyA9IGV4aXN0aW5nLnBhcnNlSWQoKTtcbiAgaWYgKGl0ZW1PcmRlcmluZ3MubXNnU2VyaWFsID09PSBleGlzdGluZ09yZGVyaW5ncy5tc2dTZXJpYWwpIHtcbiAgICByZXR1cm4gaXRlbU9yZGVyaW5ncy5pbmRleCA+IGV4aXN0aW5nT3JkZXJpbmdzLmluZGV4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpdGVtT3JkZXJpbmdzLm1zZ1NlcmlhbCA+IGV4aXN0aW5nT3JkZXJpbmdzLm1zZ1NlcmlhbDtcbiAgfVxufVxudmFyIFByZXNlbmNlTWFwID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHByZXNlbmNlLCBtZW1iZXJLZXksIG5ld2VyID0gbmV3ZXJUaGFuKSB7XG4gICAgc3VwZXIocHJlc2VuY2UubG9nZ2VyKTtcbiAgICB0aGlzLnByZXNlbmNlID0gcHJlc2VuY2U7XG4gICAgdGhpcy5tYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN5bmNJblByb2dyZXNzID0gZmFsc2U7XG4gICAgdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuICAgIHRoaXMubWVtYmVyS2V5ID0gbWVtYmVyS2V5O1xuICAgIHRoaXMubmV3ZXJUaGFuID0gbmV3ZXI7XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hcFtrZXldO1xuICB9XG4gIGdldENsaWVudChjbGllbnRJZCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBtYXBba2V5XTtcbiAgICAgIGlmIChpdGVtLmNsaWVudElkID09IGNsaWVudElkICYmIGl0ZW0uYWN0aW9uICE9IFwiYWJzZW50XCIpXG4gICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxpc3QocGFyYW1zKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIGNsaWVudElkID0gcGFyYW1zICYmIHBhcmFtcy5jbGllbnRJZCwgY29ubmVjdGlvbklkID0gcGFyYW1zICYmIHBhcmFtcy5jb25uZWN0aW9uSWQsIHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1hcCkge1xuICAgICAgY29uc3QgaXRlbSA9IG1hcFtrZXldO1xuICAgICAgaWYgKGl0ZW0uYWN0aW9uID09PSBcImFic2VudFwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChjbGllbnRJZCAmJiBjbGllbnRJZCAhPSBpdGVtLmNsaWVudElkKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChjb25uZWN0aW9uSWQgJiYgY29ubmVjdGlvbklkICE9IGl0ZW0uY29ubmVjdGlvbklkKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHB1dChpdGVtKSB7XG4gICAgaWYgKGl0ZW0uYWN0aW9uID09PSBcImVudGVyXCIgfHwgaXRlbS5hY3Rpb24gPT09IFwidXBkYXRlXCIpIHtcbiAgICAgIGl0ZW0gPSBwcmVzZW5jZW1lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKGl0ZW0pO1xuICAgICAgaXRlbS5hY3Rpb24gPSBcInByZXNlbnRcIjtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIGtleSA9IHRoaXMubWVtYmVyS2V5KGl0ZW0pO1xuICAgIGlmICh0aGlzLnJlc2lkdWFsTWVtYmVycylcbiAgICAgIGRlbGV0ZSB0aGlzLnJlc2lkdWFsTWVtYmVyc1trZXldO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IG1hcFtrZXldO1xuICAgIGlmIChleGlzdGluZ0l0ZW0gJiYgIXRoaXMubmV3ZXJUaGFuKGl0ZW0sIGV4aXN0aW5nSXRlbSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbWFwW2tleV0gPSBpdGVtO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhbHVlcygpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWFwKSB7XG4gICAgICBjb25zdCBpdGVtID0gbWFwW2tleV07XG4gICAgICBpZiAoaXRlbS5hY3Rpb24gIT0gXCJhYnNlbnRcIilcbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmVtb3ZlKGl0ZW0pIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwga2V5ID0gdGhpcy5tZW1iZXJLZXkoaXRlbSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gbWFwW2tleV07XG4gICAgaWYgKGV4aXN0aW5nSXRlbSAmJiAhdGhpcy5uZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5zeW5jSW5Qcm9ncmVzcykge1xuICAgICAgaXRlbSA9IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21WYWx1ZXMoaXRlbSk7XG4gICAgICBpdGVtLmFjdGlvbiA9IFwiYWJzZW50XCI7XG4gICAgICBtYXBba2V5XSA9IGl0ZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBtYXBba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuICEhZXhpc3RpbmdJdGVtO1xuICB9XG4gIHN0YXJ0U3luYygpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgXCJQcmVzZW5jZU1hcC5zdGFydFN5bmMoKVwiLFxuICAgICAgXCJjaGFubmVsID0gXCIgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArIFwiOyBzeW5jSW5Qcm9ncmVzcyA9IFwiICsgc3luY0luUHJvZ3Jlc3NcbiAgICApO1xuICAgIGlmICghdGhpcy5zeW5jSW5Qcm9ncmVzcykge1xuICAgICAgdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBjb3B5KG1hcCk7XG4gICAgICB0aGlzLnNldEluUHJvZ3Jlc3ModHJ1ZSk7XG4gICAgfVxuICB9XG4gIGVuZFN5bmMoKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAsIHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiUHJlc2VuY2VNYXAuZW5kU3luYygpXCIsXG4gICAgICBcImNoYW5uZWwgPSBcIiArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgXCI7IHN5bmNJblByb2dyZXNzID0gXCIgKyBzeW5jSW5Qcm9ncmVzc1xuICAgICk7XG4gICAgaWYgKHN5bmNJblByb2dyZXNzKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlcktleSBpbiBtYXApIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBtYXBbbWVtYmVyS2V5XTtcbiAgICAgICAgaWYgKGVudHJ5LmFjdGlvbiA9PT0gXCJhYnNlbnRcIikge1xuICAgICAgICAgIGRlbGV0ZSBtYXBbbWVtYmVyS2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wcmVzZW5jZS5fc3ludGhlc2l6ZUxlYXZlcyh2YWx1ZXNBcnJheSh0aGlzLnJlc2lkdWFsTWVtYmVycykpO1xuICAgICAgZm9yIChjb25zdCBtZW1iZXJLZXkgaW4gdGhpcy5yZXNpZHVhbE1lbWJlcnMpIHtcbiAgICAgICAgZGVsZXRlIG1hcFttZW1iZXJLZXldO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuICAgICAgdGhpcy5zZXRJblByb2dyZXNzKGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwic3luY1wiKTtcbiAgfVxuICB3YWl0U3luYyhjYWxsYmFjaykge1xuICAgIGNvbnN0IHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiUHJlc2VuY2VNYXAud2FpdFN5bmMoKVwiLFxuICAgICAgXCJjaGFubmVsID0gXCIgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArIFwiOyBzeW5jSW5Qcm9ncmVzcyA9IFwiICsgc3luY0luUHJvZ3Jlc3NcbiAgICApO1xuICAgIGlmICghc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub25jZShcInN5bmNcIiwgY2FsbGJhY2spO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMubWFwID0ge307XG4gICAgdGhpcy5zZXRJblByb2dyZXNzKGZhbHNlKTtcbiAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG4gIH1cbiAgc2V0SW5Qcm9ncmVzcyhpblByb2dyZXNzKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUHJlc2VuY2VNYXAuc2V0SW5Qcm9ncmVzcygpXCIsIFwiaW5Qcm9ncmVzcyA9IFwiICsgaW5Qcm9ncmVzcyk7XG4gICAgdGhpcy5zeW5jSW5Qcm9ncmVzcyA9IGluUHJvZ3Jlc3M7XG4gICAgdGhpcy5wcmVzZW5jZS5zeW5jQ29tcGxldGUgPSAhaW5Qcm9ncmVzcztcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1vbi9saWIvY2xpZW50L3JlYWx0aW1lcHJlc2VuY2UudHNcbmZ1bmN0aW9uIGdldENsaWVudElkKHJlYWx0aW1lUHJlc2VuY2UpIHtcbiAgcmV0dXJuIHJlYWx0aW1lUHJlc2VuY2UuY2hhbm5lbC5jbGllbnQuYXV0aC5jbGllbnRJZDtcbn1cbmZ1bmN0aW9uIGlzQW5vbnltb3VzT3JXaWxkY2FyZChyZWFsdGltZVByZXNlbmNlKSB7XG4gIGNvbnN0IHJlYWx0aW1lID0gcmVhbHRpbWVQcmVzZW5jZS5jaGFubmVsLmNsaWVudDtcbiAgY29uc3QgY2xpZW50SWQgPSByZWFsdGltZS5hdXRoLmNsaWVudElkO1xuICByZXR1cm4gKCFjbGllbnRJZCB8fCBjbGllbnRJZCA9PT0gXCIqXCIpICYmIHJlYWx0aW1lLmNvbm5lY3Rpb24uc3RhdGUgPT09IFwiY29ubmVjdGVkXCI7XG59XG5mdW5jdGlvbiB3YWl0QXR0YWNoZWQoY2hhbm5lbCwgY2FsbGJhY2ssIGFjdGlvbikge1xuICBzd2l0Y2ggKGNoYW5uZWwuc3RhdGUpIHtcbiAgICBjYXNlIFwiYXR0YWNoZWRcIjpcbiAgICBjYXNlIFwic3VzcGVuZGVkXCI6XG4gICAgICBhY3Rpb24oKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpbml0aWFsaXplZFwiOlxuICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgIGNhc2UgXCJkZXRhY2hpbmdcIjpcbiAgICBjYXNlIFwiYXR0YWNoaW5nXCI6XG4gICAgICB3aGVuUHJvbWlzZVNldHRsZXMoY2hhbm5lbC5hdHRhY2goKSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGFjdGlvbigpO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY2FsbGJhY2soRXJyb3JJbmZvLmZyb21WYWx1ZXMoY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcigpKSk7XG4gIH1cbn1cbnZhciBSZWFsdGltZVByZXNlbmNlID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWwpIHtcbiAgICBzdXBlcihjaGFubmVsLmxvZ2dlcik7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICB0aGlzLnN5bmNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIHRoaXMubWVtYmVycyA9IG5ldyBQcmVzZW5jZU1hcCh0aGlzLCAoaXRlbSkgPT4gaXRlbS5jbGllbnRJZCArIFwiOlwiICsgaXRlbS5jb25uZWN0aW9uSWQpO1xuICAgIHRoaXMuX215TWVtYmVycyA9IG5ldyBQcmVzZW5jZU1hcCh0aGlzLCAoaXRlbSkgPT4gaXRlbS5jbGllbnRJZCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IGV2ZW50ZW1pdHRlcl9kZWZhdWx0KHRoaXMubG9nZ2VyKTtcbiAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZSA9IFtdO1xuICB9XG4gIGFzeW5jIGVudGVyKGRhdGEpIHtcbiAgICBpZiAoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JJbmZvKFwiY2xpZW50SWQgbXVzdCBiZSBzcGVjaWZpZWQgdG8gZW50ZXIgYSBwcmVzZW5jZSBjaGFubmVsXCIsIDQwMDEyLCA0MDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh2b2lkIDAsIHZvaWQgMCwgZGF0YSwgXCJlbnRlclwiKTtcbiAgfVxuICBhc3luYyB1cGRhdGUoZGF0YSkge1xuICAgIGlmIChpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJjbGllbnRJZCBtdXN0IGJlIHNwZWNpZmllZCB0byB1cGRhdGUgcHJlc2VuY2UgZGF0YVwiLCA0MDAxMiwgNDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodm9pZCAwLCB2b2lkIDAsIGRhdGEsIFwidXBkYXRlXCIpO1xuICB9XG4gIGFzeW5jIGVudGVyQ2xpZW50KGNsaWVudElkLCBkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodm9pZCAwLCBjbGllbnRJZCwgZGF0YSwgXCJlbnRlclwiKTtcbiAgfVxuICBhc3luYyB1cGRhdGVDbGllbnQoY2xpZW50SWQsIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh2b2lkIDAsIGNsaWVudElkLCBkYXRhLCBcInVwZGF0ZVwiKTtcbiAgfVxuICBhc3luYyBfZW50ZXJPclVwZGF0ZUNsaWVudChpZCwgY2xpZW50SWQsIGRhdGEsIGFjdGlvbikge1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgIHRocm93IGNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcbiAgICB9XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lUHJlc2VuY2UuXCIgKyBhY3Rpb24gKyBcIkNsaWVudCgpXCIsXG4gICAgICBcImNoYW5uZWwgPSBcIiArIGNoYW5uZWwubmFtZSArIFwiLCBpZCA9IFwiICsgaWQgKyBcIiwgY2xpZW50ID0gXCIgKyAoY2xpZW50SWQgfHwgXCIoaW1wbGljaXQpIFwiICsgZ2V0Q2xpZW50SWQodGhpcykpXG4gICAgKTtcbiAgICBjb25zdCBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZV9kZWZhdWx0LmZyb21EYXRhKGRhdGEpO1xuICAgIHByZXNlbmNlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICBpZiAoaWQpIHtcbiAgICAgIHByZXNlbmNlLmlkID0gaWQ7XG4gICAgfVxuICAgIGlmIChjbGllbnRJZCkge1xuICAgICAgcHJlc2VuY2UuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICB9XG4gICAgY29uc3Qgd2lyZVByZXNNc2cgPSBhd2FpdCBwcmVzZW5jZS5lbmNvZGUoY2hhbm5lbC5jaGFubmVsT3B0aW9ucyk7XG4gICAgc3dpdGNoIChjaGFubmVsLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiYXR0YWNoZWRcIjpcbiAgICAgICAgcmV0dXJuIGNoYW5uZWwuc2VuZFByZXNlbmNlKFt3aXJlUHJlc01zZ10pO1xuICAgICAgY2FzZSBcImluaXRpYWxpemVkXCI6XG4gICAgICBjYXNlIFwiZGV0YWNoZWRcIjpcbiAgICAgICAgY2hhbm5lbC5hdHRhY2goKTtcbiAgICAgIGNhc2UgXCJhdHRhY2hpbmdcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZS5wdXNoKHtcbiAgICAgICAgICAgIHByZXNlbmNlOiB3aXJlUHJlc01zZyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoZXJyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IFBhcnRpYWxFcnJvckluZm8oXG4gICAgICAgICAgXCJVbmFibGUgdG8gXCIgKyBhY3Rpb24gKyBcIiBwcmVzZW5jZSBjaGFubmVsIHdoaWxlIGluIFwiICsgY2hhbm5lbC5zdGF0ZSArIFwiIHN0YXRlXCIsXG4gICAgICAgICAgOTAwMDFcbiAgICAgICAgKTtcbiAgICAgICAgZXJyLmNvZGUgPSA5MDAwMTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBsZWF2ZShkYXRhKSB7XG4gICAgaWYgKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcImNsaWVudElkIG11c3QgaGF2ZSBiZWVuIHNwZWNpZmllZCB0byBlbnRlciBvciBsZWF2ZSBhIHByZXNlbmNlIGNoYW5uZWxcIiwgNDAwMTIsIDQwMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlYXZlQ2xpZW50KHZvaWQgMCwgZGF0YSk7XG4gIH1cbiAgYXN5bmMgbGVhdmVDbGllbnQoY2xpZW50SWQsIGRhdGEpIHtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuICAgIGlmICghY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICB0aHJvdyBjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCk7XG4gICAgfVxuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgXCJSZWFsdGltZVByZXNlbmNlLmxlYXZlQ2xpZW50KClcIixcbiAgICAgIFwibGVhdmluZzsgY2hhbm5lbCA9IFwiICsgdGhpcy5jaGFubmVsLm5hbWUgKyBcIiwgY2xpZW50ID0gXCIgKyBjbGllbnRJZFxuICAgICk7XG4gICAgY29uc3QgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VfZGVmYXVsdC5mcm9tRGF0YShkYXRhKTtcbiAgICBwcmVzZW5jZS5hY3Rpb24gPSBcImxlYXZlXCI7XG4gICAgaWYgKGNsaWVudElkKSB7XG4gICAgICBwcmVzZW5jZS5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgIH1cbiAgICBjb25zdCB3aXJlUHJlc01zZyA9IGF3YWl0IHByZXNlbmNlLmVuY29kZShjaGFubmVsLmNoYW5uZWxPcHRpb25zKTtcbiAgICBzd2l0Y2ggKGNoYW5uZWwuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICByZXR1cm4gY2hhbm5lbC5zZW5kUHJlc2VuY2UoW3dpcmVQcmVzTXNnXSk7XG4gICAgICBjYXNlIFwiYXR0YWNoaW5nXCI6XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UucHVzaCh7XG4gICAgICAgICAgICBwcmVzZW5jZTogd2lyZVByZXNNc2csXG4gICAgICAgICAgICBjYWxsYmFjazogKGVycikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwiaW5pdGlhbGl6ZWRcIjpcbiAgICAgIGNhc2UgXCJmYWlsZWRcIjoge1xuICAgICAgICB0aHJvdyBuZXcgUGFydGlhbEVycm9ySW5mbyhcIlVuYWJsZSB0byBsZWF2ZSBwcmVzZW5jZSBjaGFubmVsIChpbmNvbXBhdGlibGUgc3RhdGUpXCIsIDkwMDAxKTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IGNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgIGNvbnN0IHdhaXRGb3JTeW5jID0gIXBhcmFtcyB8fCAoXCJ3YWl0Rm9yU3luY1wiIGluIHBhcmFtcyA/IHBhcmFtcy53YWl0Rm9yU3luYyA6IHRydWUpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBmdW5jdGlvbiByZXR1cm5NZW1iZXJzKG1lbWJlcnMpIHtcbiAgICAgICAgcmVzb2x2ZShwYXJhbXMgPyBtZW1iZXJzLmxpc3QocGFyYW1zKSA6IG1lbWJlcnMudmFsdWVzKCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2hhbm5lbC5zdGF0ZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgICAgICBpZiAod2FpdEZvclN5bmMpIHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBFcnJvckluZm8uZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgICAgICAgY29kZTogOTEwMDUsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiUHJlc2VuY2Ugc3RhdGUgaXMgb3V0IG9mIHN5bmMgZHVlIHRvIGNoYW5uZWwgYmVpbmcgaW4gdGhlIFNVU1BFTkRFRCBzdGF0ZVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuTWVtYmVycyh0aGlzLm1lbWJlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdhaXRBdHRhY2hlZChcbiAgICAgICAgdGhpcy5jaGFubmVsLFxuICAgICAgICAoZXJyKSA9PiByZWplY3QoZXJyKSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1lbWJlcnMgPSB0aGlzLm1lbWJlcnM7XG4gICAgICAgICAgaWYgKHdhaXRGb3JTeW5jKSB7XG4gICAgICAgICAgICBtZW1iZXJzLndhaXRTeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm5NZW1iZXJzKG1lbWJlcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybk1lbWJlcnMobWVtYmVycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGhpc3RvcnkocGFyYW1zKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiUmVhbHRpbWVQcmVzZW5jZS5oaXN0b3J5KClcIiwgXCJjaGFubmVsID0gXCIgKyB0aGlzLm5hbWUpO1xuICAgIGNvbnN0IHJlc3RNaXhpbiA9IHRoaXMuY2hhbm5lbC5jbGllbnQucmVzdC5wcmVzZW5jZU1peGluO1xuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnVudGlsQXR0YWNoKSB7XG4gICAgICBpZiAodGhpcy5jaGFubmVsLnN0YXRlID09PSBcImF0dGFjaGVkXCIpIHtcbiAgICAgICAgZGVsZXRlIHBhcmFtcy51bnRpbEF0dGFjaDtcbiAgICAgICAgcGFyYW1zLmZyb21fc2VyaWFsID0gdGhpcy5jaGFubmVsLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ySW5mbyhcbiAgICAgICAgICBcIm9wdGlvbiB1bnRpbEF0dGFjaCByZXF1aXJlcyB0aGUgY2hhbm5lbCB0byBiZSBhdHRhY2hlZCwgd2FzOiBcIiArIHRoaXMuY2hhbm5lbC5zdGF0ZSxcbiAgICAgICAgICA0ZTQsXG4gICAgICAgICAgNDAwXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN0TWl4aW4uaGlzdG9yeSh0aGlzLCBwYXJhbXMpO1xuICB9XG4gIHNldFByZXNlbmNlKHByZXNlbmNlU2V0LCBpc1N5bmMsIHN5bmNDaGFubmVsU2VyaWFsKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sXG4gICAgICBcIlJlYWx0aW1lUHJlc2VuY2Uuc2V0UHJlc2VuY2UoKVwiLFxuICAgICAgXCJyZWNlaXZlZCBwcmVzZW5jZSBmb3IgXCIgKyBwcmVzZW5jZVNldC5sZW5ndGggKyBcIiBwYXJ0aWNpcGFudHM7IHN5bmNDaGFubmVsU2VyaWFsID0gXCIgKyBzeW5jQ2hhbm5lbFNlcmlhbFxuICAgICk7XG4gICAgbGV0IHN5bmNDdXJzb3IsIG1hdGNoO1xuICAgIGNvbnN0IG1lbWJlcnMgPSB0aGlzLm1lbWJlcnMsIG15TWVtYmVycyA9IHRoaXMuX215TWVtYmVycywgYnJvYWRjYXN0TWVzc2FnZXMgPSBbXSwgY29ubklkID0gdGhpcy5jaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZDtcbiAgICBpZiAoaXNTeW5jKSB7XG4gICAgICB0aGlzLm1lbWJlcnMuc3RhcnRTeW5jKCk7XG4gICAgICBpZiAoc3luY0NoYW5uZWxTZXJpYWwgJiYgKG1hdGNoID0gc3luY0NoYW5uZWxTZXJpYWwubWF0Y2goL15bXFx3LV0rOiguKikkLykpKSB7XG4gICAgICAgIHN5bmNDdXJzb3IgPSBtYXRjaFsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgcHJlc2VuY2Ugb2YgcHJlc2VuY2VTZXQpIHtcbiAgICAgIHN3aXRjaCAocHJlc2VuY2UuYWN0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJsZWF2ZVwiOlxuICAgICAgICAgIGlmIChtZW1iZXJzLnJlbW92ZShwcmVzZW5jZSkpIHtcbiAgICAgICAgICAgIGJyb2FkY2FzdE1lc3NhZ2VzLnB1c2gocHJlc2VuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlc2VuY2UuY29ubmVjdGlvbklkID09PSBjb25uSWQgJiYgIXByZXNlbmNlLmlzU3ludGhlc2l6ZWQoKSkge1xuICAgICAgICAgICAgbXlNZW1iZXJzLnJlbW92ZShwcmVzZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW50ZXJcIjpcbiAgICAgICAgY2FzZSBcInByZXNlbnRcIjpcbiAgICAgICAgY2FzZSBcInVwZGF0ZVwiOlxuICAgICAgICAgIGlmIChtZW1iZXJzLnB1dChwcmVzZW5jZSkpIHtcbiAgICAgICAgICAgIGJyb2FkY2FzdE1lc3NhZ2VzLnB1c2gocHJlc2VuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlc2VuY2UuY29ubmVjdGlvbklkID09PSBjb25uSWQpIHtcbiAgICAgICAgICAgIG15TWVtYmVycy5wdXQocHJlc2VuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzU3luYyAmJiAhc3luY0N1cnNvcikge1xuICAgICAgbWVtYmVycy5lbmRTeW5jKCk7XG4gICAgICB0aGlzLmNoYW5uZWwuc3luY0NoYW5uZWxTZXJpYWwgPSBudWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJyb2FkY2FzdE1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwcmVzZW5jZSA9IGJyb2FkY2FzdE1lc3NhZ2VzW2ldO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmVtaXQocHJlc2VuY2UuYWN0aW9uLCBwcmVzZW5jZSk7XG4gICAgfVxuICB9XG4gIG9uQXR0YWNoZWQoaGFzUHJlc2VuY2UpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiUmVhbHRpbWVQcmVzZW5jZS5vbkF0dGFjaGVkKClcIixcbiAgICAgIFwiY2hhbm5lbCA9IFwiICsgdGhpcy5jaGFubmVsLm5hbWUgKyBcIiwgaGFzUHJlc2VuY2UgPSBcIiArIGhhc1ByZXNlbmNlXG4gICAgKTtcbiAgICBpZiAoaGFzUHJlc2VuY2UpIHtcbiAgICAgIHRoaXMubWVtYmVycy5zdGFydFN5bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3ludGhlc2l6ZUxlYXZlcyh0aGlzLm1lbWJlcnMudmFsdWVzKCkpO1xuICAgICAgdGhpcy5tZW1iZXJzLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKTtcbiAgICBjb25zdCBwZW5kaW5nUHJlc2VuY2UgPSB0aGlzLnBlbmRpbmdQcmVzZW5jZSwgcGVuZGluZ1ByZXNDb3VudCA9IHBlbmRpbmdQcmVzZW5jZS5sZW5ndGg7XG4gICAgaWYgKHBlbmRpbmdQcmVzQ291bnQpIHtcbiAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG4gICAgICBjb25zdCBwcmVzZW5jZUFycmF5ID0gW107XG4gICAgICBjb25zdCBtdWx0aWNhc3RlciA9IG11bHRpY2FzdGVyX2RlZmF1bHQuY3JlYXRlKHRoaXMubG9nZ2VyKTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgICAgXCJSZWFsdGltZVByZXNlbmNlLm9uQXR0YWNoZWRcIixcbiAgICAgICAgXCJzZW5kaW5nIFwiICsgcGVuZGluZ1ByZXNDb3VudCArIFwiIHF1ZXVlZCBwcmVzZW5jZSBtZXNzYWdlc1wiXG4gICAgICApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZW5kaW5nUHJlc0NvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBwZW5kaW5nUHJlc2VuY2VbaV07XG4gICAgICAgIHByZXNlbmNlQXJyYXkucHVzaChldmVudC5wcmVzZW5jZSk7XG4gICAgICAgIG11bHRpY2FzdGVyLnB1c2goZXZlbnQuY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGFubmVsLnNlbmRQcmVzZW5jZShwcmVzZW5jZUFycmF5KS50aGVuKCgpID0+IG11bHRpY2FzdGVyKCkpLmNhdGNoKChlcnIpID0+IG11bHRpY2FzdGVyKGVycikpO1xuICAgIH1cbiAgfVxuICBhY3RPbkNoYW5uZWxTdGF0ZShzdGF0ZSwgaGFzUHJlc2VuY2UsIGVycikge1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJhdHRhY2hlZFwiOlxuICAgICAgICB0aGlzLm9uQXR0YWNoZWQoaGFzUHJlc2VuY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZXRhY2hlZFwiOlxuICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICB0aGlzLl9jbGVhck15TWVtYmVycygpO1xuICAgICAgICB0aGlzLm1lbWJlcnMuY2xlYXIoKTtcbiAgICAgIGNhc2UgXCJzdXNwZW5kZWRcIjpcbiAgICAgICAgdGhpcy5mYWlsUGVuZGluZ1ByZXNlbmNlKGVycik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmYWlsUGVuZGluZ1ByZXNlbmNlKGVycikge1xuICAgIGlmICh0aGlzLnBlbmRpbmdQcmVzZW5jZS5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgICAgXCJSZWFsdGltZUNoYW5uZWwuZmFpbFBlbmRpbmdQcmVzZW5jZVwiLFxuICAgICAgICBcImNoYW5uZWw7IG5hbWUgPSBcIiArIHRoaXMuY2hhbm5lbC5uYW1lICsgXCIsIGVyciA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGVuZGluZ1ByZXNlbmNlLmxlbmd0aDsgaSsrKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlW2ldLmNhbGxiYWNrKGVycik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcbiAgICB9XG4gIH1cbiAgX2NsZWFyTXlNZW1iZXJzKCkge1xuICAgIHRoaXMuX215TWVtYmVycy5jbGVhcigpO1xuICB9XG4gIF9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCkge1xuICAgIGNvbnN0IG15TWVtYmVycyA9IHRoaXMuX215TWVtYmVycztcbiAgICBjb25zdCBjb25uSWQgPSB0aGlzLmNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkO1xuICAgIGZvciAoY29uc3QgbWVtYmVyS2V5IGluIG15TWVtYmVycy5tYXApIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gbXlNZW1iZXJzLm1hcFttZW1iZXJLZXldO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JQ1JPLFxuICAgICAgICBcIlJlYWx0aW1lUHJlc2VuY2UuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKVwiLFxuICAgICAgICAnQXV0by1yZWVudGVyaW5nIGNsaWVudElkIFwiJyArIGVudHJ5LmNsaWVudElkICsgJ1wiIGludG8gdGhlIHByZXNlbmNlIHNldCdcbiAgICAgICk7XG4gICAgICBjb25zdCBpZCA9IGVudHJ5LmNvbm5lY3Rpb25JZCA9PT0gY29ubklkID8gZW50cnkuaWQgOiB2b2lkIDA7XG4gICAgICB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KGlkLCBlbnRyeS5jbGllbnRJZCwgZW50cnkuZGF0YSwgXCJlbnRlclwiKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRFcnIgPSBuZXcgRXJyb3JJbmZvKFwiUHJlc2VuY2UgYXV0byByZS1lbnRlciBmYWlsZWRcIiwgOTEwMDQsIDQwMCwgZXJyKTtcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICBcIlJlYWx0aW1lUHJlc2VuY2UuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKVwiLFxuICAgICAgICAgIFwiUHJlc2VuY2UgYXV0byByZS1lbnRlciBmYWlsZWQ7IHJlYXNvbiA9IFwiICsgaW5zcGVjdEVycm9yKGVycilcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZV9kZWZhdWx0KHRoaXMuY2hhbm5lbC5zdGF0ZSwgdGhpcy5jaGFubmVsLnN0YXRlLCB0cnVlLCBmYWxzZSwgd3JhcHBlZEVycik7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5lbWl0KFwidXBkYXRlXCIsIGNoYW5nZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3N5bnRoZXNpemVMZWF2ZXMoaXRlbXMpIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgY29uc3QgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VfZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgYWN0aW9uOiBcImxlYXZlXCIsXG4gICAgICAgIGNvbm5lY3Rpb25JZDogaXRlbS5jb25uZWN0aW9uSWQsXG4gICAgICAgIGNsaWVudElkOiBpdGVtLmNsaWVudElkLFxuICAgICAgICBkYXRhOiBpdGVtLmRhdGEsXG4gICAgICAgIGVuY29kaW5nOiBpdGVtLmVuY29kaW5nLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgIH0pO1xuICAgICAgc3Vic2NyaXB0aW9ucy5lbWl0KFwibGVhdmVcIiwgcHJlc2VuY2UpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHN1YnNjcmliZSguLi5fYXJncykge1xuICAgIGNvbnN0IGFyZ3MgPSByZWFsdGltZWNoYW5uZWxfZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgY29uc3QgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgaWYgKGNoYW5uZWwuc3RhdGUgPT09IFwiZmFpbGVkXCIpIHtcbiAgICAgIHRocm93IEVycm9ySW5mby5mcm9tVmFsdWVzKGNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoKSk7XG4gICAgfVxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIGlmIChjaGFubmVsLmNoYW5uZWxPcHRpb25zLmF0dGFjaE9uU3Vic2NyaWJlICE9PSBmYWxzZSkge1xuICAgICAgYXdhaXQgY2hhbm5lbC5hdHRhY2goKTtcbiAgICB9XG4gIH1cbiAgdW5zdWJzY3JpYmUoLi4uX2FyZ3MpIHtcbiAgICBjb25zdCBhcmdzID0gcmVhbHRpbWVjaGFubmVsX2RlZmF1bHQucHJvY2Vzc0xpc3RlbmVyQXJncyhfYXJncyk7XG4gICAgY29uc3QgZXZlbnQgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gYXJnc1sxXTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbn07XG52YXIgcmVhbHRpbWVwcmVzZW5jZV9kZWZhdWx0ID0gUmVhbHRpbWVQcmVzZW5jZTtcblxuLy8gc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L3dlYnNvY2tldHRyYW5zcG9ydC50c1xudmFyIHNob3J0TmFtZSA9IFRyYW5zcG9ydE5hbWVzLldlYlNvY2tldDtcbmZ1bmN0aW9uIGlzTm9kZVdlYlNvY2tldCh3cykge1xuICByZXR1cm4gISF3cy5vbjtcbn1cbnZhciBXZWJTb2NrZXRUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIHRyYW5zcG9ydF9kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuICAgIHN1cGVyKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuICAgIHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuICAgIHBhcmFtcy5oZWFydGJlYXRzID0gUGxhdGZvcm0uQ29uZmlnLnVzZVByb3RvY29sSGVhcnRiZWF0cztcbiAgICB0aGlzLndzSG9zdCA9IHBhcmFtcy5ob3N0O1xuICB9XG4gIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gISFQbGF0Zm9ybS5Db25maWcuV2ViU29ja2V0O1xuICB9XG4gIGNyZWF0ZVdlYlNvY2tldCh1cmksIGNvbm5lY3RQYXJhbXMpIHtcbiAgICB0aGlzLnVyaSA9IHVyaSArIHRvUXVlcnlTdHJpbmcoY29ubmVjdFBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBQbGF0Zm9ybS5Db25maWcuV2ViU29ja2V0KHRoaXMudXJpKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJXZWJTb2NrZXRUcmFuc3BvcnQ7IHVyaT1cIiArIHRoaXMudXJpO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKVwiLCBcInN0YXJ0aW5nXCIpO1xuICAgIHRyYW5zcG9ydF9kZWZhdWx0LnByb3RvdHlwZS5jb25uZWN0LmNhbGwodGhpcyk7XG4gICAgY29uc3Qgc2VsZjIgPSB0aGlzLCBwYXJhbXMgPSB0aGlzLnBhcmFtcywgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zO1xuICAgIGNvbnN0IHdzU2NoZW1lID0gb3B0aW9ucy50bHMgPyBcIndzczovL1wiIDogXCJ3czovL1wiO1xuICAgIGNvbnN0IHdzVXJpID0gd3NTY2hlbWUgKyB0aGlzLndzSG9zdCArIFwiOlwiICsgZGVmYXVsdHNfZGVmYXVsdC5nZXRQb3J0KG9wdGlvbnMpICsgXCIvXCI7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKVwiLCBcInVyaTogXCIgKyB3c1VyaSk7XG4gICAgd2hlblByb21pc2VTZXR0bGVzKFxuICAgICAgdGhpcy5hdXRoLmdldEF1dGhQYXJhbXMoKSxcbiAgICAgIGZ1bmN0aW9uKGVyciwgYXV0aFBhcmFtcykge1xuICAgICAgICBpZiAoc2VsZjIuaXNEaXNwb3NlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyYW1TdHIgPSBcIlwiO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcmFtIGluIGF1dGhQYXJhbXMpXG4gICAgICAgICAgcGFyYW1TdHIgKz0gXCIgXCIgKyBwYXJhbSArIFwiOiBcIiArIGF1dGhQYXJhbXNbcGFyYW1dICsgXCI7XCI7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICBzZWxmMi5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICAgIFwiV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKVwiLFxuICAgICAgICAgIFwiYXV0aFBhcmFtczpcIiArIHBhcmFtU3RyICsgXCIgZXJyOiBcIiArIGVyclxuICAgICAgICApO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgc2VsZjIuZGlzY29ubmVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0UGFyYW1zID0gcGFyYW1zLmdldENvbm5lY3RQYXJhbXMoYXV0aFBhcmFtcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgd3NDb25uZWN0aW9uID0gc2VsZjIud3NDb25uZWN0aW9uID0gc2VsZjIuY3JlYXRlV2ViU29ja2V0KHdzVXJpLCBjb25uZWN0UGFyYW1zKTtcbiAgICAgICAgICB3c0Nvbm5lY3Rpb24uYmluYXJ5VHlwZSA9IFBsYXRmb3JtLkNvbmZpZy5iaW5hcnlUeXBlO1xuICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYyLm9uV3NPcGVuKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25jbG9zZSA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICBzZWxmMi5vbldzQ2xvc2UoZXYpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd3NDb25uZWN0aW9uLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICBzZWxmMi5vbldzRGF0YShldi5kYXRhKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHNlbGYyLm9uV3NFcnJvcihldik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaXNOb2RlV2ViU29ja2V0KHdzQ29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbihcInBpbmdcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNlbGYyLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHNlbGYyLmxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUixcbiAgICAgICAgICAgIFwiV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKVwiLFxuICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiBjcmVhdGluZyB3ZWJzb2NrZXQ6IGVyciA9IFwiICsgKGUuc3RhY2sgfHwgZS5tZXNzYWdlKVxuICAgICAgICAgICk7XG4gICAgICAgICAgc2VsZjIuZGlzY29ubmVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgc2VuZChtZXNzYWdlKSB7XG4gICAgY29uc3Qgd3NDb25uZWN0aW9uID0gdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgaWYgKCF3c0Nvbm5lY3Rpb24pIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIldlYlNvY2tldFRyYW5zcG9ydC5zZW5kKClcIiwgXCJObyBzb2NrZXQgY29ubmVjdGlvblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHdzQ29ubmVjdGlvbi5zZW5kKFxuICAgICAgICBzZXJpYWxpemUyKG1lc3NhZ2UsIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX01zZ1BhY2ssIHRoaXMucGFyYW1zLmZvcm1hdClcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgbXNnID0gXCJFeGNlcHRpb24gZnJvbSB3cyBjb25uZWN0aW9uIHdoZW4gdHJ5aW5nIHRvIHNlbmQ6IFwiICsgaW5zcGVjdEVycm9yKGUpO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfRVJST1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0LnNlbmQoKVwiLCBtc2cpO1xuICAgICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgbmV3IEVycm9ySW5mbyhtc2csIDVlNCwgNTAwKSk7XG4gICAgfVxuICB9XG4gIG9uV3NEYXRhKGRhdGEpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTyxcbiAgICAgIFwiV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NEYXRhKClcIixcbiAgICAgIFwiZGF0YSByZWNlaXZlZDsgbGVuZ3RoID0gXCIgKyBkYXRhLmxlbmd0aCArIFwiOyB0eXBlID0gXCIgKyB0eXBlb2YgZGF0YVxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMub25Qcm90b2NvbE1lc3NhZ2UoXG4gICAgICAgIGRlc2VyaWFsaXplKFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWFsdGltZS5fTXNnUGFjayxcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9SZWFsdGltZVByZXNlbmNlLFxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVhbHRpbWUuX0Fubm90YXRpb25zLFxuICAgICAgICAgIHRoaXMuZm9ybWF0XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICBcIldlYlNvY2tldFRyYW5zcG9ydC5vbldzRGF0YSgpXCIsXG4gICAgICAgIFwiVW5leHBlY3RlZCBleGNlcHRpb24gaGFuZGluZyBjaGFubmVsIG1lc3NhZ2U6IFwiICsgZS5zdGFja1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgb25Xc09wZW4oKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NPcGVuKClcIiwgXCJvcGVuZWQgV2ViU29ja2V0XCIpO1xuICAgIHRoaXMuZW1pdChcInByZWNvbm5lY3RcIik7XG4gIH1cbiAgb25Xc0Nsb3NlKGV2KSB7XG4gICAgbGV0IHdhc0NsZWFuLCBjb2RlO1xuICAgIGlmICh0eXBlb2YgZXYgPT0gXCJvYmplY3RcIikge1xuICAgICAgY29kZSA9IGV2LmNvZGU7XG4gICAgICB3YXNDbGVhbiA9IGV2Lndhc0NsZWFuIHx8IGNvZGUgPT09IDFlMztcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9IGV2O1xuICAgICAgd2FzQ2xlYW4gPSBjb2RlID09IDFlMztcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMud3NDb25uZWN0aW9uO1xuICAgIGlmICh3YXNDbGVhbikge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NDbG9zZSgpXCIsIFwiQ2xlYW5seSBjbG9zZWQgV2ViU29ja2V0XCIpO1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9ySW5mbyhcIldlYnNvY2tldCBjbG9zZWRcIiwgODAwMDMsIDQwMCk7XG4gICAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSBcIlVuY2xlYW4gZGlzY29ubmVjdGlvbiBvZiBXZWJTb2NrZXQgOyBjb2RlID0gXCIgKyBjb2RlLCBlcnIgPSBuZXcgRXJyb3JJbmZvKG1zZywgODAwMDMsIDQwMCk7XG4gICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0Nsb3NlKClcIiwgbXNnKTtcbiAgICAgIHRoaXMuZmluaXNoKFwiZGlzY29ubmVjdGVkXCIsIGVycik7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcImRpc3Bvc2VkXCIpO1xuICB9XG4gIG9uV3NFcnJvcihlcnIpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUixcbiAgICAgIFwiV2ViU29ja2V0VHJhbnNwb3J0Lm9uRXJyb3IoKVwiLFxuICAgICAgXCJFcnJvciBmcm9tIFdlYlNvY2tldDogXCIgKyBlcnIubWVzc2FnZVxuICAgICk7XG4gICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdChFcnJvcihlcnIubWVzc2FnZSkpO1xuICAgIH0pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKVwiLCBcIlwiKTtcbiAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgIGNvbnN0IHdzQ29ubmVjdGlvbiA9IHRoaXMud3NDb25uZWN0aW9uO1xuICAgIGlmICh3c0Nvbm5lY3Rpb24pIHtcbiAgICAgIHdzQ29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIH07XG4gICAgICBkZWxldGUgdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgICBQbGF0Zm9ybS5Db25maWcubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpXCIsIFwiY2xvc2luZyB3ZWJzb2NrZXRcIik7XG4gICAgICAgIGlmICghd3NDb25uZWN0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKTogd3NDb25uZWN0aW9uIGlzIG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHdzQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xudmFyIHdlYnNvY2tldHRyYW5zcG9ydF9kZWZhdWx0ID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuXG4vLyBzcmMvY29tbW9uL2xpYi9jbGllbnQvZmlsdGVyZWRzdWJzY3JpcHRpb25zLnRzXG52YXIgRmlsdGVyZWRTdWJzY3JpcHRpb25zID0gY2xhc3Mge1xuICBzdGF0aWMgc3Vic2NyaWJlRmlsdGVyKGNoYW5uZWwsIGZpbHRlciwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBmaWx0ZXJlZExpc3RlbmVyID0gKG0pID0+IHtcbiAgICAgIHZhciBfYTIsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgIGNvbnN0IG1hcHBpbmcgPSB7XG4gICAgICAgIG5hbWU6IG0ubmFtZSxcbiAgICAgICAgcmVmVGltZXNlcmlhbDogKF9iID0gKF9hMiA9IG0uZXh0cmFzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJlZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnRpbWVzZXJpYWwsXG4gICAgICAgIHJlZlR5cGU6IChfZCA9IChfYyA9IG0uZXh0cmFzKSA9PSBudWxsID8gdm9pZCAwIDogX2MucmVmKSA9PSBudWxsID8gdm9pZCAwIDogX2QudHlwZSxcbiAgICAgICAgaXNSZWY6ICEhKChfZiA9IChfZSA9IG0uZXh0cmFzKSA9PSBudWxsID8gdm9pZCAwIDogX2UucmVmKSA9PSBudWxsID8gdm9pZCAwIDogX2YudGltZXNlcmlhbCksXG4gICAgICAgIGNsaWVudElkOiBtLmNsaWVudElkXG4gICAgICB9O1xuICAgICAgaWYgKE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZmluZChcbiAgICAgICAgKFtrZXksIHZhbHVlXSkgPT4gdmFsdWUgIT09IHZvaWQgMCA/IG1hcHBpbmdba2V5XSAhPT0gdmFsdWUgOiBmYWxzZVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihtKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkRmlsdGVyZWRTdWJzY3JpcHRpb24oY2hhbm5lbCwgZmlsdGVyLCBsaXN0ZW5lciwgZmlsdGVyZWRMaXN0ZW5lcik7XG4gICAgY2hhbm5lbC5zdWJzY3JpcHRpb25zLm9uKGZpbHRlcmVkTGlzdGVuZXIpO1xuICB9XG4gIC8vIEFkZHMgYSBuZXcgZmlsdGVyZWQgc3Vic2NyaXB0aW9uXG4gIHN0YXRpYyBhZGRGaWx0ZXJlZFN1YnNjcmlwdGlvbihjaGFubmVsLCBmaWx0ZXIsIHJlYWxMaXN0ZW5lciwgZmlsdGVyZWRMaXN0ZW5lcikge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKCFjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucykge1xuICAgICAgY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBpZiAoY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuaGFzKHJlYWxMaXN0ZW5lcikpIHtcbiAgICAgIGNvbnN0IHJlYWxMaXN0ZW5lck1hcCA9IGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmdldChyZWFsTGlzdGVuZXIpO1xuICAgICAgcmVhbExpc3RlbmVyTWFwLnNldChmaWx0ZXIsICgoX2EyID0gcmVhbExpc3RlbmVyTWFwID09IG51bGwgPyB2b2lkIDAgOiByZWFsTGlzdGVuZXJNYXAuZ2V0KGZpbHRlcikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY29uY2F0KGZpbHRlcmVkTGlzdGVuZXIpKSB8fCBbZmlsdGVyZWRMaXN0ZW5lcl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5zZXQoXG4gICAgICAgIHJlYWxMaXN0ZW5lcixcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1tmaWx0ZXIsIFtmaWx0ZXJlZExpc3RlbmVyXV1dKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldEFuZERlbGV0ZUZpbHRlcmVkU3Vic2NyaXB0aW9ucyhjaGFubmVsLCBmaWx0ZXIsIHJlYWxMaXN0ZW5lcikge1xuICAgIGlmICghY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKCFyZWFsTGlzdGVuZXIgJiYgZmlsdGVyKSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShjaGFubmVsLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5lbnRyaWVzKCkpLm1hcCgoW2tleSwgZmlsdGVyTWFwc10pID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgbGV0IGxpc3RlbmVyTWFwcyA9IGZpbHRlck1hcHMuZ2V0KGZpbHRlcik7XG4gICAgICAgIGZpbHRlck1hcHMuZGVsZXRlKGZpbHRlcik7XG4gICAgICAgIGlmIChmaWx0ZXJNYXBzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAoX2EyID0gY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyTWFwcztcbiAgICAgIH0pLnJlZHVjZShcbiAgICAgICAgKHByZXYsIGN1cikgPT4gY3VyID8gcHJldi5jb25jYXQoLi4uY3VyKSA6IHByZXYsXG4gICAgICAgIFtdXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXJlYWxMaXN0ZW5lciB8fCAhY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuaGFzKHJlYWxMaXN0ZW5lcikpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcmVhbExpc3RlbmVyTWFwID0gY2hhbm5lbC5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZ2V0KHJlYWxMaXN0ZW5lcik7XG4gICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyczIgPSBBcnJheS5mcm9tKHJlYWxMaXN0ZW5lck1hcC52YWx1ZXMoKSkucmVkdWNlKChwcmV2LCBjdXIpID0+IHByZXYuY29uY2F0KC4uLmN1ciksIFtdKTtcbiAgICAgIGNoYW5uZWwuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmRlbGV0ZShyZWFsTGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIGxpc3RlbmVyczI7XG4gICAgfVxuICAgIGxldCBsaXN0ZW5lcnMgPSByZWFsTGlzdGVuZXJNYXAuZ2V0KGZpbHRlcik7XG4gICAgcmVhbExpc3RlbmVyTWFwLmRlbGV0ZShmaWx0ZXIpO1xuICAgIHJldHVybiBsaXN0ZW5lcnMgfHwgW107XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tb24vbGliL2NsaWVudC9kZWZhdWx0cmVhbHRpbWUudHNcbnZhciBfRGVmYXVsdFJlYWx0aW1lID0gY2xhc3MgX0RlZmF1bHRSZWFsdGltZSBleHRlbmRzIGJhc2VyZWFsdGltZV9kZWZhdWx0IHtcbiAgLy8gVGhlIHB1YmxpYyB0eXBpbmdzIGRlY2xhcmUgdGhhdCB0aGlzIHJlcXVpcmVzIGFuIGFyZ3VtZW50IHRvIGJlIHBhc3NlZCwgYnV0IHNpbmNlIHdlIHdhbnQgdG8gZW1pdCBhIGdvb2QgZXJyb3IgbWVzc2FnZSBpbiB0aGUgY2FzZSB3aGVyZSBhIG5vbi1UeXBlU2NyaXB0IHVzZXIgZG9lcyBub3QgcGFzcyBhbiBhcmd1bWVudCwgdGVsbCB0aGUgY29tcGlsZXIgdGhhdCB0aGlzIGlzIHBvc3NpYmxlIHNvIHRoYXQgaXQgZm9yY2VzIHVzIHRvIGhhbmRsZSBpdC5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYTI7XG4gICAgY29uc3QgTXNnUGFjayA9IF9EZWZhdWx0UmVhbHRpbWUuX01zZ1BhY2s7XG4gICAgaWYgKCFNc2dQYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBEZWZhdWx0UmVhbHRpbWUuX01zZ1BhY2sgdG8gaGF2ZSBiZWVuIHNldFwiKTtcbiAgICB9XG4gICAgc3VwZXIoXG4gICAgICBkZWZhdWx0c19kZWZhdWx0Lm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucywgdHJ1ZSwgXCJSZWFsdGltZVwiLCBsb2dnZXJfZGVmYXVsdC5kZWZhdWx0TG9nZ2VyLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBhbGxDb21tb25Nb2R1bGFyUGx1Z2lucyksIHtcbiAgICAgICAgQ3J5cHRvOiAoX2EyID0gX0RlZmF1bHRSZWFsdGltZS5DcnlwdG8pICE9IG51bGwgPyBfYTIgOiB2b2lkIDAsXG4gICAgICAgIE1zZ1BhY2ssXG4gICAgICAgIFJlYWx0aW1lUHJlc2VuY2U6IHtcbiAgICAgICAgICBSZWFsdGltZVByZXNlbmNlOiByZWFsdGltZXByZXNlbmNlX2RlZmF1bHQsXG4gICAgICAgICAgUHJlc2VuY2VNZXNzYWdlOiBwcmVzZW5jZW1lc3NhZ2VfZGVmYXVsdCxcbiAgICAgICAgICBXaXJlUHJlc2VuY2VNZXNzYWdlXG4gICAgICAgIH0sXG4gICAgICAgIEFubm90YXRpb25zOiB7XG4gICAgICAgICAgQW5ub3RhdGlvbjogYW5ub3RhdGlvbl9kZWZhdWx0LFxuICAgICAgICAgIFdpcmVBbm5vdGF0aW9uLFxuICAgICAgICAgIFJlYWx0aW1lQW5ub3RhdGlvbnM6IHJlYWx0aW1lYW5ub3RhdGlvbnNfZGVmYXVsdCxcbiAgICAgICAgICBSZXN0QW5ub3RhdGlvbnM6IHJlc3Rhbm5vdGF0aW9uc19kZWZhdWx0XG4gICAgICAgIH0sXG4gICAgICAgIFdlYlNvY2tldFRyYW5zcG9ydDogd2Vic29ja2V0dHJhbnNwb3J0X2RlZmF1bHQsXG4gICAgICAgIE1lc3NhZ2VJbnRlcmFjdGlvbnM6IEZpbHRlcmVkU3Vic2NyaXB0aW9uc1xuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgZ2V0IENyeXB0bygpIHtcbiAgICBpZiAodGhpcy5fQ3J5cHRvID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIG5vdCBlbmFibGVkOyB1c2UgYWJseS5lbmNyeXB0aW9uLmpzIGluc3RlYWRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9DcnlwdG87XG4gIH1cbiAgc3RhdGljIHNldCBDcnlwdG8obmV3VmFsdWUpIHtcbiAgICB0aGlzLl9DcnlwdG8gPSBuZXdWYWx1ZTtcbiAgfVxufTtcbl9EZWZhdWx0UmVhbHRpbWUuVXRpbHMgPSB1dGlsc19leHBvcnRzO1xuX0RlZmF1bHRSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlciA9IGNvbm5lY3Rpb25tYW5hZ2VyX2RlZmF1bHQ7XG5fRGVmYXVsdFJlYWx0aW1lLlByb3RvY29sTWVzc2FnZSA9IHByb3RvY29sbWVzc2FnZV9kZWZhdWx0O1xuX0RlZmF1bHRSZWFsdGltZS5fQ3J5cHRvID0gbnVsbDtcbl9EZWZhdWx0UmVhbHRpbWUuTWVzc2FnZSA9IERlZmF1bHRNZXNzYWdlO1xuX0RlZmF1bHRSZWFsdGltZS5QcmVzZW5jZU1lc3NhZ2UgPSBEZWZhdWx0UHJlc2VuY2VNZXNzYWdlO1xuX0RlZmF1bHRSZWFsdGltZS5Bbm5vdGF0aW9uID0gRGVmYXVsdEFubm90YXRpb247XG5fRGVmYXVsdFJlYWx0aW1lLl9Nc2dQYWNrID0gbnVsbDtcbi8vIFVzZWQgYnkgdGVzdHNcbl9EZWZhdWx0UmVhbHRpbWUuX0h0dHAgPSBIdHRwO1xuX0RlZmF1bHRSZWFsdGltZS5fUHJlc2VuY2VNYXAgPSBQcmVzZW5jZU1hcDtcbnZhciBEZWZhdWx0UmVhbHRpbWUgPSBfRGVmYXVsdFJlYWx0aW1lO1xuXG4vLyBzcmMvcGxhdGZvcm0vbm9kZWpzL2xpYi91dGlsL2J1ZmZlcnV0aWxzLnRzXG52YXIgaW1wb3J0X2NyeXB0byA9IF9fdG9FU00ocmVxdWlyZShcImNyeXB0b1wiKSk7XG52YXIgQnVmZmVyVXRpbHMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmFzZTY0Q2hhclNldCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICAgIHRoaXMuaGV4Q2hhclNldCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICB9XG4gIGJhc2U2NERlY29kZShzdHJpbmcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyaW5nLCBcImJhc2U2NFwiKTtcbiAgfVxuICBiYXNlNjRFbmNvZGUoYnVmZmVyKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CdWZmZXIoYnVmZmVyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgfVxuICBhcmVCdWZmZXJzRXF1YWwoYnVmZmVyMSwgYnVmZmVyMikge1xuICAgIGlmICghYnVmZmVyMSB8fCAhYnVmZmVyMilcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcihidWZmZXIxKS5jb21wYXJlKHRoaXMudG9CdWZmZXIoYnVmZmVyMikpID09IDA7XG4gIH1cbiAgYnl0ZUxlbmd0aChidWZmZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gIH1cbiAgaGV4RGVjb2RlKHN0cmluZykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHJpbmcsIFwiaGV4XCIpO1xuICB9XG4gIGhleEVuY29kZShidWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcihidWZmZXIpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICB9XG4gIC8qIEluIG5vZGUsIEJ1ZmZlclV0aWxzIG1ldGhvZHMgdGhhdCByZXR1cm4gYmluYXJ5IG9iamVjdHMgcmV0dXJuIGEgQnVmZmVyXG4gICAqIGZvciBoaXN0b3JpY2FsIHJlYXNvbnM7IHRoZSBicm93c2VyIGVxdWl2YWxlbnRzIHJldHVybiBBcnJheUJ1ZmZlcnMgKi9cbiAgaXNCdWZmZXIoYnVmZmVyKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpIHx8IGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpO1xuICB9XG4gIHRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gICAgY29uc3Qgbm9kZUJ1ZmZlciA9IHRoaXMudG9CdWZmZXIoYnVmZmVyKTtcbiAgICByZXR1cm4gbm9kZUJ1ZmZlci5idWZmZXIuc2xpY2Uobm9kZUJ1ZmZlci5ieXRlT2Zmc2V0LCBub2RlQnVmZmVyLmJ5dGVPZmZzZXQgKyBub2RlQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICB9XG4gIHRvQnVmZmVyKGJ1ZmZlcikge1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gIH1cbiAgYXJyYXlCdWZmZXJWaWV3VG9CdWZmZXIoYXJyYXlCdWZmZXJWaWV3KSB7XG4gICAgcmV0dXJuIHRoaXMudG9CdWZmZXIoYXJyYXlCdWZmZXJWaWV3KTtcbiAgfVxuICB1dGY4RGVjb2RlKGJ1ZmZlcikge1xuICAgIGlmICghdGhpcy5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCBvZiB1dGY4RGVjb2RlIHRvIGJlIGEgYnVmZmVyLCBhcnJheWJ1ZmZlciwgb3Igdmlld1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9CdWZmZXIoYnVmZmVyKS50b1N0cmluZyhcInV0ZjhcIik7XG4gIH1cbiAgdXRmOEVuY29kZShzdHJpbmcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyaW5nLCBcInV0ZjhcIik7XG4gIH1cbiAgaG1hY1NoYTI1NihtZXNzYWdlLCBrZXkpIHtcbiAgICBjb25zdCBtZXNzYWdlQnVmZmVyID0gdGhpcy50b0J1ZmZlcihtZXNzYWdlKTtcbiAgICBjb25zdCBrZXlCdWZmZXIgPSB0aGlzLnRvQnVmZmVyKGtleSk7XG4gICAgY29uc3QgaG1hYzIgPSBpbXBvcnRfY3J5cHRvLmRlZmF1bHQuY3JlYXRlSG1hYyhcIlNIQTI1NlwiLCBrZXlCdWZmZXIpO1xuICAgIGhtYWMyLnVwZGF0ZShtZXNzYWdlQnVmZmVyKTtcbiAgICByZXR1cm4gaG1hYzIuZGlnZXN0KCk7XG4gIH1cbn07XG52YXIgYnVmZmVydXRpbHNfZGVmYXVsdCA9IG5ldyBCdWZmZXJVdGlscygpO1xuXG4vLyBzcmMvcGxhdGZvcm0vbm9kZWpzL2xpYi91dGlsL2NyeXB0by50c1xudmFyIGltcG9ydF9jcnlwdG8yID0gX190b0VTTShyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbnZhciBpbXBvcnRfdXRpbCA9IF9fdG9FU00ocmVxdWlyZShcInV0aWxcIikpO1xudmFyIGNyZWF0ZUNyeXB0b0NsYXNzID0gZnVuY3Rpb24oYnVmZmVyVXRpbHMpIHtcbiAgdmFyIERFRkFVTFRfQUxHT1JJVEhNID0gXCJhZXNcIjtcbiAgdmFyIERFRkFVTFRfS0VZTEVOR1RIID0gMjU2O1xuICB2YXIgREVGQVVMVF9NT0RFID0gXCJjYmNcIjtcbiAgdmFyIERFRkFVTFRfQkxPQ0tMRU5HVEggPSAxNjtcbiAgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb20oYnl0ZXMpIHtcbiAgICByZXR1cm4gaW1wb3J0X3V0aWwuZGVmYXVsdC5wcm9taXNpZnkoaW1wb3J0X2NyeXB0bzIuZGVmYXVsdC5yYW5kb21CeXRlcykoYnl0ZXMpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFBhZGRlZExlbmd0aChwbGFpbnRleHRMZW5ndGgpIHtcbiAgICByZXR1cm4gcGxhaW50ZXh0TGVuZ3RoICsgREVGQVVMVF9CTE9DS0xFTkdUSCAmIC1ERUZBVUxUX0JMT0NLTEVOR1RIO1xuICB9XG4gIGZ1bmN0aW9uIHZhbGlkYXRlQ2lwaGVyUGFyYW1zKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMuYWxnb3JpdGhtID09PSBcImFlc1wiICYmIHBhcmFtcy5tb2RlID09PSBcImNiY1wiKSB7XG4gICAgICBpZiAocGFyYW1zLmtleUxlbmd0aCA9PT0gMTI4IHx8IHBhcmFtcy5rZXlMZW5ndGggPT09IDI1Nikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVW5zdXBwb3J0ZWQga2V5IGxlbmd0aCBcIiArIHBhcmFtcy5rZXlMZW5ndGggKyBcIiBmb3IgYWVzLWNiYyBlbmNyeXB0aW9uLiBFbmNyeXB0aW9uIGtleSBtdXN0IGJlIDEyOCBvciAyNTYgYml0cyAoMTYgb3IgMzIgQVNDSUkgY2hhcmFjdGVycylcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm9ybWFsaXNlQmFzZTY0KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShcIl9cIiwgXCIvXCIpLnJlcGxhY2UoXCItXCIsIFwiK1wiKTtcbiAgfVxuICBmdW5jdGlvbiBmaWxsZWRCdWZmZXIobGVuZ3RoLCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcbiAgICByZXN1bHQuZmlsbCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgcGtjczVQYWRkaW5nID0gW2ZpbGxlZEJ1ZmZlcigxNiwgMTYpXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMTY7IGkrKylcbiAgICBwa2NzNVBhZGRpbmcucHVzaChmaWxsZWRCdWZmZXIoaSwgaSkpO1xuICBjbGFzcyBDaXBoZXJQYXJhbXMge1xuICAgIGNvbnN0cnVjdG9yKGFsZ29yaXRobSwga2V5TGVuZ3RoLCBtb2RlLCBrZXkpIHtcbiAgICAgIHRoaXMuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xuICAgICAgdGhpcy5rZXlMZW5ndGggPSBrZXlMZW5ndGg7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLml2ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNJbnN0Q2lwaGVyUGFyYW1zKHBhcmFtcykge1xuICAgIHJldHVybiAhIShwYXJhbXMuYWxnb3JpdGhtICYmIHBhcmFtcy5rZXkgJiYgcGFyYW1zLmtleUxlbmd0aCAmJiBwYXJhbXMubW9kZSk7XG4gIH1cbiAgY2xhc3MgQ3J5cHRvMiB7XG4gICAgLyoqXG4gICAgICogT2J0YWluIGEgY29tcGxldGUgQ2lwaGVyUGFyYW1zIGluc3RhbmNlIGZyb20gdGhlIHByb3ZpZGVkIHBhcmFtcywgZmlsbGluZ1xuICAgICAqIGluIGFueSBub3QgcHJvdmlkZWQgd2l0aCBkZWZhdWx0IHZhbHVlcywgY2FsY3VsYXRpbmcgYSBrZXlMZW5ndGggZnJvbVxuICAgICAqIHRoZSBzdXBwbGllZCBrZXksIGFuZCB2YWxpZGF0aW5nIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHBhcmFtcyBhbiBvYmplY3QgY29udGFpbmluZyBhdCBhIG1pbmltdW0gYSBga2V5YCBrZXkgd2l0aCB2YWx1ZSB0aGVcbiAgICAgKiBrZXksIGFzIGVpdGhlciBhIGJpbmFyeSBvciBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZy5cbiAgICAgKiBNYXkgb3B0aW9uYWxseSBhbHNvIGNvbnRhaW46IGFsZ29yaXRobSAoZGVmYXVsdHMgdG8gQUVTKSxcbiAgICAgKiBtb2RlIChkZWZhdWx0cyB0byAnY2JjJylcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgIHZhciBrZXk7XG4gICAgICBpZiAoIXBhcmFtcy5rZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3J5cHRvLmdldERlZmF1bHRQYXJhbXM6IGEga2V5IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMua2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGtleSA9IGJ1ZmZlclV0aWxzLmJhc2U2NERlY29kZShub3JtYWxpc2VCYXNlNjQocGFyYW1zLmtleSkpO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbXMua2V5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAga2V5ID0gQnVmZmVyLmZyb20ocGFyYW1zLmtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSBwYXJhbXMua2V5O1xuICAgICAgfVxuICAgICAgdmFyIGFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gfHwgREVGQVVMVF9BTEdPUklUSE07XG4gICAgICB2YXIga2V5TGVuZ3RoID0ga2V5Lmxlbmd0aCAqIDg7XG4gICAgICB2YXIgbW9kZSA9IHBhcmFtcy5tb2RlIHx8IERFRkFVTFRfTU9ERTtcbiAgICAgIHZhciBjaXBoZXJQYXJhbXMgPSBuZXcgQ2lwaGVyUGFyYW1zKGFsZ29yaXRobSwga2V5TGVuZ3RoLCBtb2RlLCBrZXkpO1xuICAgICAgaWYgKHBhcmFtcy5rZXlMZW5ndGggJiYgcGFyYW1zLmtleUxlbmd0aCAhPT0gY2lwaGVyUGFyYW1zLmtleUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtczogYSBrZXlMZW5ndGggb2YgXCIgKyBwYXJhbXMua2V5TGVuZ3RoICsgXCIgd2FzIHNwZWNpZmllZCwgYnV0IHRoZSBrZXkgYWN0dWFsbHkgaGFzIGxlbmd0aCBcIiArIGNpcGhlclBhcmFtcy5rZXlMZW5ndGhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRlQ2lwaGVyUGFyYW1zKGNpcGhlclBhcmFtcyk7XG4gICAgICByZXR1cm4gY2lwaGVyUGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHJhbmRvbSBlbmNyeXB0aW9uIGtleSBmcm9tIHRoZSBzdXBwbGllZCBrZXlsZW5ndGggKG9yIHRoZVxuICAgICAqIGRlZmF1bHQga2V5TGVuZ3RoIGlmIG5vbmUgc3VwcGxpZWQpIGFzIGEgQnVmZmVyXG4gICAgICogQHBhcmFtIGtleUxlbmd0aCAob3B0aW9uYWwpIHRoZSByZXF1aXJlZCBrZXlMZW5ndGggaW4gYml0c1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBnZW5lcmF0ZVJhbmRvbUtleShrZXlMZW5ndGgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVJhbmRvbSgoa2V5TGVuZ3RoIHx8IERFRkFVTFRfS0VZTEVOR1RIKSAvIDgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvckluZm8oXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmFuZG9tIGtleTogXCIgKyBlcnIubWVzc2FnZSwgNTAwLCA1ZTQsIGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsOyBnZXQgYSBDaGFubmVsQ2lwaGVyIGluc3RhbmNlIGJhc2VkIG9uIHRoZSBnaXZlbiBjaXBoZXJQYXJhbXNcbiAgICAgKiBAcGFyYW0gcGFyYW1zIGVpdGhlciBhIENpcGhlclBhcmFtcyBpbnN0YW5jZSBvciBzb21lIHN1YnNldCBvZiBpdHNcbiAgICAgKiBmaWVsZHMgdGhhdCBpbmNsdWRlcyBhIGtleVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaXBoZXIocGFyYW1zLCBsb2dnZXIpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICB2YXIgY2lwaGVyUGFyYW1zID0gaXNJbnN0Q2lwaGVyUGFyYW1zKHBhcmFtcykgPyBwYXJhbXMgOiB0aGlzLmdldERlZmF1bHRQYXJhbXMocGFyYW1zKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNpcGhlclBhcmFtcyxcbiAgICAgICAgY2lwaGVyOiBuZXcgQ0JDQ2lwaGVyKGNpcGhlclBhcmFtcywgKF9hMiA9IHBhcmFtcy5pdikgIT0gbnVsbCA/IF9hMiA6IG51bGwsIGxvZ2dlcilcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIENyeXB0bzIuQ2lwaGVyUGFyYW1zID0gQ2lwaGVyUGFyYW1zO1xuICBDcnlwdG8yO1xuICBjbGFzcyBDQkNDaXBoZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcywgaXYsIGxvZ2dlcikge1xuICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICB0aGlzLmVuY3J5cHRDaXBoZXIgPSBudWxsO1xuICAgICAgdGhpcy5hbGdvcml0aG0gPSBwYXJhbXMuYWxnb3JpdGhtICsgXCItXCIgKyBTdHJpbmcocGFyYW1zLmtleUxlbmd0aCkgKyBcIi1cIiArIHBhcmFtcy5tb2RlO1xuICAgICAgdGhpcy5rZXkgPSBwYXJhbXMua2V5O1xuICAgICAgdGhpcy5pdiA9IGl2O1xuICAgIH1cbiAgICBhc3luYyBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlDUk8sIFwiQ0JDQ2lwaGVyLmVuY3J5cHQoKVwiLCBcIlwiKTtcbiAgICAgIGNvbnN0IGl2ID0gYXdhaXQgdGhpcy5nZXRJdigpO1xuICAgICAgaWYgKCF0aGlzLmVuY3J5cHRDaXBoZXIpIHtcbiAgICAgICAgdGhpcy5lbmNyeXB0Q2lwaGVyID0gaW1wb3J0X2NyeXB0bzIuZGVmYXVsdC5jcmVhdGVDaXBoZXJpdih0aGlzLmFsZ29yaXRobSwgdGhpcy5rZXksIGl2KTtcbiAgICAgIH1cbiAgICAgIHZhciBwbGFpbnRleHRCdWZmZXIgPSBidWZmZXJVdGlscy50b0J1ZmZlcihwbGFpbnRleHQpO1xuICAgICAgdmFyIHBsYWludGV4dExlbmd0aCA9IHBsYWludGV4dEJ1ZmZlci5sZW5ndGgsIHBhZGRlZExlbmd0aCA9IGdldFBhZGRlZExlbmd0aChwbGFpbnRleHRMZW5ndGgpO1xuICAgICAgdmFyIGNpcGhlck91dCA9IHRoaXMuZW5jcnlwdENpcGhlci51cGRhdGUoXG4gICAgICAgIEJ1ZmZlci5jb25jYXQoW3BsYWludGV4dEJ1ZmZlciwgcGtjczVQYWRkaW5nW3BhZGRlZExlbmd0aCAtIHBsYWludGV4dExlbmd0aF1dKVxuICAgICAgKTtcbiAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gQnVmZmVyLmNvbmNhdChbaXYsIGNpcGhlck91dF0pO1xuICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG4gICAgfVxuICAgIGFzeW5jIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgdmFyIGRlY3J5cHRDaXBoZXIgPSBpbXBvcnRfY3J5cHRvMi5kZWZhdWx0LmNyZWF0ZURlY2lwaGVyaXYodGhpcy5hbGdvcml0aG0sIHRoaXMua2V5LCBjaXBoZXJ0ZXh0LnNsaWNlKDAsIERFRkFVTFRfQkxPQ0tMRU5HVEgpKSwgcGxhaW50ZXh0ID0gZGVjcnlwdENpcGhlci51cGRhdGUoY2lwaGVydGV4dC5zbGljZShERUZBVUxUX0JMT0NLTEVOR1RIKSksIGZpbmFsID0gZGVjcnlwdENpcGhlci5maW5hbCgpO1xuICAgICAgaWYgKGZpbmFsICYmIGZpbmFsLmxlbmd0aClcbiAgICAgICAgcGxhaW50ZXh0ID0gQnVmZmVyLmNvbmNhdChbcGxhaW50ZXh0LCBmaW5hbF0pO1xuICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0SXYoKSB7XG4gICAgICBpZiAodGhpcy5pdikge1xuICAgICAgICB2YXIgaXYgPSB0aGlzLml2O1xuICAgICAgICB0aGlzLml2ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGl2O1xuICAgICAgfVxuICAgICAgdmFyIHJhbmRvbUJsb2NrID0gYXdhaXQgZ2VuZXJhdGVSYW5kb20oREVGQVVMVF9CTE9DS0xFTkdUSCk7XG4gICAgICBpZiAoIXRoaXMuZW5jcnlwdENpcGhlcikge1xuICAgICAgICByZXR1cm4gcmFuZG9tQmxvY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0Q2lwaGVyLnVwZGF0ZShyYW5kb21CbG9jayk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBDcnlwdG8yO1xufTtcblxuLy8gc3JjL3BsYXRmb3JtL25vZGVqcy9saWIvdXRpbC9odHRwLnRzXG52YXIgaW1wb3J0X2dvdCA9IF9fdG9FU00ocmVxdWlyZShcImdvdFwiKSk7XG52YXIgaW1wb3J0X2h0dHA1ID0gX190b0VTTShyZXF1aXJlKFwiaHR0cFwiKSk7XG52YXIgaW1wb3J0X2h0dHBzID0gX190b0VTTShyZXF1aXJlKFwiaHR0cHNcIikpO1xudmFyIGdsb2JhbEFnZW50UG9vbCA9IFtdO1xudmFyIF9hO1xudmFyIEh0dHAyID0gKF9hID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmFnZW50ID0gbnVsbDtcbiAgICB0aGlzLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSB0cnVlO1xuICAgIHRoaXMuc3VwcG9ydHNMaW5rSGVhZGVycyA9IHRydWU7XG4gICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgaWYgKChfYTIgPSB0aGlzLmNsaWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5vcHRpb25zLmRpc2FibGVDb25uZWN0aXZpdHlDaGVjaykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbm5lY3Rpdml0eUNoZWNrVXJsID0gKChfYiA9IHRoaXMuY2xpZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Iub3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybCkgfHwgZGVmYXVsdHNfZGVmYXVsdC5jb25uZWN0aXZpdHlDaGVja1VybDtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zID0gKF9kID0gKF9jID0gdGhpcy5jbGllbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5vcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zKSAhPSBudWxsID8gX2QgOiBudWxsO1xuICAgICAgY29uc3QgY29ubmVjdGl2aXR5VXJsSXNEZWZhdWx0ID0gISgoX2UgPSB0aGlzLmNsaWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwpO1xuICAgICAgY29uc3QgeyBlcnJvciwgc3RhdHVzQ29kZSwgYm9keSB9ID0gYXdhaXQgdGhpcy5kb1VyaShcbiAgICAgICAgSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsXG4gICAgICAgIGNvbm5lY3Rpdml0eUNoZWNrVXJsLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBjb25uZWN0aXZpdHlDaGVja1BhcmFtc1xuICAgICAgKTtcbiAgICAgIGlmICghZXJyb3IgJiYgIWNvbm5lY3Rpdml0eVVybElzRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gaXNTdWNjZXNzQ29kZShzdGF0dXNDb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhZXJyb3IgJiYgKGJvZHkgPT0gbnVsbCA/IHZvaWQgMCA6IGJvZHkudG9TdHJpbmcoKS50cmltKCkpID09PSBcInllc1wiO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQgIT0gbnVsbCA/IGNsaWVudCA6IG51bGw7XG4gIH1cbiAgYXN5bmMgZG9VcmkobWV0aG9kLCB1cmksIGhlYWRlcnMsIGJvZHksIHBhcmFtcykge1xuICAgIHZhciBfYTI7XG4gICAgY29uc3QgYWdlbnRPcHRpb25zID0gdGhpcy5jbGllbnQgJiYgdGhpcy5jbGllbnQub3B0aW9ucy5yZXN0QWdlbnRPcHRpb25zIHx8IGRlZmF1bHRzX2RlZmF1bHQucmVzdEFnZW50T3B0aW9ucztcbiAgICBjb25zdCBkb09wdGlvbnMgPSB7IGhlYWRlcnM6IGhlYWRlcnMgfHwgdm9pZCAwLCByZXNwb25zZVR5cGU6IFwiYnVmZmVyXCIgfTtcbiAgICBpZiAoIXRoaXMuYWdlbnQpIHtcbiAgICAgIGNvbnN0IHBlcnNpc3RlZEFnZW50ID0gKF9hMiA9IGdsb2JhbEFnZW50UG9vbC5maW5kKCh4KSA9PiBzaGFsbG93RXF1YWxzKGFnZW50T3B0aW9ucywgeC5vcHRpb25zKSkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuYWdlbnRzO1xuICAgICAgaWYgKHBlcnNpc3RlZEFnZW50KSB7XG4gICAgICAgIHRoaXMuYWdlbnQgPSBwZXJzaXN0ZWRBZ2VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWdlbnQgPSB7XG4gICAgICAgICAgaHR0cDogbmV3IGltcG9ydF9odHRwNS5kZWZhdWx0LkFnZW50KGFnZW50T3B0aW9ucyksXG4gICAgICAgICAgaHR0cHM6IG5ldyBpbXBvcnRfaHR0cHMuZGVmYXVsdC5BZ2VudChhZ2VudE9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgICAgIGdsb2JhbEFnZW50UG9vbC5wdXNoKHtcbiAgICAgICAgICBvcHRpb25zOiBhZ2VudE9wdGlvbnMsXG4gICAgICAgICAgYWdlbnRzOiB0aGlzLmFnZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYm9keSkge1xuICAgICAgZG9PcHRpb25zLmJvZHkgPSBib2R5O1xuICAgIH1cbiAgICBpZiAocGFyYW1zKVxuICAgICAgZG9PcHRpb25zLnNlYXJjaFBhcmFtcyA9IHBhcmFtcztcbiAgICBkb09wdGlvbnMuYWdlbnQgPSB0aGlzLmFnZW50O1xuICAgIGRvT3B0aW9ucy51cmwgPSB1cmk7XG4gICAgZG9PcHRpb25zLnRpbWVvdXQgPSB7XG4gICAgICByZXF1ZXN0OiAodGhpcy5jbGllbnQgJiYgdGhpcy5jbGllbnQub3B0aW9ucy50aW1lb3V0cyB8fCBkZWZhdWx0c19kZWZhdWx0LlRJTUVPVVRTKS5odHRwUmVxdWVzdFRpbWVvdXRcbiAgICB9O1xuICAgIGRvT3B0aW9ucy5yZXRyeSA9IHsgbGltaXQ6IDAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgaW1wb3J0X2dvdC5kZWZhdWx0W21ldGhvZF0oZG9PcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVyKG51bGwsIHJlcywgcmVzLmJvZHkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIGltcG9ydF9nb3QuZGVmYXVsdC5IVFRQRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZXIobnVsbCwgZXJyLnJlc3BvbnNlLCBlcnIucmVzcG9uc2UuYm9keSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlcihlcnIpO1xuICAgIH1cbiAgfVxuICBzaG91bGRGYWxsYmFjayhlcnIpIHtcbiAgICBjb25zdCB7IGNvZGUsIHN0YXR1c0NvZGUgfSA9IGVycjtcbiAgICByZXR1cm4gY29kZSA9PT0gXCJFTkVUVU5SRUFDSFwiIHx8IGNvZGUgPT09IFwiRUhPU1RVTlJFQUNIXCIgfHwgY29kZSA9PT0gXCJFSE9TVERPV05cIiB8fCBjb2RlID09PSBcIkVUSU1FRE9VVFwiIHx8IGNvZGUgPT09IFwiRVNPQ0tFVFRJTUVET1VUXCIgfHwgY29kZSA9PT0gXCJFTk9URk9VTkRcIiB8fCBjb2RlID09PSBcIkVDT05OUkVTRVRcIiB8fCBjb2RlID09PSBcIkVDT05OUkVGVVNFRFwiIHx8IHN0YXR1c0NvZGUgPj0gNTAwICYmIHN0YXR1c0NvZGUgPD0gNTA0O1xuICB9XG4gIF9oYW5kbGVyKGVyciwgcmVzcG9uc2UsIGJvZHkpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiB7IGVycm9yOiBlcnIgfTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c0NvZGUsIGhlYWRlcnMgPSByZXNwb25zZS5oZWFkZXJzO1xuICAgIGlmIChzdGF0dXNDb2RlID49IDMwMCkge1xuICAgICAgc3dpdGNoIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSB7XG4gICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi9qc29uXCI6XG4gICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi94LW1zZ3BhY2tcIjpcbiAgICAgICAgICBpZiAoISgoX2EyID0gdGhpcy5jbGllbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuX01zZ1BhY2spKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogY3JlYXRlTWlzc2luZ1BsdWdpbkVycm9yKFwiTXNnUGFja1wiKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBib2R5ID0gdGhpcy5jbGllbnQuX01zZ1BhY2suZGVjb2RlKGJvZHkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3IgPSBib2R5LmVycm9yID8gRXJyb3JJbmZvLmZyb21WYWx1ZXMoYm9keS5lcnJvcikgOiBuZXcgRXJyb3JJbmZvKFxuICAgICAgICBoZWFkZXJzW1wieC1hYmx5LWVycm9ybWVzc2FnZVwiXSB8fCBcIkVycm9yIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gc2VydmVyOiBcIiArIHN0YXR1c0NvZGUgKyBcIiBib2R5IHdhczogXCIgKyBQbGF0Zm9ybS5Db25maWcuaW5zcGVjdChib2R5KSxcbiAgICAgICAgTnVtYmVyKGhlYWRlcnNbXCJ4LWFibHktZXJyb3Jjb2RlXCJdKSxcbiAgICAgICAgc3RhdHVzQ29kZVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7IGVycm9yLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZDogdHJ1ZSwgc3RhdHVzQ29kZSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlcnJvcjogbnVsbCwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQ6IGZhbHNlLCBzdGF0dXNDb2RlIH07XG4gIH1cbn0sIF9hLm1ldGhvZHMgPSBbSHR0cE1ldGhvZHNfZGVmYXVsdC5HZXQsIEh0dHBNZXRob2RzX2RlZmF1bHQuRGVsZXRlLCBIdHRwTWV0aG9kc19kZWZhdWx0LlBvc3QsIEh0dHBNZXRob2RzX2RlZmF1bHQuUHV0LCBIdHRwTWV0aG9kc19kZWZhdWx0LlBhdGNoXSwgX2EubWV0aG9kc1dpdGhvdXRCb2R5ID0gW0h0dHBNZXRob2RzX2RlZmF1bHQuR2V0LCBIdHRwTWV0aG9kc19kZWZhdWx0LkRlbGV0ZV0sIF9hLm1ldGhvZHNXaXRoQm9keSA9IFtIdHRwTWV0aG9kc19kZWZhdWx0LlBvc3QsIEh0dHBNZXRob2RzX2RlZmF1bHQuUHV0LCBIdHRwTWV0aG9kc19kZWZhdWx0LlBhdGNoXSwgX2EpO1xudmFyIGh0dHBfZGVmYXVsdCA9IEh0dHAyO1xuXG4vLyBzcmMvcGxhdGZvcm0vbm9kZWpzL2NvbmZpZy50c1xudmFyIGltcG9ydF9jcnlwdG8zID0gX190b0VTTShyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbnZhciBpbXBvcnRfd3MgPSBfX3RvRVNNKHJlcXVpcmUoXCJ3c1wiKSk7XG52YXIgaW1wb3J0X3V0aWwyID0gX190b0VTTShyZXF1aXJlKFwidXRpbFwiKSk7XG52YXIgQ29uZmlnID0ge1xuICBhZ2VudDogXCJub2RlanMvXCIgKyBwcm9jZXNzLnZlcnNpb25zLm5vZGUsXG4gIGxvZ1RpbWVzdGFtcHM6IHRydWUsXG4gIHVzZXJBZ2VudDogbnVsbCxcbiAgYmluYXJ5VHlwZTogXCJub2RlYnVmZmVyXCIsXG4gIFdlYlNvY2tldDogaW1wb3J0X3dzLmRlZmF1bHQsXG4gIHVzZVByb3RvY29sSGVhcnRiZWF0czogZmFsc2UsXG4gIHN1cHBvcnRzQmluYXJ5OiB0cnVlLFxuICBwcmVmZXJCaW5hcnk6IHRydWUsXG4gIG5leHRUaWNrOiBwcm9jZXNzLm5leHRUaWNrLFxuICBpbnNwZWN0OiBpbXBvcnRfdXRpbDIuZGVmYXVsdC5pbnNwZWN0LFxuICBzdHJpbmdCeXRlU2l6ZTogQnVmZmVyLmJ5dGVMZW5ndGgsXG4gIGluaGVyaXRzOiBpbXBvcnRfdXRpbDIuZGVmYXVsdC5pbmhlcml0cyxcbiAgYWRkRXZlbnRMaXN0ZW5lcjogbnVsbCxcbiAgZ2V0UmFuZG9tQXJyYXlCdWZmZXI6IGFzeW5jIGZ1bmN0aW9uKGJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gaW1wb3J0X3V0aWwyLmRlZmF1bHQucHJvbWlzaWZ5KGltcG9ydF9jcnlwdG8zLmRlZmF1bHQucmFuZG9tQnl0ZXMpKGJ5dGVMZW5ndGgpO1xuICB9XG59O1xudmFyIGNvbmZpZ19kZWZhdWx0ID0gQ29uZmlnO1xuXG4vLyBzcmMvY29tbW9uL2NvbnN0YW50cy9YSFJTdGF0ZXMudHNcbnZhciBYSFJTdGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gKChYSFJTdGF0ZXMyKSA9PiB7XG4gIFhIUlN0YXRlczJbWEhSU3RhdGVzMltcIlJFUV9TRU5EXCJdID0gMF0gPSBcIlJFUV9TRU5EXCI7XG4gIFhIUlN0YXRlczJbWEhSU3RhdGVzMltcIlJFUV9SRUNWXCJdID0gMV0gPSBcIlJFUV9SRUNWXCI7XG4gIFhIUlN0YXRlczJbWEhSU3RhdGVzMltcIlJFUV9SRUNWX1BPTExcIl0gPSAyXSA9IFwiUkVRX1JFQ1ZfUE9MTFwiO1xuICBYSFJTdGF0ZXMyW1hIUlN0YXRlczJbXCJSRVFfUkVDVl9TVFJFQU1cIl0gPSAzXSA9IFwiUkVRX1JFQ1ZfU1RSRUFNXCI7XG4gIHJldHVybiBYSFJTdGF0ZXMyO1xufSkoWEhSU3RhdGVzIHx8IHt9KTtcbnZhciBYSFJTdGF0ZXNfZGVmYXVsdCA9IFhIUlN0YXRlcztcblxuLy8gc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L2NvbWV0dHJhbnNwb3J0LnRzXG5mdW5jdGlvbiBzaG91bGRCZUVycm9yQWN0aW9uKGVycikge1xuICBjb25zdCBVTlJFU09MVkFCTEVfRVJST1JfQ09ERVMgPSBbODAwMTUsIDgwMDE3LCA4MDAzMF07XG4gIGlmIChlcnIuY29kZSkge1xuICAgIGlmIChhdXRoX2RlZmF1bHQuaXNUb2tlbkVycihlcnIpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChVTlJFU09MVkFCTEVfRVJST1JfQ09ERVMuaW5jbHVkZXMoZXJyLmNvZGUpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGVyci5jb2RlID49IDRlNCAmJiBlcnIuY29kZSA8IDVlNDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpIHtcbiAgaWYgKHNob3VsZEJlRXJyb3JBY3Rpb24oZXJyKSkge1xuICAgIHJldHVybiBbZnJvbVZhbHVlcyh7IGFjdGlvbjogYWN0aW9ucy5FUlJPUiwgZXJyb3I6IGVyciB9KV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtmcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkRJU0NPTk5FQ1RFRCwgZXJyb3I6IGVyciB9KV07XG4gIH1cbn1cbnZhciBDb21ldFRyYW5zcG9ydCA9IGNsYXNzIGV4dGVuZHMgdHJhbnNwb3J0X2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgc3VwZXIoXG4gICAgICBjb25uZWN0aW9uTWFuYWdlcixcbiAgICAgIGF1dGgsXG4gICAgICBwYXJhbXMsXG4gICAgICAvKiBiaW5hcnkgbm90IHN1cHBvcnRlZCBmb3IgY29tZXQgc28gZm9yY2UgSlNPTiBwcm90b2NvbCAqL1xuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgLyogSGlzdG9yaWNhbCBjb21tZW50LCBiYWNrIGZyb20gd2hlbiB3ZSBzdXBwb3J0ZWQgSlNPTlA6XG4gICAgICpcbiAgICAgKiA+IEZvciBjb21ldCwgd2UgY291bGQgZG8gdGhlIGF1dGggdXBkYXRlIGJ5IGFib3J0aW5nIHRoZSBjdXJyZW50IHJlY3YgYW5kXG4gICAgICogPiBzdGFydGluZyBhIG5ldyBvbmUgd2l0aCB0aGUgbmV3IHRva2VuLCB0aGF0J2QgYmUgc3VmZmljaWVudCBmb3IgcmVhbHRpbWUuXG4gICAgICogPiBQcm9ibGVtIGlzIEpTT05QIC0geW91IGNhbid0IGNhbmNlbCB0cnVseSBhYm9ydCBhIHJlY3Ygb25jZSBzdGFydGVkLiBTb1xuICAgICAqID4gd2UgbmVlZCB0byBzZW5kIGFuIEFVVEggZm9yIGpzb25wLiBJbiB3aGljaCBjYXNlIGl0J3Mgc2ltcGxlciB0byBrZWVwIGFsbFxuICAgICAqID4gY29tZXQgdHJhbnNwb3J0cyB0aGUgc2FtZSBhbmQgZG8gaXQgZm9yIGFsbCBvZiB0aGVtLiBTbyB3ZSBzZW5kIHRoZSBBVVRIXG4gICAgICogPiBpbnN0ZWFkLCBhbmQgZG9uJ3QgbmVlZCB0byBhYm9ydCB0aGUgcmVjdlxuICAgICAqXG4gICAgICogTm93IHRoYXQgd2XigJl2ZSBkcm9wcGVkIEpTT05QIHN1cHBvcnQsIHdlIG1heSBiZSBhYmxlIHRvIHJldmlzaXQgdGhlIGFib3ZlO1xuICAgICAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzL2lzc3Vlcy8xMjE0LlxuICAgICAqL1xuICAgIHRoaXMub25BdXRoVXBkYXRlZCA9ICh0b2tlbkRldGFpbHMpID0+IHtcbiAgICAgIHRoaXMuYXV0aFBhcmFtcyA9IHsgYWNjZXNzX3Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW4gfTtcbiAgICB9O1xuICAgIHRoaXMuc3RyZWFtID0gXCJzdHJlYW1cIiBpbiBwYXJhbXMgPyBwYXJhbXMuc3RyZWFtIDogdHJ1ZTtcbiAgICB0aGlzLnNlbmRSZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdDYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xuICB9XG4gIGNvbm5lY3QoKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHRoaXMubG9nZ2VyLCBsb2dnZXJfZGVmYXVsdC5MT0dfTUlOT1IsIFwiQ29tZXRUcmFuc3BvcnQuY29ubmVjdCgpXCIsIFwic3RhcnRpbmdcIik7XG4gICAgdHJhbnNwb3J0X2RlZmF1bHQucHJvdG90eXBlLmNvbm5lY3QuY2FsbCh0aGlzKTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICBjb25zdCBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG4gICAgY29uc3QgaG9zdCA9IGRlZmF1bHRzX2RlZmF1bHQuZ2V0SG9zdChvcHRpb25zLCBwYXJhbXMuaG9zdCk7XG4gICAgY29uc3QgcG9ydCA9IGRlZmF1bHRzX2RlZmF1bHQuZ2V0UG9ydChvcHRpb25zKTtcbiAgICBjb25zdCBjb21ldFNjaGVtZSA9IG9wdGlvbnMudGxzID8gXCJodHRwczovL1wiIDogXCJodHRwOi8vXCI7XG4gICAgdGhpcy5iYXNlVXJpID0gY29tZXRTY2hlbWUgKyBob3N0ICsgXCI6XCIgKyBwb3J0ICsgXCIvY29tZXQvXCI7XG4gICAgY29uc3QgY29ubmVjdFVyaSA9IHRoaXMuYmFzZVVyaSArIFwiY29ubmVjdFwiO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKVwiLCBcInVyaTogXCIgKyBjb25uZWN0VXJpKTtcbiAgICB3aGVuUHJvbWlzZVNldHRsZXModGhpcy5hdXRoLmdldEF1dGhQYXJhbXMoKSwgKGVyciwgYXV0aFBhcmFtcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmF1dGhQYXJhbXMgPSBhdXRoUGFyYW1zO1xuICAgICAgY29uc3QgY29ubmVjdFBhcmFtcyA9IHRoaXMucGFyYW1zLmdldENvbm5lY3RQYXJhbXMoYXV0aFBhcmFtcyk7XG4gICAgICBpZiAoXCJzdHJlYW1cIiBpbiBjb25uZWN0UGFyYW1zKVxuICAgICAgICB0aGlzLnN0cmVhbSA9IGNvbm5lY3RQYXJhbXMuc3RyZWFtO1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLFxuICAgICAgICBcIkNvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKVwiLFxuICAgICAgICBcImNvbm5lY3RQYXJhbXM6XCIgKyB0b1F1ZXJ5U3RyaW5nKGNvbm5lY3RQYXJhbXMpXG4gICAgICApO1xuICAgICAgbGV0IHByZWNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgY29ubmVjdFJlcXVlc3QgPSB0aGlzLnJlY3ZSZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KFxuICAgICAgICBjb25uZWN0VXJpLFxuICAgICAgICBudWxsLFxuICAgICAgICBjb25uZWN0UGFyYW1zLFxuICAgICAgICBudWxsLFxuICAgICAgICB0aGlzLnN0cmVhbSA/IFhIUlN0YXRlc19kZWZhdWx0LlJFUV9SRUNWX1NUUkVBTSA6IFhIUlN0YXRlc19kZWZhdWx0LlJFUV9SRUNWXG4gICAgICApO1xuICAgICAgY29ubmVjdFJlcXVlc3Qub24oXCJkYXRhXCIsIChkYXRhKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5yZWN2UmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByZWNvbm5lY3RlZCkge1xuICAgICAgICAgIHByZWNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lbWl0KFwicHJlY29ubmVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgY29ubmVjdFJlcXVlc3Qub24oXCJjb21wbGV0ZVwiLCAoZXJyMikgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucmVjdlJlcXVlc3QpIHtcbiAgICAgICAgICBlcnIyID0gZXJyMiB8fCBuZXcgRXJyb3JJbmZvKFwiUmVxdWVzdCBjYW5jZWxsZWRcIiwgODAwMDMsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG4gICAgICAgIGlmICghcHJlY29ubmVjdGVkICYmICFlcnIyKSB7XG4gICAgICAgICAgcHJlY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJwcmVjb25uZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25BY3Rpdml0eSgpO1xuICAgICAgICBpZiAoZXJyMikge1xuICAgICAgICAgIGlmIChlcnIyLmNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdChlcnIyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZWN2KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25uZWN0UmVxdWVzdC5leGVjKCk7XG4gICAgfSk7XG4gIH1cbiAgcmVxdWVzdENsb3NlKCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIkNvbWV0VHJhbnNwb3J0LnJlcXVlc3RDbG9zZSgpXCIpO1xuICAgIHRoaXMuX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdCh0cnVlKTtcbiAgfVxuICByZXF1ZXN0RGlzY29ubmVjdCgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5yZXF1ZXN0RGlzY29ubmVjdCgpXCIpO1xuICAgIHRoaXMuX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdChmYWxzZSk7XG4gIH1cbiAgX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdChjbG9zaW5nKSB7XG4gICAgY29uc3QgY2xvc2VPckRpc2Nvbm5lY3RVcmkgPSBjbG9zaW5nID8gdGhpcy5jbG9zZVVyaSA6IHRoaXMuZGlzY29ubmVjdFVyaTtcbiAgICBpZiAoY2xvc2VPckRpc2Nvbm5lY3RVcmkpIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QoY2xvc2VPckRpc2Nvbm5lY3RVcmksIG51bGwsIHRoaXMuYXV0aFBhcmFtcywgbnVsbCwgWEhSU3RhdGVzX2RlZmF1bHQuUkVRX1NFTkQpO1xuICAgICAgcmVxdWVzdC5vbihcImNvbXBsZXRlXCIsIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgICAgXCJDb21ldFRyYW5zcG9ydC5yZXF1ZXN0XCIgKyAoY2xvc2luZyA/IFwiQ2xvc2UoKVwiIDogXCJEaXNjb25uZWN0KClcIiksXG4gICAgICAgICAgICBcInJlcXVlc3QgcmV0dXJuZWQgZXJyID0gXCIgKyBpbnNwZWN0RXJyb3IoZXJyKVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5maW5pc2goXCJkaXNjb25uZWN0ZWRcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXF1ZXN0LmV4ZWMoKTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5kaXNwb3NlKClcIiwgXCJcIik7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5yZWN2UmVxdWVzdCkge1xuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSU5PUiwgXCJDb21ldFRyYW5zcG9ydC5kaXNwb3NlKClcIiwgXCJhYm9ydGluZyByZWN2IHJlcXVlc3RcIik7XG4gICAgICAgIHRoaXMucmVjdlJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgdGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmZpbmlzaChcImRpc2Nvbm5lY3RlZFwiLCBjb25uZWN0aW9uZXJyb3JzX2RlZmF1bHQuZGlzY29ubmVjdGVkKCkpO1xuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGlzcG9zZWRcIik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25Db25uZWN0KG1lc3NhZ2UpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvblN0ciA9IChfYTIgPSBtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNvbm5lY3Rpb25LZXk7XG4gICAgdHJhbnNwb3J0X2RlZmF1bHQucHJvdG90eXBlLm9uQ29ubmVjdC5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IGJhc2VDb25uZWN0aW9uVXJpID0gdGhpcy5iYXNlVXJpICsgY29ubmVjdGlvblN0cjtcbiAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24odGhpcy5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19NSUNSTywgXCJDb21ldFRyYW5zcG9ydC5vbkNvbm5lY3QoKVwiLCBcImJhc2VVcmkgPSBcIiArIGJhc2VDb25uZWN0aW9uVXJpKTtcbiAgICB0aGlzLnNlbmRVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArIFwiL3NlbmRcIjtcbiAgICB0aGlzLnJlY3ZVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArIFwiL3JlY3ZcIjtcbiAgICB0aGlzLmNsb3NlVXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyBcIi9jbG9zZVwiO1xuICAgIHRoaXMuZGlzY29ubmVjdFVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgXCIvZGlzY29ubmVjdFwiO1xuICB9XG4gIHNlbmQobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLnNlbmRSZXF1ZXN0KSB7XG4gICAgICB0aGlzLnBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zIHx8IFtdO1xuICAgICAgdGhpcy5wZW5kaW5nSXRlbXMucHVzaChtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZ0l0ZW1zID0gdGhpcy5wZW5kaW5nSXRlbXMgfHwgW107XG4gICAgcGVuZGluZ0l0ZW1zLnB1c2gobWVzc2FnZSk7XG4gICAgdGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuc2VuZEl0ZW1zKHBlbmRpbmdJdGVtcyk7XG4gIH1cbiAgc2VuZEFueVBlbmRpbmcoKSB7XG4gICAgY29uc3QgcGVuZGluZ0l0ZW1zID0gdGhpcy5wZW5kaW5nSXRlbXM7XG4gICAgaWYgKCFwZW5kaW5nSXRlbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuc2VuZEl0ZW1zKHBlbmRpbmdJdGVtcyk7XG4gIH1cbiAgc2VuZEl0ZW1zKGl0ZW1zKSB7XG4gICAgY29uc3Qgc2VuZFJlcXVlc3QgPSB0aGlzLnNlbmRSZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KFxuICAgICAgdGhpcy5zZW5kVXJpLFxuICAgICAgbnVsbCxcbiAgICAgIHRoaXMuYXV0aFBhcmFtcyxcbiAgICAgIHRoaXMuZW5jb2RlUmVxdWVzdChpdGVtcyksXG4gICAgICBYSFJTdGF0ZXNfZGVmYXVsdC5SRVFfU0VORFxuICAgICk7XG4gICAgc2VuZFJlcXVlc3Qub24oXCJjb21wbGV0ZVwiLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyKVxuICAgICAgICBsb2dnZXJfZGVmYXVsdC5sb2dBY3Rpb24oXG4gICAgICAgICAgdGhpcy5sb2dnZXIsXG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICAgIFwiQ29tZXRUcmFuc3BvcnQuc2VuZEl0ZW1zKClcIixcbiAgICAgICAgICBcIm9uIGNvbXBsZXRlOiBlcnIgPSBcIiArIGluc3BlY3RFcnJvcihlcnIpXG4gICAgICAgICk7XG4gICAgICB0aGlzLnNlbmRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlKSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGVuZGluZ0l0ZW1zKSB7XG4gICAgICAgIFBsYXRmb3JtLkNvbmZpZy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLnNlbmRSZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRBbnlQZW5kaW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZW5kUmVxdWVzdC5leGVjKCk7XG4gIH1cbiAgcmVjdigpIHtcbiAgICBpZiAodGhpcy5yZWN2UmVxdWVzdClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcmVjdlJlcXVlc3QgPSB0aGlzLnJlY3ZSZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KFxuICAgICAgdGhpcy5yZWN2VXJpLFxuICAgICAgbnVsbCxcbiAgICAgIHRoaXMuYXV0aFBhcmFtcyxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLnN0cmVhbSA/IFhIUlN0YXRlc19kZWZhdWx0LlJFUV9SRUNWX1NUUkVBTSA6IFhIUlN0YXRlc19kZWZhdWx0LlJFUV9SRUNWX1BPTExcbiAgICApO1xuICAgIHJlY3ZSZXF1ZXN0Lm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuICAgICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgfSk7XG4gICAgcmVjdlJlcXVlc3Qub24oXCJjb21wbGV0ZVwiLCAoZXJyKSA9PiB7XG4gICAgICB0aGlzLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcbiAgICAgIHRoaXMub25BY3Rpdml0eSgpO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUpIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXNjb25uZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgUGxhdGZvcm0uQ29uZmlnLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZWN2KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZWN2UmVxdWVzdC5leGVjKCk7XG4gIH1cbiAgb25EYXRhKHJlc3BvbnNlRGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpdGVtcyA9IHRoaXMuZGVjb2RlUmVzcG9uc2UocmVzcG9uc2VEYXRhKTtcbiAgICAgIGlmIChpdGVtcyAmJiBpdGVtcy5sZW5ndGgpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgdGhpcy5vblByb3RvY29sTWVzc2FnZShcbiAgICAgICAgICAgIGZyb21EZXNlcmlhbGl6ZWQoXG4gICAgICAgICAgICAgIGl0ZW1zW2ldLFxuICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9SZWFsdGltZVByZXNlbmNlLFxuICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlYWx0aW1lLl9Bbm5vdGF0aW9uc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKFxuICAgICAgICB0aGlzLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLFxuICAgICAgICBcIkNvbWV0VHJhbnNwb3J0Lm9uRGF0YSgpXCIsXG4gICAgICAgIFwiVW5leHBlY3RlZCBleGNlcHRpb24gaGFuZGluZyBjaGFubmVsIGV2ZW50OiBcIiArIGUuc3RhY2tcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGVuY29kZVJlcXVlc3QocmVxdWVzdEl0ZW1zKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlcXVlc3RJdGVtcyk7XG4gIH1cbiAgZGVjb2RlUmVzcG9uc2UocmVzcG9uc2VEYXRhKSB7XG4gICAgaWYgKHR5cGVvZiByZXNwb25zZURhdGEgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3BvbnNlRGF0YSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlRGF0YTtcbiAgfVxufTtcbnZhciBjb21ldHRyYW5zcG9ydF9kZWZhdWx0ID0gQ29tZXRUcmFuc3BvcnQ7XG5cbi8vIHNyYy9wbGF0Zm9ybS9ub2RlanMvbGliL3RyYW5zcG9ydC9ub2RlY29tZXR0cmFuc3BvcnQuanNcbnZhciBpbXBvcnRfaHR0cDYgPSBfX3RvRVNNKHJlcXVpcmUoXCJodHRwXCIpKTtcbnZhciBpbXBvcnRfaHR0cHMyID0gX190b0VTTShyZXF1aXJlKFwiaHR0cHNcIikpO1xudmFyIGltcG9ydF91cmwgPSBfX3RvRVNNKHJlcXVpcmUoXCJ1cmxcIikpO1xudmFyIGltcG9ydF91dGlsMyA9IF9fdG9FU00ocmVxdWlyZShcInV0aWxcIikpO1xudmFyIG5vb3AzID0gZnVuY3Rpb24oKSB7XG59O1xudmFyIHNob3J0TmFtZTIgPSBUcmFuc3BvcnROYW1lcy5Db21ldDtcbnZhciBOb2RlQ29tZXRUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIGNvbWV0dHJhbnNwb3J0X2RlZmF1bHQge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG4gICAgdGhpcy5odHRwQWdlbnQgPSBudWxsO1xuICAgIHRoaXMuaHR0cHNBZ2VudCA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSAwO1xuICAgIHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lMjtcbiAgfVxuICBzdGF0aWMgaXNBdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiTm9kZUNvbWV0VHJhbnNwb3J0OyB1cmk9XCIgKyB0aGlzLmJhc2VVcmkgKyBcIjsgaXNDb25uZWN0ZWQ9XCIgKyB0aGlzLmlzQ29ubmVjdGVkICsgXCI7IGZvcm1hdD1cIiArIHRoaXMuZm9ybWF0ICsgXCI7IHN0cmVhbT1cIiArIHRoaXMuc3RyZWFtO1xuICB9XG4gIGdldEFnZW50KHRscykge1xuICAgIHZhciBwcm9wID0gdGxzID8gXCJodHRwc0FnZW50XCIgOiBcImh0dHBBZ2VudFwiLCBhZ2VudDIgPSB0aGlzW3Byb3BdO1xuICAgIGlmICghYWdlbnQyKVxuICAgICAgYWdlbnQyID0gdGhpc1twcm9wXSA9IG5ldyAodGxzID8gaW1wb3J0X2h0dHBzMi5kZWZhdWx0IDogaW1wb3J0X2h0dHA2LmRlZmF1bHQpLkFnZW50KHsga2VlcEFsaXZlOiB0cnVlIH0pO1xuICAgIHJldHVybiBhZ2VudDI7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB2YXIgc2VsZjIgPSB0aGlzO1xuICAgIHRoaXMub25jZU5vUGVuZGluZyhmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzZWxmMi5odHRwQWdlbnQpXG4gICAgICAgIHNlbGYyLmh0dHBBZ2VudC5kZXN0cm95KCk7XG4gICAgICBpZiAoc2VsZjIuaHR0cHNBZ2VudClcbiAgICAgICAgc2VsZjIuaHR0cHNBZ2VudC5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgY29tZXR0cmFuc3BvcnRfZGVmYXVsdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9XG4gIC8qIHZhbGlkIGluIG5vbi1zdHJlYW1pbmcgbW9kZSBvbmx5LCBvciBkYXRhIG9ubHkgY29udGFpbnMgbGFzdCB1cGRhdGUgKi9cbiAgcmVxdWVzdCh1cmksIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlcSA9IHRoaXMuY3JlYXRlUmVxdWVzdCh1cmksIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUpO1xuICAgIHJlcS5vbmNlKFwiY29tcGxldGVcIiwgY2FsbGJhY2spO1xuICAgIHJlcS5leGVjKCk7XG4gICAgcmV0dXJuIHJlcTtcbiAgfVxuICBjcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRoaXMuZm9ybWF0LCB0aGlzLnRpbWVvdXRzLCB0aGlzKTtcbiAgfVxuICBhZGRQZW5kaW5nKCkge1xuICAgICsrdGhpcy5wZW5kaW5nUmVxdWVzdHM7XG4gIH1cbiAgcmVtb3ZlUGVuZGluZygpIHtcbiAgICBpZiAoLS10aGlzLnBlbmRpbmdSZXF1ZXN0cyA8PSAwKSB7XG4gICAgICB0aGlzLmVtaXQoXCJub3BlbmRpbmdcIik7XG4gICAgfVxuICB9XG4gIG9uY2VOb1BlbmRpbmcobGlzdGVuZXIpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nUmVxdWVzdHMgPT0gMCkge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vbmNlKFwibm9wZW5kaW5nXCIsIGxpc3RlbmVyKTtcbiAgfVxufTtcbnZhciBSZXF1ZXN0ID0gY2xhc3MgZXh0ZW5kcyBldmVudGVtaXR0ZXJfZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgZm9ybWF0LCB0aW1lb3V0cywgdHJhbnNwb3J0KSB7XG4gICAgc3VwZXIodHJhbnNwb3J0LmxvZ2dlcik7XG4gICAgaWYgKHR5cGVvZiB1cmkgPT0gXCJzdHJpbmdcIilcbiAgICAgIHVyaSA9IGltcG9ydF91cmwuZGVmYXVsdC5wYXJzZSh1cmkpO1xuICAgIHZhciB0bHMgPSB1cmkucHJvdG9jb2wgPT0gXCJodHRwczpcIjtcbiAgICB0aGlzLmNsaWVudCA9IHRscyA/IGltcG9ydF9odHRwczIuZGVmYXVsdCA6IGltcG9ydF9odHRwNi5kZWZhdWx0O1xuICAgIHRoaXMucmVxdWVzdE1vZGUgPSByZXF1ZXN0TW9kZTtcbiAgICB0aGlzLnRpbWVvdXRzID0gdGltZW91dHM7XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5yZXF1ZXN0Q29tcGxldGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlcSA9IHRoaXMucmVzID0gbnVsbDtcbiAgICB2YXIgbWV0aG9kID0gXCJHRVRcIiwgY29udGVudFR5cGUgPSBmb3JtYXQgPT0gXCJtc2dwYWNrXCIgPyBcImFwcGxpY2F0aW9uL3gtbXNncGFja1wiIDogXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgaGVhZGVycyA9IGhlYWRlcnMgPyBtaXhpbih7fSwgaGVhZGVycykgOiB7fTtcbiAgICBoZWFkZXJzW1wiYWNjZXB0XCJdID0gY29udGVudFR5cGU7XG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIG1ldGhvZCA9IFwiUE9TVFwiO1xuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgICBib2R5ID0gQnVmZmVyLmZyb20oYm9keSk7XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdID0gYm9keS5sZW5ndGg7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gY29udGVudFR5cGU7XG4gICAgfVxuICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHRoaXMucmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICBob3N0bmFtZTogdXJpLmhvc3RuYW1lLFxuICAgICAgcG9ydDogdXJpLnBvcnQsXG4gICAgICBwYXRoOiB1cmkucGF0aCArIHRvUXVlcnlTdHJpbmcocGFyYW1zKSxcbiAgICAgIG1ldGhvZCxcbiAgICAgIGhlYWRlcnNcbiAgICB9O1xuICAgIGlmICh0cmFuc3BvcnQpXG4gICAgICByZXF1ZXN0T3B0aW9ucy5hZ2VudCA9IHRyYW5zcG9ydC5nZXRBZ2VudCh0bHMpO1xuICB9XG4gIGV4ZWMoKSB7XG4gICAgdmFyIHRpbWVvdXQgPSB0aGlzLnJlcXVlc3RNb2RlID09IFhIUlN0YXRlc19kZWZhdWx0LlJFUV9TRU5EID8gdGhpcy50aW1lb3V0cy5odHRwUmVxdWVzdFRpbWVvdXQgOiB0aGlzLnRpbWVvdXRzLnJlY3ZUaW1lb3V0LCBzZWxmMiA9IHRoaXM7XG4gICAgdmFyIHRpbWVyID0gdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmMi5hYm9ydCgpO1xuICAgIH0sIHRpbWVvdXQpLCByZXEgPSB0aGlzLnJlcSA9IHRoaXMuY2xpZW50LnJlcXVlc3QodGhpcy5yZXF1ZXN0T3B0aW9ucyk7XG4gICAgcmVxLm9uKFxuICAgICAgXCJlcnJvclwiLFxuICAgICAgdGhpcy5vblJlcUVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGVyciA9IG5ldyBQYXJ0aWFsRXJyb3JJbmZvKFwiUmVxdWVzdCBlcnJvcjogXCIgKyBlcnIubWVzc2FnZSwgbnVsbCwgNDAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgc2VsZjIudGltZXIgPSBudWxsO1xuICAgICAgICBzZWxmMi5jb21wbGV0ZShlcnIpO1xuICAgICAgfVxuICAgICk7XG4gICAgcmVxLm9uKFwicmVzcG9uc2VcIiwgZnVuY3Rpb24ocmVzKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgc2VsZjIudGltZXIgPSBudWxsO1xuICAgICAgdmFyIHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzQ29kZTtcbiAgICAgIGlmIChzdGF0dXNDb2RlID09IEh0dHBTdGF0dXNDb2Rlc19kZWZhdWx0Lk5vQ29udGVudCkge1xuICAgICAgICByZXMucmVzdW1lKCk7XG4gICAgICAgIHNlbGYyLmNvbXBsZXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlcy5vbihcbiAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICBzZWxmMi5vblJlc0Vycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgZXJyID0gbmV3IFBhcnRpYWxFcnJvckluZm8oXCJSZXNwb25zZSBlcnJvcjogXCIgKyBlcnIubWVzc2FnZSwgbnVsbCwgNDAwKTtcbiAgICAgICAgICBzZWxmMi5jb21wbGV0ZShlcnIpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgc2VsZjIucmVzID0gcmVzO1xuICAgICAgaWYgKHNlbGYyLnJlcXVlc3RNb2RlID09IFhIUlN0YXRlc19kZWZhdWx0LlJFUV9SRUNWX1NUUkVBTSAmJiBzdGF0dXNDb2RlIDwgNDAwKSB7XG4gICAgICAgIHNlbGYyLnJlYWRTdHJlYW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYyLnJlYWRGdWxseSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0aGlzLnRyYW5zcG9ydClcbiAgICAgIHRoaXMudHJhbnNwb3J0LmFkZFBlbmRpbmcoKTtcbiAgICByZXEuZW5kKHRoaXMuYm9keSk7XG4gIH1cbiAgcmVhZFN0cmVhbSgpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5yZXMsIHNlbGYyID0gdGhpcztcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHRoaXMuc3RyZWFtQ29tcGxldGUgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBvbkNodW5rKGNodW5rKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjaHVuayA9IEpTT04ucGFyc2UoY2h1bmspO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB2YXIgbXNnID0gXCJNYWxmb3JtZWQgcmVzcG9uc2UgYm9keSBmcm9tIHNlcnZlcjogXCIgKyBlLm1lc3NhZ2U7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbihzZWxmMi5sb2dnZXIsIGxvZ2dlcl9kZWZhdWx0LkxPR19FUlJPUiwgXCJOb2RlQ29tZXRUcmFuc3BvcnQuUmVxdWVzdC5yZWFkU3RyZWFtKClcIiwgbXNnKTtcbiAgICAgICAgc2VsZjIuY29tcGxldGUobmV3IFBhcnRpYWxFcnJvckluZm8obXNnLCBudWxsLCA0MDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VsZjIuZW1pdChcImRhdGFcIiwgY2h1bmspO1xuICAgIH1cbiAgICByZXMub24oXG4gICAgICBcImRhdGFcIixcbiAgICAgIHRoaXMub25kYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgbmV3Q2h1bmtzID0gU3RyaW5nKGRhdGEpLnNwbGl0KFwiXFxuXCIpLCBjaHVua3MgPSBzZWxmMi5jaHVua3M7XG4gICAgICAgIGlmIChuZXdDaHVua3MubGVuZ3RoID4gMSAmJiBjaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNodW5rcy5wdXNoKG5ld0NodW5rcy5zaGlmdCgpKTtcbiAgICAgICAgICBzZWxmMi5jaHVua3MgPSBbXTtcbiAgICAgICAgICBvbkNodW5rKGNodW5rcy5qb2luKFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhaWxpbmdOZXdDaHVuayA9IG5ld0NodW5rcy5wb3AoKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nTmV3Q2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgc2VsZjIuY2h1bmtzLnB1c2godHJhaWxpbmdOZXdDaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Q2h1bmtzLm1hcChvbkNodW5rKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJlcy5vbihcImVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYyLnN0cmVhbUNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYyLmNvbXBsZXRlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZWFkRnVsbHkoKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMucmVzLCBjaHVua3MgPSBbXSwgc2VsZjIgPSB0aGlzO1xuICAgIHJlcy5vbihcImRhdGFcIiwgZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB9KTtcbiAgICByZXMub24oXCJlbmRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYm9keSA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzKSwgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKFN0cmluZyhib2R5KSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB2YXIgbXNnID0gXCJNYWxmb3JtZWQgcmVzcG9uc2UgYm9keSBmcm9tIHNlcnZlcjogXCIgKyBlLm1lc3NhZ2U7XG4gICAgICAgICAgbG9nZ2VyX2RlZmF1bHQubG9nQWN0aW9uKHNlbGYyLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX0VSUk9SLCBcIk5vZGVDb21ldFRyYW5zcG9ydC5SZXF1ZXN0LnJlYWRGdWxseSgpXCIsIG1zZyk7XG4gICAgICAgICAgc2VsZjIuY29tcGxldGUobmV3IFBhcnRpYWxFcnJvckluZm8obXNnLCBudWxsLCA0MDApKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCA0MDAgfHwgQXJyYXkuaXNBcnJheShib2R5KSkge1xuICAgICAgICAgIHNlbGYyLmNvbXBsZXRlKG51bGwsIGJvZHkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyID0gYm9keS5lcnJvciAmJiBFcnJvckluZm8uZnJvbVZhbHVlcyhib2R5LmVycm9yKTtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgUGFydGlhbEVycm9ySW5mbyhcbiAgICAgICAgICAgIFwiRXJyb3IgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6IFwiICsgc3RhdHVzQ29kZSArIFwiLCBib2R5IHdhczogXCIgKyBpbXBvcnRfdXRpbDMuZGVmYXVsdC5pbnNwZWN0KGJvZHkpLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHN0YXR1c0NvZGVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYyLmNvbXBsZXRlKGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBjb21wbGV0ZShlcnIsIGJvZHkpIHtcbiAgICBpZiAoIXRoaXMucmVxdWVzdENvbXBsZXRlKSB7XG4gICAgICB0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IHRydWU7XG4gICAgICBpZiAoYm9keSlcbiAgICAgICAgdGhpcy5lbWl0KFwiZGF0YVwiLCBib2R5KTtcbiAgICAgIHRoaXMuZW1pdChcImNvbXBsZXRlXCIsIGVyciwgYm9keSk7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLm9uZGF0YSAmJiAhdGhpcy5zdHJlYW1Db21wbGV0ZSkge1xuICAgICAgICAgIGlmICh0aGlzLm9uZGF0YSAmJiB0aGlzLnJlcylcbiAgICAgICAgICAgIHRoaXMucmVzLnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCB0aGlzLm9uZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVQZW5kaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFib3J0KCkge1xuICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIk5vZGVDb21ldFRyYW5zcG9ydC5SZXF1ZXN0LmFib3J0KClcIiwgXCJcIik7XG4gICAgdmFyIHRpbWVyID0gdGhpcy50aW1lcjtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJlcSA9IHRoaXMucmVxO1xuICAgIGlmIChyZXEpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmxvZ0FjdGlvbih0aGlzLmxvZ2dlciwgbG9nZ2VyX2RlZmF1bHQuTE9HX01JTk9SLCBcIk5vZGVDb21ldFRyYW5zcG9ydC5SZXF1ZXN0LmFib3J0KClcIiwgXCJhYm9ydGluZyByZXF1ZXN0XCIpO1xuICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5vblJlcUVycm9yKTtcbiAgICAgIHJlcS5vbihcImVycm9yXCIsIG5vb3AzKTtcbiAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgdGhpcy5yZXEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNvbXBsZXRlKHsgc3RhdHVzQ29kZTogNDAwLCBjb2RlOiA4MDAwMywgbWVzc2FnZTogXCJDYW5jZWxsZWRcIiB9KTtcbiAgfVxufTtcbnZhciBub2RlY29tZXR0cmFuc3BvcnRfZGVmYXVsdCA9IE5vZGVDb21ldFRyYW5zcG9ydDtcblxuLy8gc3JjL3BsYXRmb3JtL25vZGVqcy9saWIvdHJhbnNwb3J0L2luZGV4LnRzXG52YXIgdHJhbnNwb3J0X2RlZmF1bHQyID0ge1xuICBvcmRlcjogW1RyYW5zcG9ydE5hbWVzLkNvbWV0XSxcbiAgYnVuZGxlZEltcGxlbWVudGF0aW9uczoge1xuICAgIFtUcmFuc3BvcnROYW1lcy5XZWJTb2NrZXRdOiB3ZWJzb2NrZXR0cmFuc3BvcnRfZGVmYXVsdCxcbiAgICBbVHJhbnNwb3J0TmFtZXMuQ29tZXRdOiBub2RlY29tZXR0cmFuc3BvcnRfZGVmYXVsdFxuICB9XG59O1xuXG4vLyBzcmMvcGxhdGZvcm0vbm9kZWpzL2xpYi91dGlsL2RlZmF1bHRzLnRzXG52YXIgRGVmYXVsdHMyID0ge1xuICBjb25uZWN0aXZpdHlDaGVja1VybDogXCJodHRwczovL2ludGVybmV0LXVwLmFibHktcmVhbHRpbWUuY29tL2lzLXRoZS1pbnRlcm5ldC11cC50eHRcIixcbiAgd3NDb25uZWN0aXZpdHlDaGVja1VybDogXCJ3c3M6Ly93cy11cC5hYmx5LXJlYWx0aW1lLmNvbVwiLFxuICAvKiBOb3RlOiBvcmRlciBtYXR0ZXJzIGhlcmU6IHRoZSBiYXNlIHRyYW5zcG9ydCBpcyB0aGUgbGVmdG1vc3Qgb25lIGluIHRoZVxuICAgKiBpbnRlcnNlY3Rpb24gb2YgYmFzZVRyYW5zcG9ydE9yZGVyIGFuZCB0aGUgdHJhbnNwb3J0cyBjbGllbnRPcHRpb24gdGhhdCdzIHN1cHBvcnRlZC4gKi9cbiAgZGVmYXVsdFRyYW5zcG9ydHM6IFtUcmFuc3BvcnROYW1lcy5XZWJTb2NrZXRdLFxuICByZXN0QWdlbnRPcHRpb25zOiB7IG1heFNvY2tldHM6IDQwLCBrZWVwQWxpdmU6IHRydWUgfVxufTtcbnZhciBkZWZhdWx0c19kZWZhdWx0MiA9IERlZmF1bHRzMjtcblxuLy8gc3JjL3BsYXRmb3JtL25vZGVqcy9pbmRleC50c1xudmFyIG1zZ3BhY2sgPSByZXF1aXJlX21zZ3BhY2soKTtcbnZhciBDcnlwdG8gPSBjcmVhdGVDcnlwdG9DbGFzcyhidWZmZXJ1dGlsc19kZWZhdWx0KTtcblBsYXRmb3JtLkNyeXB0byA9IENyeXB0bztcblBsYXRmb3JtLkJ1ZmZlclV0aWxzID0gYnVmZmVydXRpbHNfZGVmYXVsdDtcblBsYXRmb3JtLkh0dHAgPSBodHRwX2RlZmF1bHQ7XG5QbGF0Zm9ybS5Db25maWcgPSBjb25maWdfZGVmYXVsdDtcblBsYXRmb3JtLlRyYW5zcG9ydHMgPSB0cmFuc3BvcnRfZGVmYXVsdDI7XG5QbGF0Zm9ybS5XZWJTdG9yYWdlID0gbnVsbDtcbmZvciAoY29uc3QgY2xpZW50Q2xhc3Mgb2YgW0RlZmF1bHRSZXN0LCBEZWZhdWx0UmVhbHRpbWVdKSB7XG4gIGNsaWVudENsYXNzLkNyeXB0byA9IENyeXB0bztcbiAgY2xpZW50Q2xhc3MuX01zZ1BhY2sgPSBtc2dwYWNrO1xufVxubG9nZ2VyX2RlZmF1bHQuaW5pdExvZ0hhbmRsZXJzKCk7XG5QbGF0Zm9ybS5EZWZhdWx0cyA9IGdldERlZmF1bHRzKGRlZmF1bHRzX2RlZmF1bHQyKTtcbmlmIChQbGF0Zm9ybS5Db25maWcuYWdlbnQpIHtcbiAgUGxhdGZvcm0uRGVmYXVsdHMuYWdlbnQgKz0gXCIgXCIgKyBQbGF0Zm9ybS5Db25maWcuYWdlbnQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRXJyb3JJbmZvLFxuICBSZXN0OiBEZWZhdWx0UmVzdCxcbiAgUmVhbHRpbWU6IERlZmF1bHRSZWFsdGltZSxcbiAgbXNncGFjazogbnVsbCxcbiAgcHJvdG9jb2xNZXNzYWdlRnJvbURlc2VyaWFsaXplZDogZnJvbURlc2VyaWFsaXplZEluY2x1ZGluZ0RlcGVuZGVuY2llc1xufTtcbmlmICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiKSB7XG4gIHZhciBfX2NwID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgICBpZiAoKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIpIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhmcm9tKSkge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBrZXksIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IGZyb21ba2V5XSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhKGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0bztcbiAgfTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX2NwKG1vZHVsZS5leHBvcnRzLCBleHBvcnRzKTtcbn1cbnJldHVybiBtb2R1bGUuZXhwb3J0cztcbn0pKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJseS1ub2RlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/build/ably-node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ably/node_modules/ws/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/websocket.js\");\n\nWebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/stream.js\");\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/websocket-server.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/sender.js\");\n\nWebSocket.WebSocket = WebSocket;\nWebSocket.WebSocketServer = WebSocket.Server;\n\nmodule.exports = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsbUZBQWlCOztBQUUzQyxrQ0FBa0MsbUJBQU8sQ0FBQyw2RUFBYztBQUN4RCxtQkFBbUIsbUJBQU8sQ0FBQyxpR0FBd0I7QUFDbkQscUJBQXFCLG1CQUFPLENBQUMsaUZBQWdCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLDZFQUFjOztBQUV6QztBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcSGFja2F0aG9uXFxIYWNrc3BpcmVcXG5vZGVfbW9kdWxlc1xcYWJseVxcbm9kZV9tb2R1bGVzXFx3c1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQnKTtcblxuV2ViU29ja2V0LmNyZWF0ZVdlYlNvY2tldFN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3N0cmVhbScpO1xuV2ViU29ja2V0LlNlcnZlciA9IHJlcXVpcmUoJy4vbGliL3dlYnNvY2tldC1zZXJ2ZXInKTtcbldlYlNvY2tldC5SZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3JlY2VpdmVyJyk7XG5XZWJTb2NrZXQuU2VuZGVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyJyk7XG5cbldlYlNvY2tldC5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG5XZWJTb2NrZXQuV2ViU29ja2V0U2VydmVyID0gV2ViU29ja2V0LlNlcnZlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/node_modules/ws/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ably/node_modules/ws/lib/buffer-util.js":
/*!**************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/buffer-util.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/constants.js\");\n\nconst FastBuffer = Buffer[Symbol.species];\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) {\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\n  }\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = __webpack_require__(/*! bufferutil */ \"?053c\");\n\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bufferUtil.mask(source, mask, output, offset, length);\n    };\n\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsK0VBQWE7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMseUJBQVk7O0FBRTNDLElBQUksbUJBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcSGFja2F0aG9uXFxIYWNrc3BpcmVcXG5vZGVfbW9kdWxlc1xcYWJseVxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFxidWZmZXItdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcblxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgYnVmZmVycyBpbnRvIGEgbmV3IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBhcnJheSBvZiBidWZmZXJzIHRvIGNvbmNhdFxuICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsTGVuZ3RoIFRoZSB0b3RhbCBsZW5ndGggb2YgYnVmZmVycyBpbiB0aGUgbGlzdFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgcmVzdWx0aW5nIGJ1ZmZlclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjb25jYXQobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHJldHVybiBsaXN0WzBdO1xuXG4gIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJ1ZiA9IGxpc3RbaV07XG4gICAgdGFyZ2V0LnNldChidWYsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGJ1Zi5sZW5ndGg7XG4gIH1cblxuICBpZiAob2Zmc2V0IDwgdG90YWxMZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIodGFyZ2V0LmJ1ZmZlciwgdGFyZ2V0LmJ5dGVPZmZzZXQsIG9mZnNldCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIE1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBzb3VyY2UgVGhlIGJ1ZmZlciB0byBtYXNrXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBvdXRwdXQgVGhlIGJ1ZmZlciB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgd3JpdGluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIG1hc2suXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0W29mZnNldCArIGldID0gc291cmNlW2ldIF4gbWFza1tpICYgM107XG4gIH1cbn1cblxuLyoqXG4gKiBVbm1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byB1bm1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfdW5tYXNrKGJ1ZmZlciwgbWFzaykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZlcltpXSBePSBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYnVmZmVyIHRvIGFuIGBBcnJheUJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBDb252ZXJ0ZWQgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gYnVmLmJ1ZmZlcjtcbiAgfVxuXG4gIHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5sZW5ndGgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBkYXRhYCB0byBhIGBCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBidWZmZXJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9CdWZmZXIoZGF0YSkge1xuICB0b0J1ZmZlci5yZWFkT25seSA9IHRydWU7XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgcmV0dXJuIGRhdGE7XG5cbiAgbGV0IGJ1ZjtcblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgYnVmID0gbmV3IEZhc3RCdWZmZXIoZGF0YSk7XG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgYnVmID0gbmV3IEZhc3RCdWZmZXIoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICB0b0J1ZmZlci5yZWFkT25seSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbmNhdCxcbiAgbWFzazogX21hc2ssXG4gIHRvQXJyYXlCdWZmZXIsXG4gIHRvQnVmZmVyLFxuICB1bm1hc2s6IF91bm1hc2tcbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuaWYgKCFwcm9jZXNzLmVudi5XU19OT19CVUZGRVJfVVRJTCkge1xuICB0cnkge1xuICAgIGNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCdidWZmZXJ1dGlsJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5tYXNrID0gZnVuY3Rpb24gKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA8IDQ4KSBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgZWxzZSBidWZmZXJVdGlsLm1hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMudW5tYXNrID0gZnVuY3Rpb24gKGJ1ZmZlciwgbWFzaykge1xuICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPCAzMikgX3VubWFzayhidWZmZXIsIG1hc2spO1xuICAgICAgZWxzZSBidWZmZXJVdGlsLnVubWFzayhidWZmZXIsIG1hc2spO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBDb250aW51ZSByZWdhcmRsZXNzIG9mIHRoZSBlcnJvci5cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ably/node_modules/ws/lib/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/constants.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\nconst hasBlob = typeof Blob !== 'undefined';\n\nif (hasBlob) BINARY_TYPES.push('blob');\n\nmodule.exports = {\n  BINARY_TYPES,\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  hasBlob,\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYWNrYXRob25cXEhhY2tzcGlyZVxcbm9kZV9tb2R1bGVzXFxhYmx5XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJJTkFSWV9UWVBFUyA9IFsnbm9kZWJ1ZmZlcicsICdhcnJheWJ1ZmZlcicsICdmcmFnbWVudHMnXTtcbmNvbnN0IGhhc0Jsb2IgPSB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCc7XG5cbmlmIChoYXNCbG9iKSBCSU5BUllfVFlQRVMucHVzaCgnYmxvYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVI6IEJ1ZmZlci5hbGxvYygwKSxcbiAgR1VJRDogJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScsXG4gIGhhc0Jsb2IsXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlOiBTeW1ib2woJ2tJc0Zvck9uRXZlbnRBdHRyaWJ1dGUnKSxcbiAga0xpc3RlbmVyOiBTeW1ib2woJ2tMaXN0ZW5lcicpLFxuICBrU3RhdHVzQ29kZTogU3ltYm9sKCdzdGF0dXMtY29kZScpLFxuICBrV2ViU29ja2V0OiBTeW1ib2woJ3dlYnNvY2tldCcpLFxuICBOT09QOiAoKSA9PiB7fVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ably/node_modules/ws/lib/event-target.js":
/*!***************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/event-target.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/constants.js\");\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (\n        !options[kForOnEventAttribute] &&\n        listener[kListener] === handler &&\n        !listener[kForOnEventAttribute]\n      ) {\n        return;\n      }\n    }\n\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = handler;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === 'object' && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLGtDQUFrQyxFQUFFLG1CQUFPLENBQUMsK0VBQWE7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsa0JBQWtCO0FBQ3JFLGlEQUFpRCxrQkFBa0I7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFzRCxrQkFBa0I7QUFDeEUsd0RBQXdELGtCQUFrQjtBQUMxRSwwREFBMEQsa0JBQWtCOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsa0JBQWtCO0FBQ3pFLHlEQUF5RCxrQkFBa0I7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RCxrQkFBa0I7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLEdBQUc7QUFDZCxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYWNrYXRob25cXEhhY2tzcGlyZVxcbm9kZV9tb2R1bGVzXFxhYmx5XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXGV2ZW50LXRhcmdldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsga0Zvck9uRXZlbnRBdHRyaWJ1dGUsIGtMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga0NvZGUgPSBTeW1ib2woJ2tDb2RlJyk7XG5jb25zdCBrRGF0YSA9IFN5bWJvbCgna0RhdGEnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgna0Vycm9yJyk7XG5jb25zdCBrTWVzc2FnZSA9IFN5bWJvbCgna01lc3NhZ2UnKTtcbmNvbnN0IGtSZWFzb24gPSBTeW1ib2woJ2tSZWFzb24nKTtcbmNvbnN0IGtUYXJnZXQgPSBTeW1ib2woJ2tUYXJnZXQnKTtcbmNvbnN0IGtUeXBlID0gU3ltYm9sKCdrVHlwZScpO1xuY29uc3Qga1dhc0NsZWFuID0gU3ltYm9sKCdrV2FzQ2xlYW4nKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG4gKi9cbmNsYXNzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICB0aGlzW2tUYXJnZXRdID0gbnVsbDtcbiAgICB0aGlzW2tUeXBlXSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgdGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2tUYXJnZXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpc1trVHlwZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3RhcmdldCcsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICd0eXBlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNsb3NlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYENsb3NlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2RlPTBdIFRoZSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVhc29uPScnXSBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeVxuICAgKiAgICAgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndhc0NsZWFuPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbGVhbmx5IGNsb3NlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tDb2RlXSA9IG9wdGlvbnMuY29kZSA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMuY29kZTtcbiAgICB0aGlzW2tSZWFzb25dID0gb3B0aW9ucy5yZWFzb24gPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5yZWFzb247XG4gICAgdGhpc1trV2FzQ2xlYW5dID0gb3B0aW9ucy53YXNDbGVhbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLndhc0NsZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29kZSgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29kZV07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCByZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXNba1JlYXNvbl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgd2FzQ2xlYW4oKSB7XG4gICAgcmV0dXJuIHRoaXNba1dhc0NsZWFuXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdjb2RlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAncmVhc29uJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnd2FzQ2xlYW4nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGVycm9yIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEVycm9yRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZXJyb3I9bnVsbF0gVGhlIGVycm9yIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2U9JyddIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0Vycm9yXSA9IG9wdGlvbnMuZXJyb3IgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmVycm9yO1xuICAgIHRoaXNba01lc3NhZ2VdID0gb3B0aW9ucy5tZXNzYWdlID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMubWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gdGhpc1trRXJyb3JdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpc1trTWVzc2FnZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnZXJyb3InLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdtZXNzYWdlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1lc3NhZ2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZGF0YT1udWxsXSBUaGUgbWVzc2FnZSBjb250ZW50XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0RhdGFdID0gb3B0aW9ucy5kYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXNba0RhdGFdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlRXZlbnQucHJvdG90eXBlLCAnZGF0YScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGVtdWxhdGluZyB0aGUgYEV2ZW50VGFyZ2V0YCBpbnRlcmZhY2UuIEl0J3Mgbm90XG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBFdmVudFRhcmdldCA9IHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0XG4gICAqICAgICB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gICAqICAgICBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmcgYWRkZWQuIElmIGB0cnVlYCxcbiAgICogICAgIHRoZSBsaXN0ZW5lciB3b3VsZCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBpbnZva2VkLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdICYmXG4gICAgICAgIGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiZcbiAgICAgICAgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd3JhcHBlcjtcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KCdtZXNzYWdlJywge1xuICAgICAgICAgIGRhdGE6IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScsIHtcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIHJlYXNvbjogbWVzc2FnZS50b1N0cmluZygpLFxuICAgICAgICAgIHdhc0NsZWFuOiB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgJiYgdGhpcy5fY2xvc2VGcmFtZVNlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEVycm9yRXZlbnQoJ2Vycm9yJywge1xuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ29wZW4nKTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3JhcHBlcltrRm9yT25FdmVudEF0dHJpYnV0ZV0gPSAhIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdO1xuICAgIHdyYXBwZXJba0xpc3RlbmVyXSA9IGhhbmRsZXI7XG5cbiAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICB0aGlzLm9uY2UodHlwZSwgd3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24odHlwZSwgd3JhcHBlcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gaGFuZGxlciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChsaXN0ZW5lcltrTGlzdGVuZXJdID09PSBoYW5kbGVyICYmICFsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENsb3NlRXZlbnQsXG4gIEVycm9yRXZlbnQsXG4gIEV2ZW50LFxuICBFdmVudFRhcmdldCxcbiAgTWVzc2FnZUV2ZW50XG59O1xuXG4vKipcbiAqIENhbGwgYW4gZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2FsbFxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSB2YWx1ZSB0byB1c2UgYXMgYHRoaXNgYCB3aGVuIGNhbGxpbmcgdGhlIGxpc3RlbmVyXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgdGhpc0FyZywgZXZlbnQpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCcgJiYgbGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcbiAgICBsaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKGxpc3RlbmVyLCBldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzQXJnLCBldmVudCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ably/node_modules/ws/lib/extension.js":
/*!************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/extension.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/validation.js\");\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (\n        i !== 0 &&\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n      ) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLGlGQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsbUJBQW1CO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNEJBQTRCO0FBQ3BDO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSLCtEQUErRCxFQUFFO0FBQ2pFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSLCtEQUErRCxFQUFFO0FBQ2pFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLGlFQUFpRSxFQUFFO0FBQ25FO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsK0RBQStELEVBQUU7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsRUFBRSxHQUFHLEVBQUU7QUFDMUQsMkJBQTJCO0FBQzNCLGVBQWU7QUFDZjtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIkM6XFxIYWNrYXRob25cXEhhY2tzcGlyZVxcbm9kZV9tb2R1bGVzXFxhYmx5XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXGV4dGVuc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGkgIT09IDAgJiZcbiAgICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgICApIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QgLyogJz0nICovICYmIHN0YXJ0ICE9PSAtMSAmJiBlbmQgPT09IC0xKSB7XG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIFRoZSB2YWx1ZSBvZiBhIHF1b3RlZC1zdHJpbmcgYWZ0ZXIgdW5lc2NhcGluZyBtdXN0IGNvbmZvcm0gdG8gdGhlXG4gICAgICAvLyB0b2tlbiBBQk5GLCBzbyBvbmx5IHRva2VuIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgICAgLy9cbiAgICAgIGlmIChpc0VzY2FwaW5nKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKSBtdXN0VW5lc2NhcGUgPSB0cnVlO1xuICAgICAgICBpc0VzY2FwaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAmJiBoZWFkZXIuY2hhckNvZGVBdChpIC0gMSkgPT09IDB4M2QpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgbGV0IHZhbHVlID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgICAgICBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcyB8fCBjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ably/node_modules/ws/lib/limiter.js":
/*!**********************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/limiter.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxIYWNrYXRob25cXEhhY2tzcGlyZVxcbm9kZV9tb2R1bGVzXFxhYmx5XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXGxpbWl0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBrRG9uZSA9IFN5bWJvbCgna0RvbmUnKTtcbmNvbnN0IGtSdW4gPSBTeW1ib2woJ2tSdW4nKTtcblxuLyoqXG4gKiBBIHZlcnkgc2ltcGxlIGpvYiBxdWV1ZSB3aXRoIGFkanVzdGFibGUgY29uY3VycmVuY3kuIEFkYXB0ZWQgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL1NUUk1ML2FzeW5jLWxpbWl0ZXJcbiAqL1xuY2xhc3MgTGltaXRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBMaW1pdGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25jdXJyZW5jeT1JbmZpbml0eV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZFxuICAgKiAgICAgdG8gcnVuIGNvbmN1cnJlbnRseVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcbiAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZy0tO1xuICAgICAgdGhpc1trUnVuXSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5IHx8IEluZmluaXR5O1xuICAgIHRoaXMuam9icyA9IFtdO1xuICAgIHRoaXMucGVuZGluZyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGpvYiBUaGUgam9iIHRvIHJ1blxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGQoam9iKSB7XG4gICAgdGhpcy5qb2JzLnB1c2goam9iKTtcbiAgICB0aGlzW2tSdW5dKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGpvYiBmcm9tIHRoZSBxdWV1ZSBhbmQgcnVucyBpdCBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFtrUnVuXSgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nID09PSB0aGlzLmNvbmN1cnJlbmN5KSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMucGVuZGluZysrO1xuICAgICAgam9iKHRoaXNba0RvbmVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMaW1pdGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ably/node_modules/ws/lib/permessage-deflate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/permessage-deflate.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/limiter.js\");\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/constants.js\");\n\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) {\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n      }\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLG1CQUFtQixtQkFBTyxDQUFDLG1GQUFlO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFXO0FBQ25DLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsK0VBQWE7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxJQUFJLEtBQUssTUFBTTtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSw4Q0FBOEMsSUFBSSxLQUFLLE1BQU07QUFDN0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSSxLQUFLLE1BQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSSxLQUFLLE1BQU07QUFDN0Q7QUFDQTtBQUNBLFVBQVU7QUFDVixnREFBZ0QsSUFBSTtBQUNwRDs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYWNrYXRob25cXEhhY2tzcGlyZVxcbm9kZV9tb2R1bGVzXFxhYmx5XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHBlcm1lc3NhZ2UtZGVmbGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCBMaW1pdGVyID0gcmVxdWlyZSgnLi9saW1pdGVyJyk7XG5jb25zdCB7IGtTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcbmNvbnN0IFRSQUlMRVIgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHhmZiwgMHhmZl0pO1xuY29uc3Qga1Blck1lc3NhZ2VEZWZsYXRlID0gU3ltYm9sKCdwZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IGtUb3RhbExlbmd0aCA9IFN5bWJvbCgndG90YWwtbGVuZ3RoJyk7XG5jb25zdCBrQ2FsbGJhY2sgPSBTeW1ib2woJ2NhbGxiYWNrJyk7XG5jb25zdCBrQnVmZmVycyA9IFN5bWJvbCgnYnVmZmVycycpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xuXG4vL1xuLy8gV2UgbGltaXQgemxpYiBjb25jdXJyZW5jeSwgd2hpY2ggcHJldmVudHMgc2V2ZXJlIG1lbW9yeSBmcmFnbWVudGF0aW9uXG4vLyBhcyBkb2N1bWVudGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvODg3MSNpc3N1ZWNvbW1lbnQtMjUwOTE1OTEzXG4vLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzEyMDJcbi8vXG4vLyBJbnRlbnRpb25hbGx5IGdsb2JhbDsgaXQncyB0aGUgZ2xvYmFsIHRocmVhZCBwb29sIHRoYXQncyBhbiBpc3N1ZS5cbi8vXG5sZXQgemxpYkxpbWl0ZXI7XG5cbi8qKlxuICogcGVybWVzc2FnZS1kZWZsYXRlIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBQZXJNZXNzYWdlRGVmbGF0ZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUGVyTWVzc2FnZURlZmxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0c10gQWR2ZXJ0aXNlIHN1cHBvcnRcbiAgICogICAgIGZvciwgb3IgcmVxdWVzdCwgYSBjdXN0b20gY2xpZW50IHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXI9ZmFsc2VdIEFkdmVydGlzZS9cbiAgICogICAgIGFja25vd2xlZGdlIGRpc2FibGluZyBvZiBjbGllbnQgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29uY3VycmVuY3lMaW1pdD0xMF0gVGhlIG51bWJlciBvZiBjb25jdXJyZW50XG4gICAqICAgICBjYWxscyB0byB6bGliXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0c10gUmVxdWVzdC9jb25maXJtIHRoZVxuICAgKiAgICAgdXNlIG9mIGEgY3VzdG9tIHNlcnZlciB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBSZXF1ZXN0L2FjY2VwdFxuICAgKiAgICAgZGlzYWJsaW5nIG9mIHNlcnZlciBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aHJlc2hvbGQ9MTAyNF0gU2l6ZSAoaW4gYnl0ZXMpIGJlbG93IHdoaWNoXG4gICAqICAgICBtZXNzYWdlcyBzaG91bGQgbm90IGJlIGNvbXByZXNzZWQgaWYgY29udGV4dCB0YWtlb3ZlciBpcyBkaXNhYmxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuICAgKiAgICAgZGVmbGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuICAgKiAgICAgaW5mbGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1NlcnZlcj1mYWxzZV0gQ3JlYXRlIHRoZSBpbnN0YW5jZSBpbiBlaXRoZXIgc2VydmVyIG9yXG4gICAqICAgICBjbGllbnQgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaXNTZXJ2ZXIsIG1heFBheWxvYWQpIHtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fdGhyZXNob2xkID1cbiAgICAgIHRoaXMuX29wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCA6IDEwMjQ7XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIWlzU2VydmVyO1xuICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuXG4gICAgaWYgKCF6bGliTGltaXRlcikge1xuICAgICAgY29uc3QgY29uY3VycmVuY3kgPVxuICAgICAgICB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0XG4gICAgICAgICAgOiAxMDtcbiAgICAgIHpsaWJMaW1pdGVyID0gbmV3IExpbWl0ZXIoY29uY3VycmVuY3kpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBleHRlbnNpb25OYW1lKCkge1xuICAgIHJldHVybiAncGVybWVzc2FnZS1kZWZsYXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEV4dGVuc2lvbiBwYXJhbWV0ZXJzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG9mZmVyKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT0gbnVsbCkge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci9yZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWNjZXB0KGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMgPSB0aGlzLm5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucyk7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHRoaXMuX2lzU2VydmVyXG4gICAgICA/IHRoaXMuYWNjZXB0QXNTZXJ2ZXIoY29uZmlndXJhdGlvbnMpXG4gICAgICA6IHRoaXMuYWNjZXB0QXNDbGllbnQoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXMucGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFsbCByZXNvdXJjZXMgdXNlZCBieSB0aGUgZXh0ZW5zaW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLl9pbmZsYXRlKSB7XG4gICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZCdcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqICBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBvZmZlcnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnNcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc1NlcnZlcihvZmZlcnMpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5fb3B0aW9ucztcbiAgICBjb25zdCBhY2NlcHRlZCA9IG9mZmVycy5maW5kKChwYXJhbXMpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyKSB8fFxuICAgICAgICAocGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgJiZcbiAgICAgICAgICAob3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA+IHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzKSkpIHx8XG4gICAgICAgICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKCFhY2NlcHRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb25lIG9mIHRoZSBleHRlbnNpb24gb2ZmZXJzIGNhbiBiZSBhY2NlcHRlZCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRzLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX21heF93aW5kb3dfYml0cyA9IG9wdHMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID09PSB0cnVlIHx8XG4gICAgICBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlXG4gICAgKSB7XG4gICAgICBkZWxldGUgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cztcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjZXB0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IHRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3BvbnNlIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc0NsaWVudChyZXNwb25zZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHJlc3BvbnNlWzBdO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhcmFtZXRlciBcImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA+IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VuZXhwZWN0ZWQgb3IgaW52YWxpZCBwYXJhbWV0ZXIgXCJjbGllbnRfbWF4X3dpbmRvd19iaXRzXCInXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBvZmZlcnMvcmVzcG9uc2Ugd2l0aCBub3JtYWxpemVkIHBhcmFtZXRlcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zLmZvckVhY2goKHBhcmFtcykgPT4ge1xuICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1zW2tleV07XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7a2V5fVwiIG11c3QgaGF2ZSBvbmx5IGEgc2luZ2xlIHZhbHVlYCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGllbnRfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1NlcnZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NlcnZlcl9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcicgfHxcbiAgICAgICAgICBrZXkgPT09ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBcIiR7a2V5fVwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29uZmlndXJhdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9kZWNvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9jb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG5cbiAgICBpZiAoIXRoaXMuX2luZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5faW5mbGF0ZSA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2luZmxhdGVba1Blck1lc3NhZ2VEZWZsYXRlXSA9IHRoaXM7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2Vycm9yJywgaW5mbGF0ZU9uRXJyb3IpO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2luZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5faW5mbGF0ZS53cml0ZShkYXRhKTtcbiAgICBpZiAoZmluKSB0aGlzLl9pbmZsYXRlLndyaXRlKFRSQUlMRVIpO1xuXG4gICAgdGhpcy5faW5mbGF0ZS5mbHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLl9pbmZsYXRlW2tFcnJvcl07XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLl9pbmZsYXRlLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgICAgdGhpcy5faW5mbGF0ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdzZXJ2ZXInIDogJ2NsaWVudCc7XG5cbiAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZSA9IHpsaWIuY3JlYXRlRGVmbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUub24oJ2RhdGEnLCBkZWZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2RlZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgdGhpcy5fZGVmbGF0ZS5mbHVzaCh6bGliLlpfU1lOQ19GTFVTSCwgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgLy9cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAoZmluKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmxlbmd0aCAtIDQpO1xuICAgICAgfVxuXG4gICAgICAvL1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCBhZ2FpbiBpblxuICAgICAgLy8gYFBlck1lc3NhZ2VEZWZsYXRlI2NsZWFudXAoKWAuXG4gICAgICAvL1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gbnVsbDtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICB0aGlzLl9kZWZsYXRlLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVyTWVzc2FnZURlZmxhdGU7XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5EZWZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG5cbiAgaWYgKFxuICAgIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZCA8IDEgfHxcbiAgICB0aGlzW2tUb3RhbExlbmd0aF0gPD0gdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkXG4gICkge1xuICAgIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXNba0Vycm9yXSA9IG5ldyBSYW5nZUVycm9yKCdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyk7XG4gIHRoaXNba0Vycm9yXS5jb2RlID0gJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCc7XG4gIHRoaXNba0Vycm9yXVtrU3RhdHVzQ29kZV0gPSAxMDA5O1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25FcnJvcihlcnIpIHtcbiAgLy9cbiAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGBabGliI2Nsb3NlKClgIGFzIHRoZSBoYW5kbGUgaXMgYXV0b21hdGljYWxseVxuICAvLyBjbG9zZWQgd2hlbiBhbiBlcnJvciBpcyBlbWl0dGVkLlxuICAvL1xuICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX2luZmxhdGUgPSBudWxsO1xuICBlcnJba1N0YXR1c0NvZGVdID0gMTAwNztcbiAgdGhpc1trQ2FsbGJhY2tdKGVycik7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ably/node_modules/ws/lib/receiver.js":
/*!***********************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/receiver.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/validation.js\");\n\nconst FastBuffer = Buffer[Symbol.species];\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst DEFER_EVENT = 6;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n\n    this._allowSynchronousEvents =\n      options.allowSynchronousEvents !== undefined\n        ? options.allowSynchronousEvents\n        : true;\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._errored = false;\n    this._loop = false;\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(\n        buf.buffer,\n        buf.byteOffset + n,\n        buf.length - n\n      );\n\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(\n          buf.buffer,\n          buf.byteOffset + n,\n          buf.length - n\n        );\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64(cb);\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData(cb);\n          break;\n        case INFLATING:\n        case DEFER_EVENT:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    if (!this._errored) cb();\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getInfo(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      const error = this.createError(\n        RangeError,\n        'RSV2 and RSV3 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_2_3'\n      );\n\n      cb(error);\n      return;\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      const error = this.createError(\n        RangeError,\n        'RSV1 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_1'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (!this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          'invalid opcode 0',\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        const error = this.createError(\n          RangeError,\n          'FIN must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_FIN'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (\n        this._payloadLength > 0x7d ||\n        (this._opcode === 0x08 && this._payloadLength === 1)\n      ) {\n        const error = this.createError(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    } else {\n      const error = this.createError(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        'WS_ERR_INVALID_OPCODE'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        const error = this.createError(\n          RangeError,\n          'MASK must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_MASK'\n        );\n\n        cb(error);\n        return;\n      }\n    } else if (this._masked) {\n      const error = this.createError(\n        RangeError,\n        'MASK must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_MASK'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength16(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength64(cb) {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      const error = this.createError(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009,\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  haveLength(cb) {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        const error = this.createError(\n          RangeError,\n          'Max payload size exceeded',\n          false,\n          1009,\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n\n      if (\n        this._masked &&\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\n      ) {\n        unmask(data, this._mask);\n      }\n    }\n\n    if (this._opcode > 0x07) {\n      this.controlMessage(data, cb);\n      return;\n    }\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    this.dataMessage(cb);\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          const error = this.createError(\n            RangeError,\n            'Max payload size exceeded',\n            false,\n            1009,\n            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._fragments.push(buf);\n      }\n\n      this.dataMessage(cb);\n      if (this._state === GET_INFO) this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  dataMessage(cb) {\n    if (!this._fin) {\n      this._state = GET_INFO;\n      return;\n    }\n\n    const messageLength = this._messageLength;\n    const fragments = this._fragments;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragmented = 0;\n    this._fragments = [];\n\n    if (this._opcode === 2) {\n      let data;\n\n      if (this._binaryType === 'nodebuffer') {\n        data = concat(fragments, messageLength);\n      } else if (this._binaryType === 'arraybuffer') {\n        data = toArrayBuffer(concat(fragments, messageLength));\n      } else if (this._binaryType === 'blob') {\n        data = new Blob(fragments);\n      } else {\n        data = fragments;\n      }\n\n      if (this._allowSynchronousEvents) {\n        this.emit('message', data, true);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', data, true);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    } else {\n      const buf = concat(fragments, messageLength);\n\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n        const error = this.createError(\n          Error,\n          'invalid UTF-8 sequence',\n          true,\n          1007,\n          'WS_ERR_INVALID_UTF8'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\n        this.emit('message', buf, false);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', buf, false);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    }\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data, cb) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this._loop = false;\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          const error = this.createError(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            'WS_ERR_INVALID_CLOSE_CODE'\n          );\n\n          cb(error);\n          return;\n        }\n\n        const buf = new FastBuffer(\n          data.buffer,\n          data.byteOffset + 2,\n          data.length - 2\n        );\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          const error = this.createError(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._loop = false;\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n\n      this._state = GET_INFO;\n      return;\n    }\n\n    if (this._allowSynchronousEvents) {\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n      this._state = GET_INFO;\n    } else {\n      this._state = DEFER_EVENT;\n      setImmediate(() => {\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n        this._state = GET_INFO;\n        this.startLoop(cb);\n      });\n    }\n  }\n\n  /**\n   * Builds an error object.\n   *\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n   * @param {String} message The error message\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n   *     `message`\n   * @param {Number} statusCode The status code\n   * @param {String} errorCode The exposed error code\n   * @return {(Error|RangeError)} The error\n   * @private\n   */\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n    this._loop = false;\n    this._errored = true;\n\n    const err = new ErrorCtor(\n      prefix ? `Invalid WebSocket frame: ${message}` : message\n    );\n\n    Error.captureStackTrace(err, this.createError);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n  }\n}\n\nmodule.exports = Receiver;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRXJDLDBCQUEwQixtQkFBTyxDQUFDLGlHQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsK0VBQWE7QUFDekIsUUFBUSxnQ0FBZ0MsRUFBRSxtQkFBTyxDQUFDLG1GQUFlO0FBQ2pFLFFBQVEsaUNBQWlDLEVBQUUsbUJBQU8sQ0FBQyxpRkFBYzs7QUFFakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxIYWNrYXRob25cXEhhY2tzcGlyZVxcbm9kZV9tb2R1bGVzXFxhYmx5XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHJlY2VpdmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0XG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgY29uY2F0LCB0b0FycmF5QnVmZmVyLCB1bm1hc2sgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUsIGlzVmFsaWRVVEY4IH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5cbmNvbnN0IEdFVF9JTkZPID0gMDtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF8xNiA9IDE7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfNjQgPSAyO1xuY29uc3QgR0VUX01BU0sgPSAzO1xuY29uc3QgR0VUX0RBVEEgPSA0O1xuY29uc3QgSU5GTEFUSU5HID0gNTtcbmNvbnN0IERFRkVSX0VWRU5UID0gNjtcblxuLyoqXG4gKiBIeUJpIFJlY2VpdmVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBleHRlbmRzIFdyaXRhYmxlXG4gKi9cbmNsYXNzIFJlY2VpdmVyIGV4dGVuZHMgV3JpdGFibGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlY2VpdmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJpbmFyeVR5cGU9bm9kZWJ1ZmZlcl0gVGhlIHR5cGUgZm9yIGJpbmFyeSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5leHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZFxuICAgKiAgICAgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzU2VydmVyPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0byBvcGVyYXRlIGluXG4gICAqICAgICBjbGllbnQgb3Igc2VydmVyIG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cyA9XG4gICAgICBvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50c1xuICAgICAgICA6IHRydWU7XG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IG9wdGlvbnMuYmluYXJ5VHlwZSB8fCBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IG9wdGlvbnMuZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhb3B0aW9ucy5pc1NlcnZlcjtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gb3B0aW9ucy5tYXhQYXlsb2FkIHwgMDtcbiAgICB0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gPSAhIW9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uO1xuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9idWZmZXJzID0gW107XG5cbiAgICB0aGlzLl9jb21wcmVzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWFzayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICB0aGlzLl9tYXNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9maW4gPSBmYWxzZTtcbiAgICB0aGlzLl9vcGNvZGUgPSAwO1xuXG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgIHRoaXMuX2Vycm9yZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIGBXcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlKClgLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgVGhlIGNodW5rIG9mIGRhdGEgdG8gd3JpdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kaW5nIFRoZSBjaGFyYWN0ZXIgZW5jb2Rpbmcgb2YgYGNodW5rYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4ICYmIHRoaXMuX3N0YXRlID09IEdFVF9JTkZPKSByZXR1cm4gY2IoKTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMuX2J1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWVzIGBuYCBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGNvbnN1bWVcbiAgICogQHJldHVybiB7QnVmZmVyfSBUaGUgY29uc3VtZWQgYnl0ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN1bWUobikge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gbjtcblxuICAgIGlmIChuID09PSB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2J1ZmZlcnMuc2hpZnQoKTtcblxuICAgIGlmIChuIDwgdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICB0aGlzLl9idWZmZXJzWzBdID0gbmV3IEZhc3RCdWZmZXIoXG4gICAgICAgIGJ1Zi5idWZmZXIsXG4gICAgICAgIGJ1Zi5ieXRlT2Zmc2V0ICsgbixcbiAgICAgICAgYnVmLmxlbmd0aCAtIG5cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbik7XG4gICAgfVxuXG4gICAgY29uc3QgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuXG4gICAgZG8ge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGRzdC5sZW5ndGggLSBuO1xuXG4gICAgICBpZiAobiA+PSBidWYubGVuZ3RoKSB7XG4gICAgICAgIGRzdC5zZXQodGhpcy5fYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHN0LnNldChuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbiksIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgICBidWYuYnVmZmVyLFxuICAgICAgICAgIGJ1Zi5ieXRlT2Zmc2V0ICsgbixcbiAgICAgICAgICBidWYubGVuZ3RoIC0gblxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBuIC09IGJ1Zi5sZW5ndGg7XG4gICAgfSB3aGlsZSAobiA+IDApO1xuXG4gICAgcmV0dXJuIGRzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHBhcnNpbmcgbG9vcC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0TG9vcChjYikge1xuICAgIHRoaXMuX2xvb3AgPSB0cnVlO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICBjYXNlIEdFVF9JTkZPOlxuICAgICAgICAgIHRoaXMuZ2V0SW5mbyhjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzE2OlxuICAgICAgICAgIHRoaXMuZ2V0UGF5bG9hZExlbmd0aDE2KGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ6XG4gICAgICAgICAgdGhpcy5nZXRQYXlsb2FkTGVuZ3RoNjQoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9NQVNLOlxuICAgICAgICAgIHRoaXMuZ2V0TWFzaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9EQVRBOlxuICAgICAgICAgIHRoaXMuZ2V0RGF0YShjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSU5GTEFUSU5HOlxuICAgICAgICBjYXNlIERFRkVSX0VWRU5UOlxuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSB3aGlsZSAodGhpcy5fbG9vcCk7XG5cbiAgICBpZiAoIXRoaXMuX2Vycm9yZWQpIGNiKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIGZpcnN0IHR3byBieXRlcyBvZiBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SW5mbyhjYikge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSgyKTtcblxuICAgIGlmICgoYnVmWzBdICYgMHgzMCkgIT09IDB4MDApIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1JTVjIgYW5kIFJTVjMgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMl8zJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXByZXNzZWQgPSAoYnVmWzBdICYgMHg0MCkgPT09IDB4NDA7XG5cbiAgICBpZiAoY29tcHJlc3NlZCAmJiAhdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2ZpbiA9IChidWZbMF0gJiAweDgwKSA9PT0gMHg4MDtcbiAgICB0aGlzLl9vcGNvZGUgPSBidWZbMF0gJiAweDBmO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBidWZbMV0gJiAweDdmO1xuXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMCkge1xuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdpbnZhbGlkIG9wY29kZSAwJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb3Bjb2RlID0gdGhpcy5fZnJhZ21lbnRlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMSB8fCB0aGlzLl9vcGNvZGUgPT09IDB4MDIpIHtcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb21wcmVzc2VkID0gY29tcHJlc3NlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcgJiYgdGhpcy5fb3Bjb2RlIDwgMHgwYikge1xuICAgICAgaWYgKCF0aGlzLl9maW4pIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ0ZJTiBtdXN0IGJlIHNldCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfRVhQRUNURURfRklOJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPiAweDdkIHx8XG4gICAgICAgICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMSlcbiAgICAgICkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAke3RoaXMuX3BheWxvYWRMZW5ndGh9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9maW4gJiYgIXRoaXMuX2ZyYWdtZW50ZWQpIHRoaXMuX2ZyYWdtZW50ZWQgPSB0aGlzLl9vcGNvZGU7XG4gICAgdGhpcy5fbWFza2VkID0gKGJ1ZlsxXSAmIDB4ODApID09PSAweDgwO1xuXG4gICAgaWYgKHRoaXMuX2lzU2VydmVyKSB7XG4gICAgICBpZiAoIXRoaXMuX21hc2tlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTUFTSyBtdXN0IGJlIHNldCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfRVhQRUNURURfTUFTSydcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21hc2tlZCkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnTUFTSyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX01BU0snXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNikgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY7XG4gICAgZWxzZSBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI3KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF82NDtcbiAgICBlbHNlIHRoaXMuaGF2ZUxlbmd0aChjYik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNysxNikuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoMTYoY2IpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gdGhpcy5jb25zdW1lKDIpLnJlYWRVSW50MTZCRSgwKTtcbiAgICB0aGlzLmhhdmVMZW5ndGgoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrNjQpLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGF5bG9hZExlbmd0aDY0KGNiKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA4KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDgpO1xuICAgIGNvbnN0IG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMCk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBtYXhpbXVtIHNhZmUgaW50ZWdlciBpbiBKYXZhU2NyaXB0IGlzIDJeNTMgLSAxLiBBbiBlcnJvciBpcyByZXR1cm5lZFxuICAgIC8vIGlmIHBheWxvYWQgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB0aGlzIG51bWJlci5cbiAgICAvL1xuICAgIGlmIChudW0gPiBNYXRoLnBvdygyLCA1MyAtIDMyKSAtIDEpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIFdlYlNvY2tldCBmcmFtZTogcGF5bG9hZCBsZW5ndGggPiAyXjUzIC0gMScsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAxMDA5LFxuICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX0RBVEFfUEFZTE9BRF9MRU5HVEgnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IG51bSAqIE1hdGgucG93KDIsIDMyKSArIGJ1Zi5yZWFkVUludDMyQkUoNCk7XG4gICAgdGhpcy5oYXZlTGVuZ3RoKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXlsb2FkIGxlbmd0aCBoYXMgYmVlbiByZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGF2ZUxlbmd0aChjYikge1xuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoICYmIHRoaXMuX29wY29kZSA8IDB4MDgpIHtcbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCArPSB0aGlzLl9wYXlsb2FkTGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIDEwMDksXG4gICAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbWFza2VkKSB0aGlzLl9zdGF0ZSA9IEdFVF9NQVNLO1xuICAgIGVsc2UgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBtYXNrIGJ5dGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TWFzaygpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDQpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXNrID0gdGhpcy5jb25zdW1lKDQpO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgZGF0YSBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldERhdGEoY2IpIHtcbiAgICBsZXQgZGF0YSA9IEVNUFRZX0JVRkZFUjtcblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSB0aGlzLmNvbnN1bWUodGhpcy5fcGF5bG9hZExlbmd0aCk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fbWFza2VkICYmXG4gICAgICAgICh0aGlzLl9tYXNrWzBdIHwgdGhpcy5fbWFza1sxXSB8IHRoaXMuX21hc2tbMl0gfCB0aGlzLl9tYXNrWzNdKSAhPT0gMFxuICAgICAgKSB7XG4gICAgICAgIHVubWFzayhkYXRhLCB0aGlzLl9tYXNrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNykge1xuICAgICAgdGhpcy5jb250cm9sTWVzc2FnZShkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXG4gICAgICAvLyBsZW5ndGggb2YgYWxsIGZyYWdtZW50cy5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhTWVzc2FnZShjYik7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzc2VzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVjb21wcmVzcyhkYXRhLCBjYikge1xuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmRlY29tcHJlc3MoZGF0YSwgdGhpcy5fZmluLCAoZXJyLCBidWYpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgICBpZiAoYnVmLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9tZXNzYWdlTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIDEwMDksXG4gICAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goYnVmKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYXRhTWVzc2FnZShjYik7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IEdFVF9JTkZPKSB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGFNZXNzYWdlKGNiKSB7XG4gICAgaWYgKCF0aGlzLl9maW4pIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZUxlbmd0aCA9IHRoaXMuX21lc3NhZ2VMZW5ndGg7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gdGhpcy5fZnJhZ21lbnRzO1xuXG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDIpIHtcbiAgICAgIGxldCBkYXRhO1xuXG4gICAgICBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ25vZGVidWZmZXInKSB7XG4gICAgICAgIGRhdGEgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICBkYXRhID0gdG9BcnJheUJ1ZmZlcihjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdibG9iJykge1xuICAgICAgICBkYXRhID0gbmV3IEJsb2IoZnJhZ21lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBmcmFnbWVudHM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEsIHRydWUpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuXG4gICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgRXJyb3IsXG4gICAgICAgICAgJ2ludmFsaWQgVVRGLTggc2VxdWVuY2UnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwNyxcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfVVRGOCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBJTkZMQVRJTkcgfHwgdGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cykge1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gREVGRVJfRVZFTlQ7XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmLCBmYWxzZSk7XG4gICAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgY29udHJvbCBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGhhbmRsZVxuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb250cm9sTWVzc2FnZShkYXRhLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDgpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCAxMDA1LCBFTVBUWV9CVUZGRVIpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGRhdGEucmVhZFVJbnQxNkJFKDApO1xuXG4gICAgICAgIGlmICghaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICAgYGludmFsaWQgc3RhdHVzIGNvZGUgJHtjb2RlfWAsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwMixcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9DTE9TRV9DT0RFJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmID0gbmV3IEZhc3RCdWZmZXIoXG4gICAgICAgICAgZGF0YS5idWZmZXIsXG4gICAgICAgICAgZGF0YS5ieXRlT2Zmc2V0ICsgMixcbiAgICAgICAgICBkYXRhLmxlbmd0aCAtIDJcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICAgIEVycm9yLFxuICAgICAgICAgICAgJ2ludmFsaWQgVVRGLTggc2VxdWVuY2UnLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIDEwMDcsXG4gICAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfVVRGOCdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIGNvZGUsIGJ1Zik7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcbiAgICAgIHRoaXMuZW1pdCh0aGlzLl9vcGNvZGUgPT09IDB4MDkgPyAncGluZycgOiAncG9uZycsIGRhdGEpO1xuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLl9vcGNvZGUgPT09IDB4MDkgPyAncGluZycgOiAncG9uZycsIGRhdGEpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGFuIGVycm9yIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihuZXc6RXJyb3J8UmFuZ2VFcnJvcil9IEVycm9yQ3RvciBUaGUgZXJyb3IgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBwcmVmaXggU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGFkZCBhIGRlZmF1bHQgcHJlZml4IHRvXG4gICAqICAgICBgbWVzc2FnZWBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c0NvZGUgVGhlIHN0YXR1cyBjb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlcnJvckNvZGUgVGhlIGV4cG9zZWQgZXJyb3IgY29kZVxuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcil9IFRoZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlRXJyb3IoRXJyb3JDdG9yLCBtZXNzYWdlLCBwcmVmaXgsIHN0YXR1c0NvZGUsIGVycm9yQ29kZSkge1xuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICB0aGlzLl9lcnJvcmVkID0gdHJ1ZTtcblxuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvckN0b3IoXG4gICAgICBwcmVmaXggPyBgSW52YWxpZCBXZWJTb2NrZXQgZnJhbWU6ICR7bWVzc2FnZX1gIDogbWVzc2FnZVxuICAgICk7XG5cbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIHRoaXMuY3JlYXRlRXJyb3IpO1xuICAgIGVyci5jb2RlID0gZXJyb3JDb2RlO1xuICAgIGVycltrU3RhdHVzQ29kZV0gPSBzdGF0dXNDb2RlO1xuICAgIHJldHVybiBlcnI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWNlaXZlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ably/node_modules/ws/lib/sender.js":
/*!*********************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/sender.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */ \nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/constants.js\");\nconst { isBlob, isValidStatusCode } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/buffer-util.js\");\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n/**\n * HyBi Sender implementation.\n */ class Sender {\n    /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */ constructor(socket, extensions, generateMask){\n        this._extensions = extensions || {};\n        if (generateMask) {\n            this._generateMask = generateMask;\n            this._maskBuffer = Buffer.alloc(4);\n        }\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._queue = [];\n        this._state = DEFAULT;\n        this.onerror = NOOP;\n        this[kWebSocket] = undefined;\n    }\n    /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */ static frame(data, options) {\n        let mask;\n        let merge = false;\n        let offset = 2;\n        let skipMasking = false;\n        if (options.mask) {\n            mask = options.maskBuffer || maskBuffer;\n            if (options.generateMask) {\n                options.generateMask(mask);\n            } else {\n                if (randomPoolPointer === RANDOM_POOL_SIZE) {\n                    /* istanbul ignore else  */ if (randomPool === undefined) {\n                        //\n                        // This is lazily initialized because server-sent frames must not\n                        // be masked so it may never be used.\n                        //\n                        randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n                    }\n                    randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n                    randomPoolPointer = 0;\n                }\n                mask[0] = randomPool[randomPoolPointer++];\n                mask[1] = randomPool[randomPoolPointer++];\n                mask[2] = randomPool[randomPoolPointer++];\n                mask[3] = randomPool[randomPoolPointer++];\n            }\n            skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n            offset = 6;\n        }\n        let dataLength;\n        if (typeof data === 'string') {\n            if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n                dataLength = options[kByteLength];\n            } else {\n                data = Buffer.from(data);\n                dataLength = data.length;\n            }\n        } else {\n            dataLength = data.length;\n            merge = options.mask && options.readOnly && !skipMasking;\n        }\n        let payloadLength = dataLength;\n        if (dataLength >= 65536) {\n            offset += 8;\n            payloadLength = 127;\n        } else if (dataLength > 125) {\n            offset += 2;\n            payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n        if (options.rsv1) target[0] |= 0x40;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n            target.writeUInt16BE(dataLength, 2);\n        } else if (payloadLength === 127) {\n            target[2] = target[3] = 0;\n            target.writeUIntBE(dataLength, 4, 6);\n        }\n        if (!options.mask) return [\n            target,\n            data\n        ];\n        target[1] |= 0x80;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (skipMasking) return [\n            target,\n            data\n        ];\n        if (merge) {\n            applyMask(data, mask, target, offset, dataLength);\n            return [\n                target\n            ];\n        }\n        applyMask(data, mask, data, 0, dataLength);\n        return [\n            target,\n            data\n        ];\n    }\n    /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */ close(code, data, mask, cb) {\n        let buf;\n        if (code === undefined) {\n            buf = EMPTY_BUFFER;\n        } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n            throw new TypeError('First argument must be a valid error code number');\n        } else if (data === undefined || !data.length) {\n            buf = Buffer.allocUnsafe(2);\n            buf.writeUInt16BE(code, 0);\n        } else {\n            const length = Buffer.byteLength(data);\n            if (length > 123) {\n                throw new RangeError('The message must not be greater than 123 bytes');\n            }\n            buf = Buffer.allocUnsafe(2 + length);\n            buf.writeUInt16BE(code, 0);\n            if (typeof data === 'string') {\n                buf.write(data, 2);\n            } else {\n                buf.set(data, 2);\n            }\n        }\n        const options = {\n            [kByteLength]: buf.length,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x08,\n            readOnly: false,\n            rsv1: false\n        };\n        if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                buf,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(buf, options), cb);\n        }\n    }\n    /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ ping(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError('The data size must not be greater than 125 bytes');\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x09,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ pong(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError('The data size must not be greater than 125 bytes');\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x0a,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ send(data, options, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (this._firstFragment) {\n            this._firstFragment = false;\n            if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {\n                rsv1 = byteLength >= perMessageDeflate._threshold;\n            }\n            this._compress = rsv1;\n        } else {\n            rsv1 = false;\n            opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        const opts = {\n            [kByteLength]: byteLength,\n            fin: options.fin,\n            generateMask: this._generateMask,\n            mask: options.mask,\n            maskBuffer: this._maskBuffer,\n            opcode,\n            readOnly,\n            rsv1\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, this._compress, opts, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                this._compress,\n                opts,\n                cb\n            ]);\n        } else {\n            this.dispatch(data, this._compress, opts, cb);\n        }\n    }\n    /**\n   * Gets the contents of a blob as binary data.\n   *\n   * @param {Blob} blob The blob\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     the data\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ getBlobData(blob, compress, options, cb) {\n        this._bufferedBytes += options[kByteLength];\n        this._state = GET_BLOB_DATA;\n        blob.arrayBuffer().then((arrayBuffer)=>{\n            if (this._socket.destroyed) {\n                const err = new Error('The socket was closed while the blob was being read');\n                //\n                // `callCallbacks` is called in the next tick to ensure that errors\n                // that might be thrown in the callbacks behave like errors thrown\n                // outside the promise chain.\n                //\n                process.nextTick(callCallbacks, this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            const data = toBuffer(arrayBuffer);\n            if (!compress) {\n                this._state = DEFAULT;\n                this.sendFrame(Sender.frame(data, options), cb);\n                this.dequeue();\n            } else {\n                this.dispatch(data, compress, options, cb);\n            }\n        }).catch((err)=>{\n            //\n            // `onError` is called in the next tick for the same reason that\n            // `callCallbacks` above is.\n            //\n            process.nextTick(onError, this, err, cb);\n        });\n    }\n    /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ dispatch(data, compress, options, cb) {\n        if (!compress) {\n            this.sendFrame(Sender.frame(data, options), cb);\n            return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += options[kByteLength];\n        this._state = DEFLATING;\n        perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n            if (this._socket.destroyed) {\n                const err = new Error('The socket was closed while data was being compressed');\n                callCallbacks(this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            this._state = DEFAULT;\n            options.readOnly = false;\n            this.sendFrame(Sender.frame(buf, options), cb);\n            this.dequeue();\n        });\n    }\n    /**\n   * Executes queued send operations.\n   *\n   * @private\n   */ dequeue() {\n        while(this._state === DEFAULT && this._queue.length){\n            const params = this._queue.shift();\n            this._bufferedBytes -= params[3][kByteLength];\n            Reflect.apply(params[0], this, params.slice(1));\n        }\n    }\n    /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */ enqueue(params) {\n        this._bufferedBytes += params[3][kByteLength];\n        this._queue.push(params);\n    }\n    /**\n   * Sends a frame.\n   *\n   * @param {(Buffer | String)[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */ sendFrame(list, cb) {\n        if (list.length === 2) {\n            this._socket.cork();\n            this._socket.write(list[0]);\n            this._socket.write(list[1], cb);\n            this._socket.uncork();\n        } else {\n            this._socket.write(list[0], cb);\n        }\n    }\n}\nmodule.exports = Sender;\n/**\n * Calls queued callbacks with an error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error to call the callbacks with\n * @param {Function} [cb] The first callback\n * @private\n */ function callCallbacks(sender, err, cb) {\n    if (typeof cb === 'function') cb(err);\n    for(let i = 0; i < sender._queue.length; i++){\n        const params = sender._queue[i];\n        const callback = params[params.length - 1];\n        if (typeof callback === 'function') callback(err);\n    }\n}\n/**\n * Handles a `Sender` error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error\n * @param {Function} [cb] The first pending callback\n * @private\n */ function onError(sender, err, cb) {\n    callCallbacks(sender, err, cb);\n    sender.onerror(err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3RUFBd0UsR0FFM0Q7QUFFYixNQUFNLEVBQUVBLE1BQU0sRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNuQyxNQUFNLEVBQUVDLGNBQWMsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQyxzQkFBUTtBQUUzQyxNQUFNRSxvQkFBb0JGLG1CQUFPQSxDQUFDLGlHQUFzQjtBQUN4RCxNQUFNLEVBQUVHLFlBQVksRUFBRUMsVUFBVSxFQUFFQyxJQUFJLEVBQUUsR0FBR0wsbUJBQU9BLENBQUMsK0VBQWE7QUFDaEUsTUFBTSxFQUFFTSxNQUFNLEVBQUVDLGlCQUFpQixFQUFFLEdBQUdQLG1CQUFPQSxDQUFDLGlGQUFjO0FBQzVELE1BQU0sRUFBRVEsTUFBTUMsU0FBUyxFQUFFQyxRQUFRLEVBQUUsR0FBR1YsbUJBQU9BLENBQUMsbUZBQWU7QUFFN0QsTUFBTVcsY0FBY0MsT0FBTztBQUMzQixNQUFNQyxhQUFhQyxPQUFPQyxLQUFLLENBQUM7QUFDaEMsTUFBTUMsbUJBQW1CLElBQUk7QUFDN0IsSUFBSUM7QUFDSixJQUFJQyxvQkFBb0JGO0FBRXhCLE1BQU1HLFVBQVU7QUFDaEIsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxnQkFBZ0I7QUFFdEI7O0NBRUMsR0FDRCxNQUFNQztJQUNKOzs7Ozs7O0dBT0MsR0FDREMsWUFBWUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLFlBQVksQ0FBRTtRQUM1QyxJQUFJLENBQUNDLFdBQVcsR0FBR0YsY0FBYyxDQUFDO1FBRWxDLElBQUlDLGNBQWM7WUFDaEIsSUFBSSxDQUFDRSxhQUFhLEdBQUdGO1lBQ3JCLElBQUksQ0FBQ0csV0FBVyxHQUFHZixPQUFPQyxLQUFLLENBQUM7UUFDbEM7UUFFQSxJQUFJLENBQUNlLE9BQU8sR0FBR047UUFFZixJQUFJLENBQUNPLGNBQWMsR0FBRztRQUN0QixJQUFJLENB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QUFDdUUsRUFBRTtRQUMvQixNQUFNQyxXQUFXN0IsTUFBTSxDQUFDQSxPQUFPL0IsTUFBTSxHQUFHLEVBQUU7UUFFMUMsSUFBSSxPQUFPNEQsYUFBYSxZQUFZQSxTQUFTckI7SUFDL0M7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTTyxRQUFRWSxNQUFNLEVBQUVuQixHQUFHLEVBQUUzQixFQUFFO0lBQzlCK0IsY0FBY2UsUUFBUW5CLEtBQUszQjtJQUMzQjhDLE9BQU9wRSxPQUFPLENBQUNpRDtBQUNqQiIsInNvdXJjZXMiOlsiQzpcXEhhY2thdGhvblxcSGFja3NwaXJlXFxub2RlX21vZHVsZXNcXGFibHlcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcc2VuZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyByYW5kb21GaWxsU3luYyB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHsgRU1QVFlfQlVGRkVSLCBrV2ViU29ja2V0LCBOT09QIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBpc0Jsb2IsIGlzVmFsaWRTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcbmNvbnN0IHsgbWFzazogYXBwbHlNYXNrLCB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBrQnl0ZUxlbmd0aCA9IFN5bWJvbCgna0J5dGVMZW5ndGgnKTtcbmNvbnN0IG1hc2tCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG5jb25zdCBSQU5ET01fUE9PTF9TSVpFID0gOCAqIDEwMjQ7XG5sZXQgcmFuZG9tUG9vbDtcbmxldCByYW5kb21Qb29sUG9pbnRlciA9IFJBTkRPTV9QT09MX1NJWkU7XG5cbmNvbnN0IERFRkFVTFQgPSAwO1xuY29uc3QgREVGTEFUSU5HID0gMTtcbmNvbnN0IEdFVF9CTE9CX0RBVEEgPSAyO1xuXG4vKipcbiAqIEh5QmkgU2VuZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBTZW5kZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFNlbmRlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgY29ubmVjdGlvbiBzb2NrZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtnZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvY2tldCwgZXh0ZW5zaW9ucywgZ2VuZXJhdGVNYXNrKSB7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG5cbiAgICBpZiAoZ2VuZXJhdGVNYXNrKSB7XG4gICAgICB0aGlzLl9nZW5lcmF0ZU1hc2sgPSBnZW5lcmF0ZU1hc2s7XG4gICAgICB0aGlzLl9tYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIH1cblxuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbXByZXNzID0gZmFsc2U7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcbiAgICB0aGlzLm9uZXJyb3IgPSBOT09QO1xuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGEgcGllY2Ugb2YgZGF0YSBhY2NvcmRpbmcgdG8gdGhlIEh5QmkgV2ViU29ja2V0IHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgZGF0YSB0byBmcmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHJldHVybiB7KEJ1ZmZlcnxTdHJpbmcpW119IFRoZSBmcmFtZWQgZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZnJhbWUoZGF0YSwgb3B0aW9ucykge1xuICAgIGxldCBtYXNrO1xuICAgIGxldCBtZXJnZSA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSAyO1xuICAgIGxldCBza2lwTWFza2luZyA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMubWFzaykge1xuICAgICAgbWFzayA9IG9wdGlvbnMubWFza0J1ZmZlciB8fCBtYXNrQnVmZmVyO1xuXG4gICAgICBpZiAob3B0aW9ucy5nZW5lcmF0ZU1hc2spIHtcbiAgICAgICAgb3B0aW9ucy5nZW5lcmF0ZU1hc2sobWFzayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmFuZG9tUG9vbFBvaW50ZXIgPT09IFJBTkRPTV9QT09MX1NJWkUpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbiAgICAgICAgICBpZiAocmFuZG9tUG9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBsYXppbHkgaW5pdGlhbGl6ZWQgYmVjYXVzZSBzZXJ2ZXItc2VudCBmcmFtZXMgbXVzdCBub3RcbiAgICAgICAgICAgIC8vIGJlIG1hc2tlZCBzbyBpdCBtYXkgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByYW5kb21Qb29sID0gQnVmZmVyLmFsbG9jKFJBTkRPTV9QT09MX1NJWkUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJhbmRvbUZpbGxTeW5jKHJhbmRvbVBvb2wsIDAsIFJBTkRPTV9QT09MX1NJWkUpO1xuICAgICAgICAgIHJhbmRvbVBvb2xQb2ludGVyID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hc2tbMF0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgICBtYXNrWzFdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgICAgbWFza1syXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICAgIG1hc2tbM10gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgfVxuXG4gICAgICBza2lwTWFza2luZyA9IChtYXNrWzBdIHwgbWFza1sxXSB8IG1hc2tbMl0gfCBtYXNrWzNdKSA9PT0gMDtcbiAgICAgIG9mZnNldCA9IDY7XG4gICAgfVxuXG4gICAgbGV0IGRhdGFMZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoXG4gICAgICAgICghb3B0aW9ucy5tYXNrIHx8IHNraXBNYXNraW5nKSAmJlxuICAgICAgICBvcHRpb25zW2tCeXRlTGVuZ3RoXSAhPT0gdW5kZWZpbmVkXG4gICAgICApIHtcbiAgICAgICAgZGF0YUxlbmd0aCA9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIG1lcmdlID0gb3B0aW9ucy5tYXNrICYmIG9wdGlvbnMucmVhZE9ubHkgJiYgIXNraXBNYXNraW5nO1xuICAgIH1cblxuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gZGF0YUxlbmd0aDtcblxuICAgIGlmIChkYXRhTGVuZ3RoID49IDY1NTM2KSB7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjc7XG4gICAgfSBlbHNlIGlmIChkYXRhTGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lcmdlID8gZGF0YUxlbmd0aCArIG9mZnNldCA6IG9mZnNldCk7XG5cbiAgICB0YXJnZXRbMF0gPSBvcHRpb25zLmZpbiA/IG9wdGlvbnMub3Bjb2RlIHwgMHg4MCA6IG9wdGlvbnMub3Bjb2RlO1xuICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xuXG4gICAgdGFyZ2V0WzFdID0gcGF5bG9hZExlbmd0aDtcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQxNkJFKGRhdGFMZW5ndGgsIDIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICB0YXJnZXRbMl0gPSB0YXJnZXRbM10gPSAwO1xuICAgICAgdGFyZ2V0LndyaXRlVUludEJFKGRhdGFMZW5ndGgsIDQsIDYpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tYXNrKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICB0YXJnZXRbMV0gfD0gMHg4MDtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gNF0gPSBtYXNrWzBdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAzXSA9IG1hc2tbMV07XG4gICAgdGFyZ2V0W29mZnNldCAtIDJdID0gbWFza1syXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMV0gPSBtYXNrWzNdO1xuXG4gICAgaWYgKHNraXBNYXNraW5nKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICBpZiAobWVyZ2UpIHtcbiAgICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCB0YXJnZXQsIG9mZnNldCwgZGF0YUxlbmd0aCk7XG4gICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgfVxuXG4gICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIGRhdGEsIDAsIGRhdGFMZW5ndGgpO1xuICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gVGhlIHN0YXR1cyBjb2RlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSBtZXNzYWdlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ1ZjtcblxuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZiA9IEVNUFRZX0JVRkZFUjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJyB8fCAhaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSB2YWxpZCBlcnJvciBjb2RlIG51bWJlcicpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuXG4gICAgICBpZiAobGVuZ3RoID4gMTIzKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgbWVzc2FnZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTIzIGJ5dGVzJyk7XG4gICAgICB9XG5cbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgbGVuZ3RoKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi5zZXQoZGF0YSwgMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ1Zi5sZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDA4LFxuICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGJ1ZiwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcGluZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MDksXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZ2V0QmxvYkRhdGEsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBvbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDBhLFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0QmxvYkRhdGEoZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBkYXRhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5XG4gICAqICAgICBvciB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuICAgIGxldCBvcGNvZGUgPSBvcHRpb25zLmJpbmFyeSA/IDIgOiAxO1xuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcblxuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9maXJzdEZyYWdtZW50KSB7XG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gZmFsc2U7XG4gICAgICBpZiAoXG4gICAgICAgIHJzdjEgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUucGFyYW1zW1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLl9pc1NlcnZlclxuICAgICAgICAgICAgPyAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICAgICA6ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgXVxuICAgICAgKSB7XG4gICAgICAgIHJzdjEgPSBieXRlTGVuZ3RoID49IHBlck1lc3NhZ2VEZWZsYXRlLl90aHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb21wcmVzcyA9IHJzdjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzdjEgPSBmYWxzZTtcbiAgICAgIG9wY29kZSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZmluKSB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcnN2MVxuICAgIH07XG5cbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0QmxvYkRhdGEoZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbnRlbnRzIG9mIGEgYmxvYiBhcyBiaW5hcnkgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCbG9ifSBibG9iIFRoZSBibG9iXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIHRoZSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRCbG9iRGF0YShibG9iLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0JMT0JfREFUQTtcblxuICAgIGJsb2JcbiAgICAgIC5hcnJheUJ1ZmZlcigpXG4gICAgICAudGhlbigoYXJyYXlCdWZmZXIpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIHRoZSBibG9iIHdhcyBiZWluZyByZWFkJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIGBjYWxsQ2FsbGJhY2tzYCBpcyBjYWxsZWQgaW4gdGhlIG5leHQgdGljayB0byBlbnN1cmUgdGhhdCBlcnJvcnNcbiAgICAgICAgICAvLyB0aGF0IG1pZ2h0IGJlIHRocm93biBpbiB0aGUgY2FsbGJhY2tzIGJlaGF2ZSBsaWtlIGVycm9ycyB0aHJvd25cbiAgICAgICAgICAvLyBvdXRzaWRlIHRoZSBwcm9taXNlIGNoYWluLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsQ2FsbGJhY2tzLCB0aGlzLCBlcnIsIGNiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgICBjb25zdCBkYXRhID0gdG9CdWZmZXIoYXJyYXlCdWZmZXIpO1xuXG4gICAgICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkFVTFQ7XG4gICAgICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gYG9uRXJyb3JgIGlzIGNhbGxlZCBpbiB0aGUgbmV4dCB0aWNrIGZvciB0aGUgc2FtZSByZWFzb24gdGhhdFxuICAgICAgICAvLyBgY2FsbENhbGxiYWNrc2AgYWJvdmUgaXMuXG4gICAgICAgIC8vXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sob25FcnJvciwgdGhpcywgZXJyLCBjYik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fc3RhdGUgPSBERUZMQVRJTkc7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUuY29tcHJlc3MoZGF0YSwgb3B0aW9ucy5maW4sIChfLCBidWYpID0+IHtcbiAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIGNvbXByZXNzZWQnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2FsbENhbGxiYWNrcyh0aGlzLCBlcnIsIGNiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHF1ZXVlZCBzZW5kIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIHdoaWxlICh0aGlzLl9zdGF0ZSA9PT0gREVGQVVMVCAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcbiAgICAgIFJlZmxlY3QuYXBwbHkocGFyYW1zWzBdLCB0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHNlbmQgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgU2VuZCBvcGVyYXRpb24gcGFyYW1ldGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVucXVldWUocGFyYW1zKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXIgfCBTdHJpbmcpW119IGxpc3QgVGhlIGZyYW1lIHRvIHNlbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VuZEZyYW1lKGxpc3QsIGNiKSB7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aGlzLl9zb2NrZXQuY29yaygpO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0pO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMV0sIGNiKTtcbiAgICAgIHRoaXMuX3NvY2tldC51bmNvcmsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0sIGNiKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXI7XG5cbi8qKlxuICogQ2FsbHMgcXVldWVkIGNhbGxiYWNrcyB3aXRoIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U2VuZGVyfSBzZW5kZXIgVGhlIGBTZW5kZXJgIGluc3RhbmNlXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yIHRvIGNhbGwgdGhlIGNhbGxiYWNrcyB3aXRoXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIFRoZSBmaXJzdCBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsbENhbGxiYWNrcyhzZW5kZXIsIGVyciwgY2IpIHtcbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgY2IoZXJyKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbmRlci5fcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuX3F1ZXVlW2ldO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVzIGEgYFNlbmRlcmAgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTZW5kZXJ9IHNlbmRlciBUaGUgYFNlbmRlcmAgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gVGhlIGZpcnN0IHBlbmRpbmcgY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG9uRXJyb3Ioc2VuZGVyLCBlcnIsIGNiKSB7XG4gIGNhbGxDYWxsYmFja3Moc2VuZGVyLCBlcnIsIGNiKTtcbiAgc2VuZGVyLm9uZXJyb3IoZXJyKTtcbn1cbiJdLCJuYW1lcyI6WyJEdXBsZXgiLCJyZXF1aXJlIiwicmFuZG9tRmlsbFN5bmMiLCJQZXJNZXNzYWdlRGVmbGF0ZSIsIkVNUFRZX0JVRkZFUiIsImtXZWJTb2NrZXQiLCJOT09QIiwiaXNCbG9iIiwiaXNWYWxpZFN0YXR1c0NvZGUiLCJtYXNrIiwiYXBwbHlNYXNrIiwidG9CdWZmZXIiLCJrQnl0ZUxlbmd0aCIsIlN5bWJvbCIsIm1hc2tCdWZmZXIiLCJCdWZmZXIiLCJhbGxvYyIsIlJBTkRPTV9QT09MX1NJWkUiLCJyYW5kb21Qb29sIiwicmFuZG9tUG9vbFBvaW50ZXIiLCJERUZBVUxUIiwiREVGTEFUSU5HIiwiR0VUX0JMT0JfREFUQSIsIlNlbmRlciIsImNvbnN0cnVjdG9yIiwic29ja2V0IiwiZXh0ZW5zaW9ucyIsImdlbmVyYXRlTWFzayIsIl9leHRlbnNpb25zIiwiX2dlbmVyYXRlTWFzayIsIl9tYXNrQnVmZmVyIiwiX3NvY2tldCIsIl9maXJzdEZyYWdtZW50IiwiX2NvbXByZXNzIiwiX2J1ZmZlcmVkQnl0ZXMiLCJfcXVldWUiLCJfc3RhdGUiLCJvbmVycm9yIiwidW5kZWZpbmVkIiwiZnJhbWUiLCJkYXRhIiwib3B0aW9ucyIsIm1lcmdlIiwib2Zmc2V0Iiwic2tpcE1hc2tpbmciLCJkYXRhTGVuZ3RoIiwiZnJvbSIsImxlbmd0aCIsInJlYWRPbmx5IiwicGF5bG9hZExlbmd0aCIsInRhcmdldCIsImFsbG9jVW5zYWZlIiwiZmluIiwib3Bjb2RlIiwicnN2MSIsIndyaXRlVUludDE2QkUiLCJ3cml0ZVVJbnRCRSIsImNsb3NlIiwiY29kZSIsImNiIiwiYnVmIiwiVHlwZUVycm9yIiwiYnl0ZUxlbmd0aCIsIlJhbmdlRXJyb3IiLCJ3cml0ZSIsInNldCIsImVucXVldWUiLCJkaXNwYXRjaCIsInNlbmRGcmFtZSIsInBpbmciLCJzaXplIiwiZ2V0QmxvYkRhdGEiLCJwb25nIiwic2VuZCIsInBlck1lc3NhZ2VEZWZsYXRlIiwiZXh0ZW5zaW9uTmFtZSIsImJpbmFyeSIsImNvbXByZXNzIiwicGFyYW1zIiwiX2lzU2VydmVyIiwiX3RocmVzaG9sZCIsIm9wdHMiLCJibG9iIiwiYXJyYXlCdWZmZXIiLCJ0aGVuIiwiZGVzdHJveWVkIiwiZXJyIiwiRXJyb3IiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjYWxsQ2FsbGJhY2tzIiwiZGVxdWV1ZSIsImNhdGNoIiwib25FcnJvciIsIl8iLCJzaGlmdCIsIlJlZmxlY3QiLCJhcHBseSIsInNsaWNlIiwicHVzaCIsImxpc3QiLCJjb3JrIiwidW5jb3JrIiwibW9kdWxlIiwiZXhwb3J0cyIsInNlbmRlciIsImkiLCJjYWxsYmFjayJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ably/node_modules/ws/lib/stream.js":
/*!*********************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/stream.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^WebSocket$\" }] */\n\n\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/websocket.js\");\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) ws.pause();\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0Msb0NBQW9DO0FBQzdEOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFhO0FBQ3ZDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcSGFja2F0aG9uXFxIYWNrc3BpcmVcXG5vZGVfbW9kdWxlc1xcYWJseVxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFxzdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeV2ViU29ja2V0JFwiIH1dICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qKlxuICogRW1pdHMgdGhlIGAnY2xvc2UnYCBldmVudCBvbiBhIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc3RyZWFtIFRoZSBzdHJlYW0uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVuZCgpIHtcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVycm9yKGVycikge1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnZXJyb3InKSA9PT0gMCkge1xuICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IuXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwcyBhIGBXZWJTb2NrZXRgIGluIGEgZHVwbGV4IHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd3MgVGhlIGBXZWJTb2NrZXRgIHRvIHdyYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoZSBgRHVwbGV4YCBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7RHVwbGV4fSBUaGUgZHVwbGV4IHN0cmVhbVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXRTdHJlYW0od3MsIG9wdGlvbnMpIHtcbiAgbGV0IHRlcm1pbmF0ZU9uRGVzdHJveSA9IHRydWU7XG5cbiAgY29uc3QgZHVwbGV4ID0gbmV3IER1cGxleCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBhdXRvRGVzdHJveTogZmFsc2UsXG4gICAgZW1pdENsb3NlOiBmYWxzZSxcbiAgICBvYmplY3RNb2RlOiBmYWxzZSxcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6IGZhbHNlXG4gIH0pO1xuXG4gIHdzLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gbWVzc2FnZShtc2csIGlzQmluYXJ5KSB7XG4gICAgY29uc3QgZGF0YSA9XG4gICAgICAhaXNCaW5hcnkgJiYgZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgPyBtc2cudG9TdHJpbmcoKSA6IG1zZztcblxuICAgIGlmICghZHVwbGV4LnB1c2goZGF0YSkpIHdzLnBhdXNlKCk7XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIC8vIFByZXZlbnQgYHdzLnRlcm1pbmF0ZSgpYCBmcm9tIGJlaW5nIGNhbGxlZCBieSBgZHVwbGV4Ll9kZXN0cm95KClgLlxuICAgIC8vXG4gICAgLy8gLSBJZiB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlIHRoZSBgJ29wZW4nYCBldmVudCwgdGhlblxuICAgIC8vICAgYHdzLnRlcm1pbmF0ZSgpYCBpcyBhIG5vb3AgYXMgbm8gc29ja2V0IGlzIGFzc2lnbmVkLlxuICAgIC8vIC0gT3RoZXJ3aXNlLCB0aGUgZXJyb3IgaXMgcmUtZW1pdHRlZCBieSB0aGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYFxuICAgIC8vICAgZXZlbnQgb2YgdGhlIGBSZWNlaXZlcmAgb2JqZWN0LiBUaGUgbGlzdGVuZXIgYWxyZWFkeSBjbG9zZXMgdGhlXG4gICAgLy8gICBjb25uZWN0aW9uIGJ5IGNhbGxpbmcgYHdzLmNsb3NlKClgLiBUaGlzIGFsbG93cyBhIGNsb3NlIGZyYW1lIHRvIGJlXG4gICAgLy8gICBzZW50IHRvIHRoZSBvdGhlciBwZWVyLiBJZiBgd3MudGVybWluYXRlKClgIGlzIGNhbGxlZCByaWdodCBhZnRlciB0aGlzLFxuICAgIC8vICAgdGhlbiB0aGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGJlIHNlbnQuXG4gICAgdGVybWluYXRlT25EZXN0cm95ID0gZmFsc2U7XG4gICAgZHVwbGV4LmRlc3Ryb3koZXJyKTtcbiAgfSk7XG5cbiAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgZHVwbGV4LnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIGR1cGxleC5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NFRCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICAgIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcblxuICAgIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoIWNhbGxlZCkgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRlcm1pbmF0ZU9uRGVzdHJveSkgd3MudGVybWluYXRlKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIGBfc29ja2V0YCBwcm9wZXJ0eSBpcyBgbnVsbGAgaXQgbWVhbnMgdGhhdCBgd3NgIGlzIGFcbiAgICAvLyBjbGllbnQgd2Vic29ja2V0IGFuZCB0aGUgaGFuZHNoYWtlIGZhaWxlZC4gSW4gZmFjdCwgd2hlbiB0aGlzIGhhcHBlbnMsIGFcbiAgICAvLyBzb2NrZXQgaXMgbmV2ZXIgYXNzaWduZWQgdG8gdGhlIHdlYnNvY2tldC4gV2FpdCBmb3IgdGhlIGAnZXJyb3InYCBldmVudFxuICAgIC8vIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSB3ZWJzb2NrZXQuXG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpIHJldHVybjtcblxuICAgIGlmICh3cy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgaWYgKGR1cGxleC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSBkdXBsZXguZGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cy5fc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgLy8gYGR1cGxleGAgaXMgbm90IGRlc3Ryb3llZCBoZXJlIGJlY2F1c2UgdGhlIGAnZW5kJ2AgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBlbWl0dGVkIG9uIGBkdXBsZXhgIGFmdGVyIHRoaXMgYCdmaW5pc2gnYCBldmVudC4gVGhlIEVPRiBzaWduYWxpbmdcbiAgICAgICAgLy8gYG51bGxgIGNodW5rIGlzLCBpbiBmYWN0LCBwdXNoZWQgd2hlbiB0aGUgd2Vic29ja2V0IGVtaXRzIGAnY2xvc2UnYC5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgd3MuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh3cy5pc1BhdXNlZCkgd3MucmVzdW1lKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3Muc2VuZChjaHVuaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIGR1cGxleC5vbignZW5kJywgZHVwbGV4T25FbmQpO1xuICBkdXBsZXgub24oJ2Vycm9yJywgZHVwbGV4T25FcnJvcik7XG4gIHJldHVybiBkdXBsZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlV2ViU29ja2V0U3RyZWFtO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ably/node_modules/ws/lib/subprotocol.js":
/*!**************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/subprotocol.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/validation.js\");\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (\n      i !== 0 &&\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n    ) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n\n      if (end === -1) end = i;\n\n      const protocol = header.slice(start, end);\n\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  const protocol = header.slice(start, i);\n\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n\n  protocols.add(protocol);\n  return protocols;\n}\n\nmodule.exports = { parse };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsaUZBQWM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxtQkFBbUI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLCtEQUErRCxFQUFFO0FBQ2pFOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTiw2REFBNkQsRUFBRTtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIkM6XFxIYWNrYXRob25cXEhhY2tzcGlyZVxcbm9kZV9tb2R1bGVzXFxhYmx5XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHN1YnByb3RvY29sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyB0b2tlbkNoYXJzIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGBTZWMtV2ViU29ja2V0LVByb3RvY29sYCBoZWFkZXIgaW50byBhIHNldCBvZiBzdWJwcm90b2NvbCBuYW1lcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyIFRoZSBmaWVsZCB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gKiBAcmV0dXJuIHtTZXR9IFRoZSBzdWJwcm90b2NvbCBuYW1lc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3QgcHJvdG9jb2xzID0gbmV3IFNldCgpO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yIChpOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBpICE9PSAwICYmXG4gICAgICAoY29kZSA9PT0gMHgyMCAvKiAnICcgKi8gfHwgY29kZSA9PT0gMHgwOSkgLyogJ1xcdCcgKi9cbiAgICApIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MmMgLyogJywnICovKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcblxuICAgICAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICAgIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBcIiR7cHJvdG9jb2x9XCIgc3VicHJvdG9jb2wgaXMgZHVwbGljYXRlZGApO1xuICAgICAgfVxuXG4gICAgICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kICE9PSAtMSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnKTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvY29sID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBpKTtcblxuICBpZiAocHJvdG9jb2xzLmhhcyhwcm90b2NvbCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBcIiR7cHJvdG9jb2x9XCIgc3VicHJvdG9jb2wgaXMgZHVwbGljYXRlZGApO1xuICB9XG5cbiAgcHJvdG9jb2xzLmFkZChwcm90b2NvbCk7XG4gIHJldHVybiBwcm90b2NvbHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBwYXJzZSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/node_modules/ws/lib/subprotocol.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ably/node_modules/ws/lib/validation.js":
/*!*************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/validation.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { isUtf8 } = __webpack_require__(/*! buffer */ \"buffer\");\n\nconst { hasBlob } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/constants.js\");\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\n        buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Determines whether a value is a `Blob`.\n *\n * @param {*} value The value to be tested\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\n * @private\n */\nfunction isBlob(value) {\n  return (\n    hasBlob &&\n    typeof value === 'object' &&\n    typeof value.arrayBuffer === 'function' &&\n    typeof value.type === 'string' &&\n    typeof value.stream === 'function' &&\n    (value[Symbol.toStringTag] === 'Blob' ||\n      value[Symbol.toStringTag] === 'File')\n  );\n}\n\nmodule.exports = {\n  isBlob,\n  isValidStatusCode,\n  isValidUTF8: _isValidUTF8,\n  tokenChars\n};\n\nif (isUtf8) {\n  module.exports.isValidUTF8 = function (buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"?8d22\");\n\n    module.exports.isValidUTF8 = function (buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFbkMsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQywrRUFBYTs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSwwQkFBMEI7QUFDNUI7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDZCQUFnQjs7QUFFaEQsSUFBSSwwQkFBMEI7QUFDOUI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYWNrYXRob25cXEhhY2tzcGlyZVxcbm9kZV9tb2R1bGVzXFxhYmx5XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHZhbGlkYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGlzVXRmOCB9ID0gcmVxdWlyZSgnYnVmZmVyJyk7XG5cbmNvbnN0IHsgaGFzQmxvYiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuLy9cbi8vIEFsbG93ZWQgdG9rZW4gY2hhcmFjdGVyczpcbi8vXG4vLyAnIScsICcjJywgJyQnLCAnJScsICcmJywgJycnLCAnKicsICcrJywgJy0nLFxuLy8gJy4nLCAwLTksIEEtWiwgJ14nLCAnXycsICdgJywgYS16LCAnfCcsICd+J1xuLy9cbi8vIHRva2VuQ2hhcnNbMzJdID09PSAwIC8vICcgJ1xuLy8gdG9rZW5DaGFyc1szM10gPT09IDEgLy8gJyEnXG4vLyB0b2tlbkNoYXJzWzM0XSA9PT0gMCAvLyAnXCInXG4vLyAuLi5cbi8vXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHRva2VuQ2hhcnMgPSBbXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDAgLSAxNVxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNiAtIDMxXG4gIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIDEsIDAsIC8vIDMyIC0gNDdcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gNDggLSA2M1xuICAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA2NCAtIDc5XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDEsIC8vIDgwIC0gOTVcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gOTYgLSAxMTFcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCAvLyAxMTIgLSAxMjdcbl07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhdHVzIGNvZGUgaXMgYWxsb3dlZCBpbiBhIGNsb3NlIGZyYW1lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBzdGF0dXMgY29kZSBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICAoY29kZSA+PSAxMDAwICYmXG4gICAgICBjb2RlIDw9IDEwMTQgJiZcbiAgICAgIGNvZGUgIT09IDEwMDQgJiZcbiAgICAgIGNvZGUgIT09IDEwMDUgJiZcbiAgICAgIGNvZGUgIT09IDEwMDYpIHx8XG4gICAgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpXG4gICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYnVmZmVyIGNvbnRhaW5zIG9ubHkgY29ycmVjdCBVVEYtOC5cbiAqIFBvcnRlZCBmcm9tIGh0dHBzOi8vd3d3LmNsLmNhbS5hYy51ay8lN0VtZ2syNS91Y3MvdXRmOF9jaGVjay5jIGJ5XG4gKiBNYXJrdXMgS3Vobi5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgYnVmYCBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTgsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfaXNWYWxpZFVURjgoYnVmKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gIGxldCBpID0gMDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmICgoYnVmW2ldICYgMHg4MCkgPT09IDApIHtcbiAgICAgIC8vIDB4eHh4eHh4XG4gICAgICBpKys7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgIC8vIDExMHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAxID09PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldICYgMHhmZSkgPT09IDB4YzAgLy8gT3ZlcmxvbmdcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMjtcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgLy8gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDIgPj0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldID09PSAweGUwICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXG4gICAgICAgIChidWZbaV0gPT09IDB4ZWQgJiYgKGJ1ZltpICsgMV0gJiAweGUwKSA9PT0gMHhhMCkgLy8gU3Vycm9nYXRlIChVK0Q4MDAgLSBVK0RGRkYpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDM7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgIC8vIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAzID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgM10gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldID09PSAweGYwICYmIChidWZbaSArIDFdICYgMHhmMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXG4gICAgICAgIChidWZbaV0gPT09IDB4ZjQgJiYgYnVmW2kgKyAxXSA+IDB4OGYpIHx8XG4gICAgICAgIGJ1ZltpXSA+IDB4ZjQgLy8gPiBVKzEwRkZGRlxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgdmFsdWUgaXMgYSBgQmxvYmAuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGBCbG9iYCwgZWxzZSBgZmFsc2VgXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBoYXNCbG9iICYmXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5zdHJlYW0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAodmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0Jsb2InIHx8XG4gICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnRmlsZScpXG4gICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0Jsb2IsXG4gIGlzVmFsaWRTdGF0dXNDb2RlLFxuICBpc1ZhbGlkVVRGODogX2lzVmFsaWRVVEY4LFxuICB0b2tlbkNoYXJzXG59O1xuXG5pZiAoaXNVdGY4KSB7XG4gIG1vZHVsZS5leHBvcnRzLmlzVmFsaWRVVEY4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHJldHVybiBidWYubGVuZ3RoIDwgMjQgPyBfaXNWYWxpZFVURjgoYnVmKSA6IGlzVXRmOChidWYpO1xuICB9O1xufSAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi8gZWxzZSBpZiAoIXByb2Nlc3MuZW52LldTX05PX1VURl84X1ZBTElEQVRFKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgaXNWYWxpZFVURjggPSByZXF1aXJlKCd1dGYtOC12YWxpZGF0ZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMuaXNWYWxpZFVURjggPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDMyID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1ZhbGlkVVRGOChidWYpO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBDb250aW51ZSByZWdhcmRsZXNzIG9mIHRoZSBlcnJvci5cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ably/node_modules/ws/lib/websocket-server.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/websocket-server.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst extension = __webpack_require__(/*! ./extension */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/websocket.js\");\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/constants.js\");\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n   *     automatically send a pong in response to a ping\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      allowSynchronousEvents: true,\n      autoPong: true,\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key = req.headers['sec-websocket-key'];\n    const upgrade = req.headers.upgrade;\n    const version = +req.headers['sec-websocket-version'];\n\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (key === undefined || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (version !== 8 && version !== 13) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message =\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null, undefined, this.options);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n\n  socket.once('finish', socket.destroy);\n\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      Object.keys(headers)\n        .map((h) => `${h}: ${headers[h]}`)\n        .join('\\r\\n') +\n      '\\r\\n\\r\\n' +\n      message\n  );\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDLHlEQUF5RDs7QUFFbEY7O0FBRWIscUJBQXFCLG1CQUFPLENBQUMsc0JBQVE7QUFDckMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDbkMsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFdkMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQWE7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsaUdBQXNCO0FBQ3hELG9CQUFvQixtQkFBTyxDQUFDLG1GQUFlO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFhO0FBQ3ZDLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQywrRUFBYTs7QUFFbEQsaUNBQWlDLEdBQUc7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSw0QkFBNEI7QUFDekM7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVywyQkFBMkI7QUFDdEMsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLE1BQU0sRUFBRSx3QkFBd0I7QUFDaEQ7QUFDQSx1QkFBdUIsRUFBRSxJQUFJLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYWNrYXRob25cXEhhY2tzcGlyZVxcbm9kZV9tb2R1bGVzXFxhYmx5XFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHdlYnNvY2tldC1zZXJ2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4JFwiLCBcImNhdWdodEVycm9yc1wiOiBcIm5vbmVcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IGV4dGVuc2lvbiA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBzdWJwcm90b2NvbCA9IHJlcXVpcmUoJy4vc3VicHJvdG9jb2wnKTtcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5jb25zdCB7IEdVSUQsIGtXZWJTb2NrZXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGtleVJlZ2V4ID0gL15bKy8wLTlBLVphLXpdezIyfT09JC87XG5cbmNvbnN0IFJVTk5JTkcgPSAwO1xuY29uc3QgQ0xPU0lORyA9IDE7XG5jb25zdCBDTE9TRUQgPSAyO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvUG9uZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIGF1dG9tYXRpY2FsbHkgc2VuZCBhIHBvbmcgaW4gcmVzcG9uc2UgdG8gYSBwaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iYWNrbG9nPTUxMV0gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBxdWV1ZSBvZlxuICAgKiAgICAgcGVuZGluZyBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudFRyYWNraW5nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgdHJhY2sgY2xpZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oYW5kbGVQcm90b2NvbHNdIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ob3N0XSBUaGUgaG9zdG5hbWUgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gICAqICAgICBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9TZXJ2ZXI9ZmFsc2VdIEVuYWJsZSBubyBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aF0gQWNjZXB0IG9ubHkgY29ubmVjdGlvbnMgbWF0Y2hpbmcgdGhpcyBwYXRoXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9ZmFsc2VdIEVuYWJsZS9kaXNhYmxlXG4gICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvcnRdIFRoZSBwb3J0IHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0geyhodHRwLlNlcnZlcnxodHRwcy5TZXJ2ZXIpfSBbb3B0aW9ucy5zZXJ2ZXJdIEEgcHJlLWNyZWF0ZWQgSFRUUC9TXG4gICAqICAgICBzZXJ2ZXIgdG8gdXNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmVyaWZ5Q2xpZW50XSBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLldlYlNvY2tldD1XZWJTb2NrZXRdIFNwZWNpZmllcyB0aGUgYFdlYlNvY2tldGBcbiAgICogICAgIGNsYXNzIHRvIHVzZS4gSXQgbXVzdCBiZSB0aGUgYFdlYlNvY2tldGAgY2xhc3Mgb3IgY2xhc3MgdGhhdCBleHRlbmRzIGl0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdHJ1ZSxcbiAgICAgIGF1dG9Qb25nOiB0cnVlLFxuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIFdlYlNvY2tldCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKFxuICAgICAgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikgfHxcbiAgICAgIChvcHRpb25zLnBvcnQgIT0gbnVsbCAmJiAob3B0aW9ucy5zZXJ2ZXIgfHwgb3B0aW9ucy5ub1NlcnZlcikpIHx8XG4gICAgICAob3B0aW9ucy5zZXJ2ZXIgJiYgb3B0aW9ucy5ub1NlcnZlcilcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdPbmUgYW5kIG9ubHkgb25lIG9mIHRoZSBcInBvcnRcIiwgXCJzZXJ2ZXJcIiwgb3IgXCJub1NlcnZlclwiIG9wdGlvbnMgJyArXG4gICAgICAgICAgJ211c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gaHR0cC5TVEFUVVNfQ09ERVNbNDI2XTtcblxuICAgICAgICByZXMud3JpdGVIZWFkKDQyNiwge1xuICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5lbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NlcnZlci5saXN0ZW4oXG4gICAgICAgIG9wdGlvbnMucG9ydCxcbiAgICAgICAgb3B0aW9ucy5ob3N0LFxuICAgICAgICBvcHRpb25zLmJhY2tsb2csXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIGNvbnN0IGVtaXRDb25uZWN0aW9uID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nvbm5lY3Rpb24nKTtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gYWRkTGlzdGVuZXJzKHRoaXMuX3NlcnZlciwge1xuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcbiAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxuICAgICAgICB1cGdyYWRlOiAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGVtaXRDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPT09IHRydWUpIG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jbGllbnRUcmFja2luZykge1xuICAgICAgdGhpcy5jbGllbnRzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcbiAgICogYXMgcmVwb3J0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0gaWYgbGlzdGVuaW5nIG9uIGFuIElQIHNvY2tldC5cbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG9wZXJhdGluZyBpbiBcIm5vU2VydmVyXCIgbW9kZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc2VydmVyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBzZXJ2ZXIgZnJvbSBhY2NlcHRpbmcgbmV3IGNvbm5lY3Rpb25zIGFuZCBlbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogd2hlbiBhbGwgZXhpc3RpbmcgY29ubmVjdGlvbnMgYXJlIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBBIG9uZS10aW1lIGxpc3RlbmVyIGZvciB0aGUgYCdjbG9zZSdgIGV2ZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TRUQpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgIGNiKG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBub3QgcnVubmluZycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2IpIHRoaXMub25jZSgnY2xvc2UnLCBjYik7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NJTkc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudHMuc2l6ZSkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX3NlcnZlcjtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIEhUVFAvUyBzZXJ2ZXIgd2FzIGNyZWF0ZWQgaW50ZXJuYWxseS4gQ2xvc2UgaXQsIGFuZCByZWx5IG9uIGl0c1xuICAgICAgLy8gYCdjbG9zZSdgIGV2ZW50LlxuICAgICAgLy9cbiAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgIGVtaXRDbG9zZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUgaWYgYSBnaXZlbiByZXF1ZXN0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoaXMgc2VydmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgUmVxdWVzdCBvYmplY3QgdG8gaW5zcGVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlcXVlc3QgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzaG91bGRIYW5kbGUocmVxKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHJlcS51cmwuaW5kZXhPZignPycpO1xuICAgICAgY29uc3QgcGF0aG5hbWUgPSBpbmRleCAhPT0gLTEgPyByZXEudXJsLnNsaWNlKDAsIGluZGV4KSA6IHJlcS51cmw7XG5cbiAgICAgIGlmIChwYXRobmFtZSAhPT0gdGhpcy5vcHRpb25zLnBhdGgpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICBjb25zdCBrZXkgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXTtcbiAgICBjb25zdCB1cGdyYWRlID0gcmVxLmhlYWRlcnMudXBncmFkZTtcbiAgICBjb25zdCB2ZXJzaW9uID0gK3JlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXTtcblxuICAgIGlmIChyZXEubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIEhUVFAgbWV0aG9kJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDA1LCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSA9PT0gdW5kZWZpbmVkIHx8IHVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8ICFrZXlSZWdleC50ZXN0KGtleSkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtS2V5IGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gIT09IDggJiYgdmVyc2lvbiAhPT0gMTMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtVmVyc2lvbiBoZWFkZXInO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zaG91bGRIYW5kbGUocmVxKSkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldFByb3RvY29sID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcbiAgICBsZXQgcHJvdG9jb2xzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldFByb3RvY29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHByb3RvY29scyA9IHN1YnByb3RvY29sLnBhcnNlKHNlY1dlYlNvY2tldFByb3RvY29sKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2ZmZXJzID0gZXh0ZW5zaW9uLnBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuXG4gICAgICAgIGlmIChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgICAgICBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnSW52YWxpZCBvciB1bmFjY2VwdGFibGUgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIGNsaWVudCB2ZXJpZmljYXRpb24gaGFuZGxlci5cbiAgICAvL1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KSB7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBvcmlnaW46XG4gICAgICAgICAgcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/ICdzZWMtd2Vic29ja2V0LW9yaWdpbicgOiAnb3JpZ2luJ31gXSxcbiAgICAgICAgc2VjdXJlOiAhIShyZXEuc29ja2V0LmF1dGhvcml6ZWQgfHwgcmVxLnNvY2tldC5lbmNyeXB0ZWQpLFxuICAgICAgICByZXFcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8sICh2ZXJpZmllZCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykgPT4ge1xuICAgICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUgfHwgNDAxLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgY2JcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogVXBncmFkZSB0aGUgY29ubmVjdGlvbiB0byBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIHZhbHVlIG9mIHRoZSBgU2VjLVdlYlNvY2tldC1LZXlgIGhlYWRlclxuICAgKiBAcGFyYW0ge1NldH0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lIHNvY2tldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICAvL1xuICAgIC8vIERlc3Ryb3kgdGhlIHNvY2tldCBpZiB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IHNlbnQgYSBGSU4gcGFja2V0LlxuICAgIC8vXG4gICAgaWYgKCFzb2NrZXQucmVhZGFibGUgfHwgIXNvY2tldC53cml0YWJsZSkgcmV0dXJuIHNvY2tldC5kZXN0cm95KCk7XG5cbiAgICBpZiAoc29ja2V0W2tXZWJTb2NrZXRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSAnICtcbiAgICAgICAgICAnc29ja2V0LCBwb3NzaWJseSBkdWUgdG8gYSBtaXNjb25maWd1cmF0aW9uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPiBSVU5OSU5HKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA1MDMpO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgICAgJ1VwZ3JhZGU6IHdlYnNvY2tldCcsXG4gICAgICAnQ29ubmVjdGlvbjogVXBncmFkZScsXG4gICAgICBgU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICR7ZGlnZXN0fWBcbiAgICBdO1xuXG4gICAgY29uc3Qgd3MgPSBuZXcgdGhpcy5vcHRpb25zLldlYlNvY2tldChudWxsLCB1bmRlZmluZWQsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBpZiAocHJvdG9jb2xzLnNpemUpIHtcbiAgICAgIC8vXG4gICAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgcHJvdG9jb2wgc2VsZWN0aW9uIGhhbmRsZXIuXG4gICAgICAvL1xuICAgICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzXG4gICAgICAgID8gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29scyhwcm90b2NvbHMsIHJlcSlcbiAgICAgICAgOiBwcm90b2NvbHMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXG4gICAgICBpZiAocHJvdG9jb2wpIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LVByb3RvY29sOiAke3Byb3RvY29sfWApO1xuICAgICAgICB3cy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5wYXJhbXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5mb3JtYXQoe1xuICAgICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IFtwYXJhbXNdXG4gICAgICB9KTtcbiAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zOiAke3ZhbHVlfWApO1xuICAgICAgd3MuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQWxsb3cgZXh0ZXJuYWwgbW9kaWZpY2F0aW9uL2luc3BlY3Rpb24gb2YgaGFuZHNoYWtlIGhlYWRlcnMuXG4gICAgLy9cbiAgICB0aGlzLmVtaXQoJ2hlYWRlcnMnLCBoZWFkZXJzLCByZXEpO1xuXG4gICAgc29ja2V0LndyaXRlKGhlYWRlcnMuY29uY2F0KCdcXHJcXG4nKS5qb2luKCdcXHJcXG4nKSk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgd3Muc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdGhpcy5vcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMsXG4gICAgICBtYXhQYXlsb2FkOiB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogdGhpcy5vcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgdGhpcy5jbGllbnRzLmFkZCh3cyk7XG4gICAgICB3cy5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUod3MpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRFbWl0Q2xvc2UgJiYgIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYih3cywgcmVxKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGBFdmVudEVtaXR0ZXJgIHVzaW5nIGEgbWFwIG9mIDxldmVudCwgbGlzdGVuZXI+XG4gKiBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IG1hcCBUaGUgbGlzdGVuZXJzIHRvIGFkZFxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWRkZWQgbGlzdGVuZXJzIHdoZW5cbiAqICAgICBjYWxsZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhzZXJ2ZXIsIG1hcCkge1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHNlcnZlci5vbihldmVudCwgbWFwW2V2ZW50XSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHtcbiAgICAgIHNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbWFwW2V2ZW50XSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEVtaXQgYSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYW4gYEV2ZW50RW1pdHRlcmAuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHNlcnZlcikge1xuICBzZXJ2ZXIuX3N0YXRlID0gQ0xPU0VEO1xuICBzZXJ2ZXIuZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgc29ja2V0IGVycm9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICB0aGlzLmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBmdWxmaWxsZWQuXG4gKlxuICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gQWRkaXRpb25hbCBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICAvL1xuICAvLyBUaGUgc29ja2V0IGlzIHdyaXRhYmxlIHVubGVzcyB0aGUgdXNlciBkZXN0cm95ZWQgb3IgZW5kZWQgaXQgYmVmb3JlIGNhbGxpbmdcbiAgLy8gYHNlcnZlci5oYW5kbGVVcGdyYWRlKClgIG9yIGluIHRoZSBgdmVyaWZ5Q2xpZW50YCBmdW5jdGlvbiwgd2hpY2ggaXMgYSB1c2VyXG4gIC8vIGVycm9yLiBIYW5kbGluZyB0aGlzIGRvZXMgbm90IG1ha2UgbXVjaCBzZW5zZSBhcyB0aGUgd29yc3QgdGhhdCBjYW4gaGFwcGVuXG4gIC8vIGlzIHRoYXQgc29tZSBvZiB0aGUgZGF0YSB3cml0dGVuIGJ5IHRoZSB1c2VyIG1pZ2h0IGJlIGRpc2NhcmRlZCBkdWUgdG8gdGhlXG4gIC8vIGNhbGwgdG8gYHNvY2tldC5lbmQoKWAgYmVsb3csIHdoaWNoIHRyaWdnZXJzIGFuIGAnZXJyb3InYCBldmVudCB0aGF0IGluXG4gIC8vIHR1cm4gY2F1c2VzIHRoZSBzb2NrZXQgdG8gYmUgZGVzdHJveWVkLlxuICAvL1xuICBtZXNzYWdlID0gbWVzc2FnZSB8fCBodHRwLlNUQVRVU19DT0RFU1tjb2RlXTtcbiAgaGVhZGVycyA9IHtcbiAgICBDb25uZWN0aW9uOiAnY2xvc2UnLFxuICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcbiAgICAnQ29udGVudC1MZW5ndGgnOiBCdWZmZXIuYnl0ZUxlbmd0aChtZXNzYWdlKSxcbiAgICAuLi5oZWFkZXJzXG4gIH07XG5cbiAgc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIHNvY2tldC5kZXN0cm95KTtcblxuICBzb2NrZXQuZW5kKFxuICAgIGBIVFRQLzEuMSAke2NvZGV9ICR7aHR0cC5TVEFUVVNfQ09ERVNbY29kZV19XFxyXFxuYCArXG4gICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICAubWFwKChoKSA9PiBgJHtofTogJHtoZWFkZXJzW2hdfWApXG4gICAgICAgIC5qb2luKCdcXHJcXG4nKSArXG4gICAgICAnXFxyXFxuXFxyXFxuJyArXG4gICAgICBtZXNzYWdlXG4gICk7XG59XG5cbi8qKlxuICogRW1pdCBhIGAnd3NDbGllbnRFcnJvcidgIGV2ZW50IG9uIGEgYFdlYlNvY2tldFNlcnZlcmAgaWYgdGhlcmUgaXMgYXQgbGVhc3RcbiAqIG9uZSBsaXN0ZW5lciBmb3IgaXQsIG90aGVyd2lzZSBjYWxsIGBhYm9ydEhhbmRzaGFrZSgpYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldFNlcnZlcn0gc2VydmVyIFRoZSBXZWJTb2NrZXQgc2VydmVyXG4gKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcihzZXJ2ZXIsIHJlcSwgc29ja2V0LCBjb2RlLCBtZXNzYWdlKSB7XG4gIGlmIChzZXJ2ZXIubGlzdGVuZXJDb3VudCgnd3NDbGllbnRFcnJvcicpKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKTtcblxuICAgIHNlcnZlci5lbWl0KCd3c0NsaWVudEVycm9yJywgZXJyLCBzb2NrZXQsIHJlcSk7XG4gIH0gZWxzZSB7XG4gICAgYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ably/node_modules/ws/lib/websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/ably/node_modules/ws/lib/websocket.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { Duplex, Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/sender.js\");\nconst { isBlob } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/validation.js\");\n\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/constants.js\");\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = __webpack_require__(/*! ./event-target */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ably/node_modules/ws/lib/buffer-util.js\");\n\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._errorEmitted = false;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._autoPong = options.autoPong;\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\n   * instead of \"blob\".\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      allowSynchronousEvents: options.allowSynchronousEvents,\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    const sender = new Sender(socket, this._extensions, options.generateMask);\n\n    this._receiver = receiver;\n    this._sender = sender;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    sender[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    sender.onerror = senderOnError;\n\n    //\n    // These methods may not be available if `socket` is just a `Duplex`.\n    //\n    if (socket.setTimeout) socket.setTimeout(0);\n    if (socket.setNoDelay) socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    setCloseTimer(this);\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n *     times in the same tick\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n *     automatically send a pong in response to a ping\n * @param {Function} [options.finishRequest] A function which can be used to\n *     customize the headers of each http request before it is sent\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    allowSynchronousEvents: true,\n    autoPong: true,\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  websocket._autoPong = opts.autoPong;\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n  }\n\n  if (parsedUrl.protocol === 'http:') {\n    parsedUrl.protocol = 'ws:';\n  } else if (parsedUrl.protocol === 'https:') {\n    parsedUrl.protocol = 'wss:';\n  }\n\n  websocket._url = parsedUrl.href;\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n  let invalidUrlMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n    invalidUrlMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' +\n      '\"http:\", \"https\", or \"ws+unix:\"';\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection =\n    opts.createConnection || (isSecure ? tlsConnect : netConnect);\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isIpcUrl) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req;\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalIpc = isIpcUrl;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isIpcUrl\n        ? opts.socketPath\n        : parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isIpcUrl\n        ? websocket._originalIpc\n          ? opts.socketPath === websocket._originalHostOrSocketPath\n          : false\n        : websocket._originalIpc\n          ? false\n          : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n\n        if (!isSameHost) delete opts.headers.host;\n\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n\n    req = websocket._req = request(opts);\n\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req[kAborted]) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const upgrade = res.headers.upgrade;\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      allowSynchronousEvents: opts.allowSynchronousEvents,\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket);\n  } else {\n    req.end();\n  }\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  //\n  // The following assignment is practically useless and is done only for\n  // consistency.\n  //\n  websocket._errorEmitted = true;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    process.nextTick(cb, err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The `Sender` error event handler.\n *\n * @param {Error} The error\n * @private\n */\nfunction senderOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket.readyState === WebSocket.CLOSED) return;\n  if (websocket.readyState === WebSocket.OPEN) {\n    websocket._readyState = WebSocket.CLOSING;\n    setCloseTimer(websocket);\n  }\n\n  //\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\n  // peer to finish sending queued data. There is no need to set a timer here\n  // because `CLOSING` means that it is already set or not needed.\n  //\n  this._socket.end();\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * Set a timer to destroy the underlying raw socket of a WebSocket.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @private\n */\nfunction setCloseTimer(websocket) {\n  websocket._closeTimer = setTimeout(\n    websocket._socket.destroy.bind(websocket._socket),\n    closeTimeout\n  );\n}\n\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWJseS9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0Msa0VBQWtFOztBQUUzRjs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNyQyxjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3BELFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QyxRQUFRLE1BQU0sRUFBRSxtQkFBTyxDQUFDLGdCQUFLOztBQUU3QiwwQkFBMEIsbUJBQU8sQ0FBQyxpR0FBc0I7QUFDeEQsaUJBQWlCLG1CQUFPLENBQUMsNkVBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHlFQUFVO0FBQ2pDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsaUZBQWM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLCtFQUFhO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHFGQUFnQjtBQUM1QixRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsK0VBQWE7QUFDL0MsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxtRkFBZTs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsa0JBQWtCO0FBQzNFLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RCxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQixHQUFHLG1CQUFtQjtBQUM1RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FB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QVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhY2thdGhvblxcSGFja3NwaXJlXFxub2RlX21vZHVsZXNcXGFibHlcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcd2Vic29ja2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleHxSZWFkYWJsZSRcIiwgXCJjYXVnaHRFcnJvcnNcIjogXCJub25lXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyByYW5kb21CeXRlcywgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCB7IER1cGxleCwgUmVhZGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXInKTtcbmNvbnN0IFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyJyk7XG5jb25zdCB7IGlzQmxvYiB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIEdVSUQsXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlLFxuICBrTGlzdGVuZXIsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0LFxuICBOT09QXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHtcbiAgRXZlbnRUYXJnZXQ6IHsgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciB9XG59ID0gcmVxdWlyZSgnLi9ldmVudC10YXJnZXQnKTtcbmNvbnN0IHsgZm9ybWF0LCBwYXJzZSB9ID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IHsgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3QgY2xvc2VUaW1lb3V0ID0gMzAgKiAxMDAwO1xuY29uc3Qga0Fib3J0ZWQgPSBTeW1ib2woJ2tBYm9ydGVkJyk7XG5jb25zdCBwcm90b2NvbFZlcnNpb25zID0gWzgsIDEzXTtcbmNvbnN0IHJlYWR5U3RhdGVzID0gWydDT05ORUNUSU5HJywgJ09QRU4nLCAnQ0xPU0lORycsICdDTE9TRUQnXTtcbmNvbnN0IHN1YnByb3RvY29sUmVnZXggPSAvXlshIyQlJicqK1xcLS4wLTlBLVpeX2B8YS16fl0rJC87XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBXZWJTb2NrZXRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAgICogQHBhcmFtIHsoU3RyaW5nfFN0cmluZ1tdKX0gW3Byb3RvY29sc10gVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fY2xvc2VDb2RlID0gMTAwNjtcbiAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlTWVzc2FnZSA9IEVNUFRZX0JVRkZFUjtcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcHJvdG9jb2wgPSAnJztcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3NlbmRlciA9IG51bGw7XG4gICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcblxuICAgIGlmIChhZGRyZXNzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9idWZmZXJlZEFtb3VudCA9IDA7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVkaXJlY3RzID0gMDtcblxuICAgICAgaWYgKHByb3RvY29scyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnb2JqZWN0JyAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gcHJvdG9jb2xzO1xuICAgICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh0aGlzLCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hdXRvUG9uZyA9IG9wdGlvbnMuYXV0b1Bvbmc7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIHRoZSBjdXN0b20gXCJub2RlYnVmZmVyXCIgdHlwZSBpcyB1c2VkIGJ5IHRoZSBkZWZhdWx0XG4gICAqIGluc3RlYWQgb2YgXCJibG9iXCIuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgYmluYXJ5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluYXJ5VHlwZTtcbiAgfVxuXG4gIHNldCBiaW5hcnlUeXBlKHR5cGUpIHtcbiAgICBpZiAoIUJJTkFSWV9UWVBFUy5pbmNsdWRlcyh0eXBlKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IHR5cGU7XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IHRvIGNoYW5nZSBgYmluYXJ5VHlwZWAgb24gdGhlIGZseS5cbiAgICAvL1xuICAgIGlmICh0aGlzLl9yZWNlaXZlcikgdGhpcy5fcmVjZWl2ZXIuX2JpbmFyeVR5cGUgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYnVmZmVyZWRBbW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHJldHVybiB0aGlzLl9idWZmZXJlZEFtb3VudDtcblxuICAgIHJldHVybiB0aGlzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUubGVuZ3RoICsgdGhpcy5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZXh0ZW5zaW9ucygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZXh0ZW5zaW9ucykuam9pbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGlzUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9uY2xvc2UoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9uZXJyb3IoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ub3BlbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25tZXNzYWdlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgcHJvdG9jb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgc29ja2V0IGFuZCB0aGUgaW50ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFNvY2tldChzb2NrZXQsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZWNlaXZlciA9IG5ldyBSZWNlaXZlcih7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiBvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMsXG4gICAgICBiaW5hcnlUeXBlOiB0aGlzLmJpbmFyeVR5cGUsXG4gICAgICBleHRlbnNpb25zOiB0aGlzLl9leHRlbnNpb25zLFxuICAgICAgaXNTZXJ2ZXI6IHRoaXMuX2lzU2VydmVyLFxuICAgICAgbWF4UGF5bG9hZDogb3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgY29uc3Qgc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMsIG9wdGlvbnMuZ2VuZXJhdGVNYXNrKTtcblxuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fc2VuZGVyID0gc2VuZGVyO1xuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHJlY2VpdmVyW2tXZWJTb2NrZXRdID0gdGhpcztcbiAgICBzZW5kZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNvY2tldFtrV2ViU29ja2V0XSA9IHRoaXM7XG5cbiAgICByZWNlaXZlci5vbignY29uY2x1ZGUnLCByZWNlaXZlck9uQ29uY2x1ZGUpO1xuICAgIHJlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcbiAgICByZWNlaXZlci5vbignbWVzc2FnZScsIHJlY2VpdmVyT25NZXNzYWdlKTtcbiAgICByZWNlaXZlci5vbigncGluZycsIHJlY2VpdmVyT25QaW5nKTtcbiAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcblxuICAgIHNlbmRlci5vbmVycm9yID0gc2VuZGVyT25FcnJvcjtcblxuICAgIC8vXG4gICAgLy8gVGhlc2UgbWV0aG9kcyBtYXkgbm90IGJlIGF2YWlsYWJsZSBpZiBgc29ja2V0YCBpcyBqdXN0IGEgYER1cGxleGAuXG4gICAgLy9cbiAgICBpZiAoc29ja2V0LnNldFRpbWVvdXQpIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgIGlmIChzb2NrZXQuc2V0Tm9EZWxheSkgc29ja2V0LnNldE5vRGVsYXkoKTtcblxuICAgIGlmIChoZWFkLmxlbmd0aCA+IDApIHNvY2tldC51bnNoaWZ0KGhlYWQpO1xuXG4gICAgc29ja2V0Lm9uKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICAgIHNvY2tldC5vbignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gICAgc29ja2V0Lm9uKCdlbmQnLCBzb2NrZXRPbkVuZCk7XG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5PUEVOO1xuICAgIHRoaXMuZW1pdCgnb3BlbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgdGhlIGAnY2xvc2UnYCBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtaXRDbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLmNsZWFudXAoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWNlaXZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgY2xvc2luZyBoYW5kc2hha2UuXG4gICAqXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLStcbiAgICogICAgIC0gLSAtfHdzLmNsb3NlKCl8LS0+fGNsb3NlIGZyYW1lfC0tPnx3cy5jbG9zZSgpfC0gLSAtXG4gICAqICAgIHwgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLSsgICAgIHxcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICAgICAgIHxcbiAgICogQ0xPU0lORyAgfHdzLmNsb3NlKCl8PC0tfGNsb3NlIGZyYW1lfDwtLSstLS0tLSsgICAgICAgQ0xPU0lOR1xuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgfFxuICAgKiAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0+fGZpbnwgLSAtIC0gLVxuICAgKiAgICB8ICAgICAgICAgKy0tLSsgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rXG4gICAqICAgICAtIC0gLSAtIC18ZmlufDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAqICAgICAgICAgICAgICArLS0tK1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgcmVhc29uIHdoeSB0aGUgY29ubmVjdGlvbiBpc1xuICAgKiAgICAgY2xvc2luZ1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NJTkcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgJiZcbiAgICAgICAgKHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fCB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuX3NlbmRlci5jbG9zZShjb2RlLCBkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIChlcnIpID0+IHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIGhhbmRsZWQgYnkgdGhlIGAnZXJyb3InYCBsaXN0ZW5lciBvbiB0aGUgc29ja2V0LiBXZSBvbmx5XG4gICAgICAvLyB3YW50IHRvIGtub3cgaWYgdGhlIGNsb3NlIGZyYW1lIGhhcyBiZWVuIHNlbnQgaGVyZS5cbiAgICAgIC8vXG4gICAgICBpZiAoZXJyKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gdHJ1ZTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHxcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc2V0Q2xvc2VUaW1lcih0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgc29ja2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBwYXVzZSgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRURcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NvY2tldC5wYXVzZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBpbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBpbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcG9uZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwb25nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBtYXNrO1xuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5wb25nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlc3VtZSgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRURcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLm5lZWREcmFpbikgdGhpcy5fc29ja2V0LnJlc3VtZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnldIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnkgb3JcbiAgICogICAgIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzc10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZVxuICAgKiAgICAgbGFzdCBvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIGRhdGEgaXMgd3JpdHRlbiBvdXRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBiaW5hcnk6IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyxcbiAgICAgIG1hc2s6ICF0aGlzLl9pc1NlcnZlcixcbiAgICAgIGNvbXByZXNzOiB0cnVlLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZW5kZXIuc2VuZChkYXRhIHx8IEVNUFRZX0JVRkZFUiwgb3B0cywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNpYmx5IGNsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgICAgdGhpcy5fc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ09OTkVDVElORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENPTk5FQ1RJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ09OTkVDVElORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ09QRU4nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBPUEVOXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ09QRU4nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDTE9TSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0lORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0lOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDTE9TSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0lORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDTE9TRUQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NFRFxuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDTE9TRUQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxufSk7XG5cbltcbiAgJ2JpbmFyeVR5cGUnLFxuICAnYnVmZmVyZWRBbW91bnQnLFxuICAnZXh0ZW5zaW9ucycsXG4gICdpc1BhdXNlZCcsXG4gICdwcm90b2NvbCcsXG4gICdyZWFkeVN0YXRlJyxcbiAgJ3VybCdcbl0uZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsIHByb3BlcnR5LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG59KTtcblxuLy9cbi8vIEFkZCB0aGUgYG9ub3BlbmAsIGBvbmVycm9yYCwgYG9uY2xvc2VgLCBhbmQgYG9ubWVzc2FnZWAgYXR0cmlidXRlcy5cbi8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9jb21tcy5odG1sI3RoZS13ZWJzb2NrZXQtaW50ZXJmYWNlXG4vL1xuWydvcGVuJywgJ2Vycm9yJywgJ2Nsb3NlJywgJ21lc3NhZ2UnXS5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsIGBvbiR7bWV0aG9kfWAsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldCgpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMobWV0aG9kKSkge1xuICAgICAgICBpZiAobGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSByZXR1cm4gbGlzdGVuZXJba0xpc3RlbmVyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzZXQoaGFuZGxlcikge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKG1ldGhvZCwgbGlzdGVuZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBoYW5kbGVyLCB7XG4gICAgICAgIFtrRm9yT25FdmVudEF0dHJpYnV0ZV06IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59KTtcblxuV2ViU29ja2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcbldlYlNvY2tldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBXZWJTb2NrZXQgY2xpZW50LlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIGNsaWVudCB0byBpbml0aWFsaXplXG4gKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3RvY29scyBUaGUgc3VicHJvdG9jb2xzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIGFueVxuICogICAgIG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWQgbXVsdGlwbGVcbiAqICAgICB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9Qb25nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICogICAgIGF1dG9tYXRpY2FsbHkgc2VuZCBhIHBvbmcgaW4gcmVzcG9uc2UgdG8gYSBwaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5maW5pc2hSZXF1ZXN0XSBBIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG4gKiAgICAgY3VzdG9taXplIHRoZSBoZWFkZXJzIG9mIGVhY2ggaHR0cCByZXF1ZXN0IGJlZm9yZSBpdCBpcyBzZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvbGxvd1JlZGlyZWN0cz1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gZm9sbG93XG4gKiAgICAgcmVkaXJlY3RzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICogICAgIG1hc2tpbmcga2V5XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGFuZHNoYWtlVGltZW91dF0gVGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZVxuICogICAgIGhhbmRzaGFrZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0xMDQ4NTc2MDBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZVxuICogICAgIHNpemVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhSZWRpcmVjdHM9MTBdIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHNcbiAqICAgICBhbGxvd2VkXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMub3JpZ2luXSBWYWx1ZSBvZiB0aGUgYE9yaWdpbmAgb3JcbiAqICAgICBgU2VjLVdlYlNvY2tldC1PcmlnaW5gIGhlYWRlclxuICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT10cnVlXSBFbmFibGUvZGlzYWJsZVxuICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByb3RvY29sVmVyc2lvbj0xM10gVmFsdWUgb2YgdGhlXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtVmVyc2lvbmAgaGVhZGVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdHJ1ZSxcbiAgICBhdXRvUG9uZzogdHJ1ZSxcbiAgICBwcm90b2NvbFZlcnNpb246IHByb3RvY29sVmVyc2lvbnNbMV0sXG4gICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgc2tpcFVURjhWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdHJ1ZSxcbiAgICBmb2xsb3dSZWRpcmVjdHM6IGZhbHNlLFxuICAgIG1heFJlZGlyZWN0czogMTAsXG4gICAgLi4ub3B0aW9ucyxcbiAgICBzb2NrZXRQYXRoOiB1bmRlZmluZWQsXG4gICAgaG9zdG5hbWU6IHVuZGVmaW5lZCxcbiAgICBwcm90b2NvbDogdW5kZWZpbmVkLFxuICAgIHRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIGhvc3Q6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgcG9ydDogdW5kZWZpbmVkXG4gIH07XG5cbiAgd2Vic29ja2V0Ll9hdXRvUG9uZyA9IG9wdHMuYXV0b1Bvbmc7XG5cbiAgaWYgKCFwcm90b2NvbFZlcnNpb25zLmluY2x1ZGVzKG9wdHMucHJvdG9jb2xWZXJzaW9uKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgYFVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb246ICR7b3B0cy5wcm90b2NvbFZlcnNpb259IGAgK1xuICAgICAgICBgKHN1cHBvcnRlZCB2ZXJzaW9uczogJHtwcm90b2NvbFZlcnNpb25zLmpvaW4oJywgJyl9KWBcbiAgICApO1xuICB9XG5cbiAgbGV0IHBhcnNlZFVybDtcblxuICBpZiAoYWRkcmVzcyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHBhcnNlZFVybCA9IGFkZHJlc3M7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFVybCA9IG5ldyBVUkwoYWRkcmVzcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSAnd3M6JztcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgcGFyc2VkVXJsLnByb3RvY29sID0gJ3dzczonO1xuICB9XG5cbiAgd2Vic29ja2V0Ll91cmwgPSBwYXJzZWRVcmwuaHJlZjtcblxuICBjb25zdCBpc1NlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzczonO1xuICBjb25zdCBpc0lwY1VybCA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzK3VuaXg6JztcbiAgbGV0IGludmFsaWRVcmxNZXNzYWdlO1xuXG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09ICd3czonICYmICFpc1NlY3VyZSAmJiAhaXNJcGNVcmwpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9XG4gICAgICAnVGhlIFVSTFxcJ3MgcHJvdG9jb2wgbXVzdCBiZSBvbmUgb2YgXCJ3czpcIiwgXCJ3c3M6XCIsICcgK1xuICAgICAgJ1wiaHR0cDpcIiwgXCJodHRwc1wiLCBvciBcIndzK3VuaXg6XCInO1xuICB9IGVsc2UgaWYgKGlzSXBjVXJsICYmICFwYXJzZWRVcmwucGF0aG5hbWUpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9IFwiVGhlIFVSTCdzIHBhdGhuYW1lIGlzIGVtcHR5XCI7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9ICdUaGUgVVJMIGNvbnRhaW5zIGEgZnJhZ21lbnQgaWRlbnRpZmllcic7XG4gIH1cblxuICBpZiAoaW52YWxpZFVybE1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IoaW52YWxpZFVybE1lc3NhZ2UpO1xuXG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZWZhdWx0UG9ydCA9IGlzU2VjdXJlID8gNDQzIDogODA7XG4gIGNvbnN0IGtleSA9IHJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIGNvbnN0IHJlcXVlc3QgPSBpc1NlY3VyZSA/IGh0dHBzLnJlcXVlc3QgOiBodHRwLnJlcXVlc3Q7XG4gIGNvbnN0IHByb3RvY29sU2V0ID0gbmV3IFNldCgpO1xuICBsZXQgcGVyTWVzc2FnZURlZmxhdGU7XG5cbiAgb3B0cy5jcmVhdGVDb25uZWN0aW9uID1cbiAgICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gfHwgKGlzU2VjdXJlID8gdGxzQ29ubmVjdCA6IG5ldENvbm5lY3QpO1xuICBvcHRzLmRlZmF1bHRQb3J0ID0gb3B0cy5kZWZhdWx0UG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5wb3J0ID0gcGFyc2VkVXJsLnBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMuaG9zdCA9IHBhcnNlZFVybC5ob3N0bmFtZS5zdGFydHNXaXRoKCdbJylcbiAgICA/IHBhcnNlZFVybC5ob3N0bmFtZS5zbGljZSgxLCAtMSlcbiAgICA6IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgb3B0cy5oZWFkZXJzID0ge1xuICAgIC4uLm9wdHMuaGVhZGVycyxcbiAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0cy5wcm90b2NvbFZlcnNpb24sXG4gICAgJ1NlYy1XZWJTb2NrZXQtS2V5Jzoga2V5LFxuICAgIENvbm5lY3Rpb246ICdVcGdyYWRlJyxcbiAgICBVcGdyYWRlOiAnd2Vic29ja2V0J1xuICB9O1xuICBvcHRzLnBhdGggPSBwYXJzZWRVcmwucGF0aG5hbWUgKyBwYXJzZWRVcmwuc2VhcmNoO1xuICBvcHRzLnRpbWVvdXQgPSBvcHRzLmhhbmRzaGFrZVRpbWVvdXQ7XG5cbiAgaWYgKG9wdHMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgIG9wdHMucGVyTWVzc2FnZURlZmxhdGUgIT09IHRydWUgPyBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIDoge30sXG4gICAgICBmYWxzZSxcbiAgICAgIG9wdHMubWF4UGF5bG9hZFxuICAgICk7XG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnXSA9IGZvcm1hdCh7XG4gICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IHBlck1lc3NhZ2VEZWZsYXRlLm9mZmVyKClcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvdG9jb2xzLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcHJvdG9jb2xzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBwcm90b2NvbCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIXN1YnByb3RvY29sUmVnZXgudGVzdChwcm90b2NvbCkgfHxcbiAgICAgICAgcHJvdG9jb2xTZXQuaGFzKHByb3RvY29sKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICAnQW4gaW52YWxpZCBvciBkdXBsaWNhdGVkIHN1YnByb3RvY29sIHdhcyBzcGVjaWZpZWQnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29sU2V0LmFkZChwcm90b2NvbCk7XG4gICAgfVxuXG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LVByb3RvY29sJ10gPSBwcm90b2NvbHMuam9pbignLCcpO1xuICB9XG4gIGlmIChvcHRzLm9yaWdpbikge1xuICAgIGlmIChvcHRzLnByb3RvY29sVmVyc2lvbiA8IDEzKSB7XG4gICAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtT3JpZ2luJ10gPSBvcHRzLm9yaWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy5oZWFkZXJzLk9yaWdpbiA9IG9wdHMub3JpZ2luO1xuICAgIH1cbiAgfVxuICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xuICAgIG9wdHMuYXV0aCA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgfVxuXG4gIGlmIChpc0lwY1VybCkge1xuICAgIGNvbnN0IHBhcnRzID0gb3B0cy5wYXRoLnNwbGl0KCc6Jyk7XG5cbiAgICBvcHRzLnNvY2tldFBhdGggPSBwYXJ0c1swXTtcbiAgICBvcHRzLnBhdGggPSBwYXJ0c1sxXTtcbiAgfVxuXG4gIGxldCByZXE7XG5cbiAgaWYgKG9wdHMuZm9sbG93UmVkaXJlY3RzKSB7XG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjID0gaXNJcGNVcmw7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsU2VjdXJlID0gaXNTZWN1cmU7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aCA9IGlzSXBjVXJsXG4gICAgICAgID8gb3B0cy5zb2NrZXRQYXRoXG4gICAgICAgIDogcGFyc2VkVXJsLmhvc3Q7XG5cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycztcblxuICAgICAgLy9cbiAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgdXNlciBwcm92aWRlZCBvcHRpb25zIHNvIHRoYXQgaGVhZGVycyBjYW4gYmUgY2hhbmdlZFxuICAgICAgLy8gd2l0aG91dCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgLy9cbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGhlYWRlcnM6IHt9IH07XG5cbiAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3ZWJzb2NrZXQubGlzdGVuZXJDb3VudCgncmVkaXJlY3QnKSA9PT0gMCkge1xuICAgICAgY29uc3QgaXNTYW1lSG9zdCA9IGlzSXBjVXJsXG4gICAgICAgID8gd2Vic29ja2V0Ll9vcmlnaW5hbElwY1xuICAgICAgICAgID8gb3B0cy5zb2NrZXRQYXRoID09PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aFxuICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgOiB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjXG4gICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgIDogcGFyc2VkVXJsLmhvc3QgPT09IHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoO1xuXG4gICAgICBpZiAoIWlzU2FtZUhvc3QgfHwgKHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgJiYgIWlzU2VjdXJlKSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgZHJvcCB0aGUgZm9sbG93aW5nIGhlYWRlcnMuIFRoZXNlXG4gICAgICAgIC8vIGhlYWRlcnMgYXJlIGFsc28gZHJvcHBlZCB3aGVuIGZvbGxvd2luZyBhIHJlZGlyZWN0IHRvIGEgc3ViZG9tYWluLlxuICAgICAgICAvL1xuICAgICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmF1dGhvcml6YXRpb247XG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuY29va2llO1xuXG4gICAgICAgIGlmICghaXNTYW1lSG9zdCkgZGVsZXRlIG9wdHMuaGVhZGVycy5ob3N0O1xuXG4gICAgICAgIG9wdHMuYXV0aCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBtYWtlIHRoZSBmaXJzdCBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIHdpbi5cbiAgICAvLyBJZiB0aGUgYEF1dGhvcml6YXRpb25gIGhlYWRlciBpcyBzZXQsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkbyBhcyBpdFxuICAgIC8vIHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICAgIC8vXG4gICAgaWYgKG9wdHMuYXV0aCAmJiAhb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uID1cbiAgICAgICAgJ0Jhc2ljICcgKyBCdWZmZXIuZnJvbShvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IHJlcXVlc3Qob3B0cyk7XG5cbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMpIHtcbiAgICAgIC8vXG4gICAgICAvLyBVbmxpa2Ugd2hhdCBpcyBkb25lIGZvciB0aGUgYCd1cGdyYWRlJ2AgZXZlbnQsIG5vIGVhcmx5IGV4aXQgaXNcbiAgICAgIC8vIHRyaWdnZXJlZCBoZXJlIGlmIHRoZSB1c2VyIGNhbGxzIGB3ZWJzb2NrZXQuY2xvc2UoKWAgb3JcbiAgICAgIC8vIGB3ZWJzb2NrZXQudGVybWluYXRlKClgIGZyb20gYSBsaXN0ZW5lciBvZiB0aGUgYCdyZWRpcmVjdCdgIGV2ZW50LiBUaGlzXG4gICAgICAvLyBpcyBiZWNhdXNlIHRoZSB1c2VyIGNhbiBhbHNvIGNhbGwgYHJlcXVlc3QuZGVzdHJveSgpYCB3aXRoIGFuIGVycm9yXG4gICAgICAvLyBiZWZvcmUgY2FsbGluZyBgd2Vic29ja2V0LmNsb3NlKClgIG9yIGB3ZWJzb2NrZXQudGVybWluYXRlKClgIGFuZCB0aGlzXG4gICAgICAvLyB3b3VsZCByZXN1bHQgaW4gYW4gZXJyb3IgYmVpbmcgZW1pdHRlZCBvbiB0aGUgYHJlcXVlc3RgIG9iamVjdCB3aXRoIG5vXG4gICAgICAvLyBgJ2Vycm9yJ2AgZXZlbnQgbGlzdGVuZXJzIGF0dGFjaGVkLlxuICAgICAgLy9cbiAgICAgIHdlYnNvY2tldC5lbWl0KCdyZWRpcmVjdCcsIHdlYnNvY2tldC51cmwsIHJlcSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcbiAgfVxuXG4gIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICByZXEub24oJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ09wZW5pbmcgaGFuZHNoYWtlIGhhcyB0aW1lZCBvdXQnKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlcS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgaWYgKHJlcSA9PT0gbnVsbCB8fCByZXFba0Fib3J0ZWRdKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG4gICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICB9KTtcblxuICByZXEub24oJ3Jlc3BvbnNlJywgKHJlcykgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzLmhlYWRlcnMubG9jYXRpb247XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuXG4gICAgaWYgKFxuICAgICAgbG9jYXRpb24gJiZcbiAgICAgIG9wdHMuZm9sbG93UmVkaXJlY3RzICYmXG4gICAgICBzdGF0dXNDb2RlID49IDMwMCAmJlxuICAgICAgc3RhdHVzQ29kZSA8IDQwMFxuICAgICkge1xuICAgICAgaWYgKCsrd2Vic29ja2V0Ll9yZWRpcmVjdHMgPiBvcHRzLm1heFJlZGlyZWN0cykge1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ01heGltdW0gcmVkaXJlY3RzIGV4Y2VlZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVxLmFib3J0KCk7XG5cbiAgICAgIGxldCBhZGRyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhZGRyID0gbmV3IFVSTChsb2NhdGlvbiwgYWRkcmVzcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7bG9jYXRpb259YCk7XG4gICAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoIXdlYnNvY2tldC5lbWl0KCd1bmV4cGVjdGVkLXJlc3BvbnNlJywgcmVxLCByZXMpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShcbiAgICAgICAgd2Vic29ja2V0LFxuICAgICAgICByZXEsXG4gICAgICAgIGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZTogJHtyZXMuc3RhdHVzQ29kZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmVxLm9uKCd1cGdyYWRlJywgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgd2Vic29ja2V0LmVtaXQoJ3VwZ3JhZGUnLCByZXMpO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgdXNlciBtYXkgaGF2ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24gZnJvbSBhIGxpc3RlbmVyIG9mIHRoZVxuICAgIC8vIGAndXBncmFkZSdgIGV2ZW50LlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuQ09OTkVDVElORykgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuXG4gICAgY29uc3QgdXBncmFkZSA9IHJlcy5oZWFkZXJzLnVwZ3JhZGU7XG5cbiAgICBpZiAodXBncmFkZSA9PT0gdW5kZWZpbmVkIHx8IHVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBpZiAocmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGRpZ2VzdCkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcnZlclByb3QgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90RXJyb3I7XG5cbiAgICBpZiAoc2VydmVyUHJvdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXByb3RvY29sU2V0LnNpemUpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGEgc3VicHJvdG9jb2wgYnV0IG5vbmUgd2FzIHJlcXVlc3RlZCc7XG4gICAgICB9IGVsc2UgaWYgKCFwcm90b2NvbFNldC5oYXMoc2VydmVyUHJvdCkpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGFuIGludmFsaWQgc3VicHJvdG9jb2wnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IG5vIHN1YnByb3RvY29sJztcbiAgICB9XG5cbiAgICBpZiAocHJvdEVycm9yKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgcHJvdEVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyUHJvdCkgd2Vic29ja2V0Ll9wcm90b2NvbCA9IHNlcnZlclByb3Q7XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnU2VydmVyIHNlbnQgYSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIGJ1dCBubyBleHRlbnNpb24gJyArXG4gICAgICAgICAgJ3dhcyByZXF1ZXN0ZWQnO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGV4dGVuc2lvbnM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZShzZWNXZWJTb2NrZXRFeHRlbnNpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRlbnNpb25OYW1lcyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGV4dGVuc2lvbk5hbWVzLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICBleHRlbnNpb25OYW1lc1swXSAhPT0gUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnU2VydmVyIGluZGljYXRlZCBhbiBleHRlbnNpb24gdGhhdCB3YXMgbm90IHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2Vic29ja2V0Ll9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID1cbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgfVxuXG4gICAgd2Vic29ja2V0LnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcbiAgICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IG9wdHMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIGdlbmVyYXRlTWFzazogb3B0cy5nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXhQYXlsb2FkOiBvcHRzLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdHMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG4gIH0pO1xuXG4gIGlmIChvcHRzLmZpbmlzaFJlcXVlc3QpIHtcbiAgICBvcHRzLmZpbmlzaFJlcXVlc3QocmVxLCB3ZWJzb2NrZXQpO1xuICB9IGVsc2Uge1xuICAgIHJlcS5lbmQoKTtcbiAgfVxufVxuXG4vKipcbiAqIEVtaXQgdGhlIGAnZXJyb3InYCBhbmQgYCdjbG9zZSdgIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IFRoZSBlcnJvciB0byBlbWl0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycikge1xuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBhc3NpZ25tZW50IGlzIHByYWN0aWNhbGx5IHVzZWxlc3MgYW5kIGlzIGRvbmUgb25seSBmb3JcbiAgLy8gY29uc2lzdGVuY3kuXG4gIC8vXG4gIHdlYnNvY2tldC5fZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBuZXQuU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7bmV0LlNvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5ldENvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnNvY2tldFBhdGg7XG4gIHJldHVybiBuZXQuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgdGxzLlRMU1NvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge3Rscy5UTFNTb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0bHNDb25uZWN0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5wYXRoID0gdW5kZWZpbmVkO1xuXG4gIGlmICghb3B0aW9ucy5zZXJ2ZXJuYW1lICYmIG9wdGlvbnMuc2VydmVybmFtZSAhPT0gJycpIHtcbiAgICBvcHRpb25zLnNlcnZlcm5hbWUgPSBuZXQuaXNJUChvcHRpb25zLmhvc3QpID8gJycgOiBvcHRpb25zLmhvc3Q7XG4gIH1cblxuICByZXR1cm4gdGxzLmNvbm5lY3Qob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQWJvcnQgdGhlIGhhbmRzaGFrZSBhbmQgZW1pdCBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7KGh0dHAuQ2xpZW50UmVxdWVzdHxuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzdHJlYW0gVGhlIHJlcXVlc3QgdG9cbiAqICAgICBhYm9ydCBvciB0aGUgc29ja2V0IHRvIGRlc3Ryb3lcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHN0cmVhbSwgbWVzc2FnZSkge1xuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2UpO1xuXG4gIGlmIChzdHJlYW0uc2V0SGVhZGVyKSB7XG4gICAgc3RyZWFtW2tBYm9ydGVkXSA9IHRydWU7XG4gICAgc3RyZWFtLmFib3J0KCk7XG5cbiAgICBpZiAoc3RyZWFtLnNvY2tldCAmJiAhc3RyZWFtLnNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIC8vXG4gICAgICAvLyBPbiBOb2RlLmpzID49IDE0LjMuMCBgcmVxdWVzdC5hYm9ydCgpYCBkb2VzIG5vdCBkZXN0cm95IHRoZSBzb2NrZXQgaWZcbiAgICAgIC8vIGNhbGxlZCBhZnRlciB0aGUgcmVxdWVzdCBjb21wbGV0ZWQuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzE4NjkuXG4gICAgICAvL1xuICAgICAgc3RyZWFtLnNvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZSwgd2Vic29ja2V0LCBlcnIpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgd2Vic29ja2V0LmVtaXQuYmluZCh3ZWJzb2NrZXQsICdlcnJvcicpKTtcbiAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgY2FzZXMgd2hlcmUgdGhlIGBwaW5nKClgLCBgcG9uZygpYCwgb3IgYHNlbmQoKWAgbWV0aG9kcyBhcmUgY2FsbGVkXG4gKiB3aGVuIHRoZSBgcmVhZHlTdGF0ZWAgYXR0cmlidXRlIGlzIGBDTE9TSU5HYCBvciBgQ0xPU0VEYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlbmRBZnRlckNsb3NlKHdlYnNvY2tldCwgZGF0YSwgY2IpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICBjb25zdCBsZW5ndGggPSBpc0Jsb2IoZGF0YSkgPyBkYXRhLnNpemUgOiB0b0J1ZmZlcihkYXRhKS5sZW5ndGg7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBgX2J1ZmZlcmVkQW1vdW50YCBwcm9wZXJ0eSBpcyB1c2VkIG9ubHkgd2hlbiB0aGUgcGVlciBpcyBhIGNsaWVudCBhbmRcbiAgICAvLyB0aGUgb3BlbmluZyBoYW5kc2hha2UgZmFpbHMuIFVuZGVyIHRoZXNlIGNpcmN1bXN0YW5jZXMsIGluIGZhY3QsIHRoZVxuICAgIC8vIGBzZXRTb2NrZXQoKWAgbWV0aG9kIGlzIG5vdCBjYWxsZWQsIHNvIHRoZSBgX3NvY2tldGAgYW5kIGBfc2VuZGVyYFxuICAgIC8vIHByb3BlcnRpZXMgYXJlIHNldCB0byBgbnVsbGAuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0Ll9zb2NrZXQpIHdlYnNvY2tldC5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzICs9IGxlbmd0aDtcbiAgICBlbHNlIHdlYnNvY2tldC5fYnVmZmVyZWRBbW91bnQgKz0gbGVuZ3RoO1xuICB9XG5cbiAgaWYgKGNiKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgYFdlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAke3dlYnNvY2tldC5yZWFkeVN0YXRlfSBgICtcbiAgICAgICAgYCgke3JlYWR5U3RhdGVzW3dlYnNvY2tldC5yZWFkeVN0YXRlXX0pYFxuICAgICk7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2NvbmNsdWRlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmVhc29uIFRoZSByZWFzb24gZm9yIGNsb3NpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IHRydWU7XG4gIHdlYnNvY2tldC5fY2xvc2VNZXNzYWdlID0gcmVhc29uO1xuICB3ZWJzb2NrZXQuX2Nsb3NlQ29kZSA9IGNvZGU7XG5cbiAgaWYgKHdlYnNvY2tldC5fc29ja2V0W2tXZWJTb2NrZXRdID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgaWYgKGNvZGUgPT09IDEwMDUpIHdlYnNvY2tldC5jbG9zZSgpO1xuICBlbHNlIHdlYnNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2RyYWluJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkRyYWluKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICghd2Vic29ja2V0LmlzUGF1c2VkKSB3ZWJzb2NrZXQuX3NvY2tldC5yZXN1bWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFJhbmdlRXJyb3J8RXJyb3IpfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gIT09IHVuZGVmaW5lZCkge1xuICAgIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcblxuICAgIC8vXG4gICAgLy8gT24gTm9kZS5qcyA8IDE0LjAuMCB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgc3luY2hyb25vdXNseS4gU2VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzE5NDAuXG4gICAgLy9cbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSwgd2Vic29ja2V0Ll9zb2NrZXQpO1xuXG4gICAgd2Vic29ja2V0LmNsb3NlKGVycltrU3RhdHVzQ29kZV0pO1xuICB9XG5cbiAgaWYgKCF3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCkge1xuICAgIHdlYnNvY2tldC5fZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZmluaXNoJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkZpbmlzaCgpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0Q2xvc2UoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdtZXNzYWdlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXlCdWZmZXJ8QnVmZmVyW10pfSBkYXRhIFRoZSBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluYXJ5IFNwZWNpZmllcyB3aGV0aGVyIHRoZSBtZXNzYWdlIGlzIGJpbmFyeSBvciBub3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25NZXNzYWdlKGRhdGEsIGlzQmluYXJ5KSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgnbWVzc2FnZScsIGRhdGEsIGlzQmluYXJ5KTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwaW5nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBpbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25QaW5nKGRhdGEpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0Ll9hdXRvUG9uZykgd2Vic29ja2V0LnBvbmcoZGF0YSwgIXRoaXMuX2lzU2VydmVyLCBOT09QKTtcbiAgd2Vic29ja2V0LmVtaXQoJ3BpbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwb25nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBvbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Qb25nKGRhdGEpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdwb25nJywgZGF0YSk7XG59XG5cbi8qKlxuICogUmVzdW1lIGEgcmVhZGFibGUgc3RyZWFtXG4gKlxuICogQHBhcmFtIHtSZWFkYWJsZX0gc3RyZWFtIFRoZSByZWFkYWJsZSBzdHJlYW1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0pIHtcbiAgc3RyZWFtLnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBgU2VuZGVyYCBlcnJvciBldmVudCBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VuZGVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHNldENsb3NlVGltZXIod2Vic29ja2V0KTtcbiAgfVxuXG4gIC8vXG4gIC8vIGBzb2NrZXQuZW5kKClgIGlzIHVzZWQgaW5zdGVhZCBvZiBgc29ja2V0LmRlc3Ryb3koKWAgdG8gYWxsb3cgdGhlIG90aGVyXG4gIC8vIHBlZXIgdG8gZmluaXNoIHNlbmRpbmcgcXVldWVkIGRhdGEuIFRoZXJlIGlzIG5vIG5lZWQgdG8gc2V0IGEgdGltZXIgaGVyZVxuICAvLyBiZWNhdXNlIGBDTE9TSU5HYCBtZWFucyB0aGF0IGl0IGlzIGFscmVhZHkgc2V0IG9yIG5vdCBuZWVkZWQuXG4gIC8vXG4gIHRoaXMuX3NvY2tldC5lbmQoKTtcblxuICBpZiAoIXdlYnNvY2tldC5fZXJyb3JFbWl0dGVkKSB7XG4gICAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSB0aW1lciB0byBkZXN0cm95IHRoZSB1bmRlcmx5aW5nIHJhdyBzb2NrZXQgb2YgYSBXZWJTb2NrZXQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRDbG9zZVRpbWVyKHdlYnNvY2tldCkge1xuICB3ZWJzb2NrZXQuX2Nsb3NlVGltZXIgPSBzZXRUaW1lb3V0KFxuICAgIHdlYnNvY2tldC5fc29ja2V0LmRlc3Ryb3kuYmluZCh3ZWJzb2NrZXQuX3NvY2tldCksXG4gICAgY2xvc2VUaW1lb3V0XG4gICk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdjbG9zZSdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uQ2xvc2UoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHNvY2tldE9uRW5kKTtcblxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBsZXQgY2h1bms7XG5cbiAgLy9cbiAgLy8gVGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBoYXZlIGJlZW4gcmVjZWl2ZWQgb3IgdGhlIGAnZW5kJ2AgZXZlbnQgZW1pdHRlZCxcbiAgLy8gZm9yIGV4YW1wbGUsIGlmIHRoZSBzb2NrZXQgd2FzIGRlc3Ryb3llZCBkdWUgdG8gYW4gZXJyb3IuIEVuc3VyZSB0aGF0IHRoZVxuICAvLyBgcmVjZWl2ZXJgIHN0cmVhbSBpcyBjbG9zZWQgYWZ0ZXIgd3JpdGluZyBhbnkgcmVtYWluaW5nIGJ1ZmZlcmVkIGRhdGEgdG9cbiAgLy8gaXQuIElmIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSBzb2NrZXQgaXMgaW4gZmxvd2luZyBtb2RlIHRoZW4gdGhlcmUgaXMgbm9cbiAgLy8gYnVmZmVyZWQgZGF0YSBhcyBldmVyeXRoaW5nIGhhcyBiZWVuIGFscmVhZHkgd3JpdHRlbiBhbmQgYHJlYWRhYmxlLnJlYWQoKWBcbiAgLy8gd2lsbCByZXR1cm4gYG51bGxgLiBJZiBpbnN0ZWFkLCB0aGUgc29ja2V0IGlzIHBhdXNlZCwgYW55IHBvc3NpYmxlIGJ1ZmZlcmVkXG4gIC8vIGRhdGEgd2lsbCBiZSByZWFkIGFzIGEgc2luZ2xlIGNodW5rLlxuICAvL1xuICBpZiAoXG4gICAgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCAmJlxuICAgICF3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJlxuICAgICF3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCAmJlxuICAgIChjaHVuayA9IHdlYnNvY2tldC5fc29ja2V0LnJlYWQoKSkgIT09IG51bGxcbiAgKSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci53cml0ZShjaHVuayk7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuXG4gIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XG5cbiAgaWYgKFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICApIHtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRmluaXNoKTtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRGF0YShjaHVuaykge1xuICBpZiAoIXRoaXNba1dlYlNvY2tldF0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG4gIHRoaXMuZW5kKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgdGhpcy5vbignZXJyb3InLCBOT09QKTtcblxuICBpZiAod2Vic29ja2V0KSB7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ably/node_modules/ws/lib/websocket.js\n");

/***/ })

};
;